protocol RDPEUSB with
BinaryEncodingDefaults{Endian = Endian.Little},
Documentation
{
    ProtocolName = "Remote Desktop Protocol: USB Devices Virtual Channel Extension",
    ShortName = "RDPEUSB",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References =
        [
            new Reference{Name = "MS-RDPEUSB", Version = "12.0", Date = "01/31/2013", ProgramName = ProgramName.MCPP},
        ],
    RevisionSummary =
        [
            new Revision{Class=RevisionClass.Major, Version="376320", Date="04/07/2015"}
        ]
};

using Standard;
using Utility;
using RDPEDYC;
using InfrastructureResources;

endpoint Server over RDPEDYC.Server
    provides OperationContract consumes OperationContract;
client endpoint Client connected to Server;
    
autostart actor ServerOverRDPEDYC(RDPEDYC.Server server)
{
    map<uint, uint> RequestInterfaceId = {};
    map<uint, uint> RequestMessageId = {};
    map<uint, uint> AddDeviceUsbDevice = {};
    map<uint, uint> QueryDeviceTextInterfaceId = {};
    map<uint, uint> QueryDeviceTextMessageId = {};
    map<uint, uint> RequestCompletion = {};
    map<uint, uint> QueryInterfaceRequestFromClientInterfaceId = {};
    map<uint, uint> QueryInterfaceRequestFromClientMessageId = {};
    map<uint, uint> QueryInterfaceRequestFromServerInterfaceId = {};
    map<uint, uint> QueryInterfaceRequestFromServerMessageId = {};
    map<ulong, ushort> QueryTsUrbFunctionFromChannelIdRequestId = {};
    ushort TsUrbFunction = 0xFFFF;
    
    // Common IDs for all interfaces are as follows.
    process server accepts d:RDPEDYC.DVCDataPDU where d#EDYCChannelName != nothing && d#EDYCChannelName == "URBDRC" && d.Data.Count != 0
    {
        if (d.Data.Segment(8, 4) == $[02000000] && d.Data.Count == 28)
        {
            switch (d.Data)
            {
                case m:OperationContract.RimQueryInterfaceRequest from BinaryDecoder<OperationContract.RimQueryInterfaceRequest> =>
                    QueryInterfaceRequestFromClientInterfaceId[d.ChannelId] = m.Header.GetInterfaceId();
                    QueryInterfaceRequestFromClientMessageId[d.ChannelId] = m.Header.MessageId;
                    dispatch (endpoint Server over server) accepts m;
                default => 
                    ThrowDecodingException("RDPEUSB", "RimQueryInterfaceRequest");
            }
        }
        else if ((d.ChannelId in QueryInterfaceRequestFromServerInterfaceId && d.ChannelId in QueryInterfaceRequestFromServerMessageId) 
                && MatchIDandMask(d.Data.Segment(0, 8), QueryInterfaceRequestFromServerInterfaceId[d.ChannelId], QueryInterfaceRequestFromServerMessageId[d.ChannelId], 0x0) )
        {
            switch (d.Data)
            {
                case m:OperationContract.RimQueryInterfaceResponse from BinaryDecoder<OperationContract.RimQueryInterfaceResponse> =>
                    dispatch (endpoint Server over server) accepts m;
                default => 
                    ThrowDecodingException("RDPEUSB", "RimQueryInterfaceResponse");
            }
        }
        else if ( (d.ChannelId in RequestInterfaceId && d.ChannelId in RequestMessageId) 
                && MatchIDandMask(d.Data.Segment(0, 8), RequestInterfaceId[d.ChannelId], RequestMessageId[d.ChannelId], 0x0) 
                && d.Data.Segment(8, 4) == $[01000000] )
        {
            switch (d.Data)
            {
                case m:OperationContract.RimExchangeCapabilityResponse from BinaryDecoder<OperationContract.RimExchangeCapabilityResponse> =>
                    dispatch (endpoint Server over server) accepts m;
                default => 
                    ThrowDecodingException("RDPEUSB", "RimExchangeCapabilityResponse");
            }
        }
        else if ( d.Data.Segment(0, 4) == $[01000040] && d.Data.Segment(8, 4) == $[00010000] )
        {
            switch (d.Data)
            {
                case m:OperationContract.AddVirtualChannel from BinaryDecoder<OperationContract.AddVirtualChannel> =>
                    dispatch (endpoint Server over server) accepts m;
                default => 
                    ThrowDecodingException("RDPEUSB", "AddVirtualChannel");
            }
        }
        else if ( d.Data.Segment(0, 4) == $[01000040] && d.Data.Segment(8, 4) == $[01010000] )
        {
            switch (d.Data)
            {
                case m:OperationContract.AddDevice from BinaryDecoder<OperationContract.AddDevice> =>
                    AddDeviceUsbDevice[d.ChannelId] = m.UsbDevice;
                    dispatch (endpoint Server over server) accepts m;
                default => 
                    ThrowDecodingException("RDPEUSB", "AddDevice");
            }
        }
        else if ( d.Data.Segment(0, 4) == $[03000040] && d.Data.Segment(8, 4) == $[00010000] )
        {
            switch (d.Data)
            {
                case m:OperationContract.ChannelCreated from BinaryDecoder<OperationContract.ChannelCreated> =>
                    dispatch (endpoint Server over server) accepts m;
                default => 
                    ThrowDecodingException("RDPEUSB", "ChannelCreated");
            }
        }
        else if ( d.ChannelId in QueryDeviceTextInterfaceId 
                && MatchIDandMask(d.Data.Segment(0, 8), QueryDeviceTextInterfaceId[d.ChannelId], QueryDeviceTextMessageId[d.ChannelId], 0x2))
        {
            switch (d.Data)
            {
                case m:OperationContract.QueryDeviceTextRsp from BinaryDecoder<OperationContract.QueryDeviceTextRsp> =>
                    dispatch (endpoint Server over server) accepts m;
                default => 
                    ThrowDecodingException("RDPEUSB", "QueryDeviceTextRsp");
            }
        }
        else if ( d.ChannelId in RequestCompletion 
                && MatchInterfaceID(d.Data.Segment(0, 8), RequestCompletion[d.ChannelId], 0x1) 
                && d.Data.Segment(8, 4) == $[00010000] )
        {
            switch (d.Data)
            {
                case m:OperationContract.IOControlCompletion from BinaryDecoder<OperationContract.IOControlCompletion> =>
                    dispatch (endpoint Server over server) accepts m;
                default => 
                    ThrowDecodingException("RDPEUSB", "IOControlCompletion");
            }
        }
        else if ( d.ChannelId in RequestCompletion 
            && MatchInterfaceID(d.Data.Segment(0, 8), RequestCompletion[d.ChannelId], 0x1) 
            && d.Data.Segment(8, 4) == $[01010000] )
        {
            //determine TsUrbFunction based on channel Id and requestId in URBCompletion
            uint requestId = BinaryDecoder<uint>(d.Data.Segment(12, 4)) as uint;
            ulong chreqId = (((d.ChannelId as ulong) << 32) + requestId) as ulong;  
            if(chreqId in QueryTsUrbFunctionFromChannelIdRequestId)
            {        
                TsUrbFunction = QueryTsUrbFunctionFromChannelIdRequestId[chreqId];
            }
            else
            {
                TsUrbFunction = 0xFFFF;
            }
            var cm = BinaryDecoder<OperationContract.URBCompletion[TsUrbFunction]>(d.Data);
            if (cm != nothing)
            {
                OperationContract.URBCompletion[TsUrbFunction] m = cm as OperationContract.URBCompletion[TsUrbFunction];
                if (TsUrbFunction == 0xFFFF)
                {
                    ValidationCheck(TsUrbFunction == 0xFFFF, null, "RDPEUSB: Missing TransferInRequest message.");
                    TsUrbFunction = 0xFFFF;
                }
                dispatch (endpoint Server) accepts m;
            }
            else
            {
                ThrowDecodingException("RDPEUSB", "URBCompletion");
            }            
        }
        else if ( d.ChannelId in RequestCompletion 
            && MatchInterfaceID(d.Data.Segment(0, 8), RequestCompletion[d.ChannelId], 0x1) 
            && d.Data.Segment(8, 4) == $[02010000] )
        {
            //determine TsUrbFunction based on channel Id and requestId in URBCompletionNoData
            uint requestId = BinaryDecoder<uint>(d.Data.Segment(12, 4)) as uint;
            ulong chreqId = (((d.ChannelId as ulong) << 32) + requestId) as ulong;
            if(chreqId in QueryTsUrbFunctionFromChannelIdRequestId)
            {
                TsUrbFunction = QueryTsUrbFunctionFromChannelIdRequestId[chreqId];
            } 
            else
            {
                TsUrbFunction = 0xFFFF;
            } 
            var cm = BinaryDecoder<OperationContract.URBCompletionNoData[TsUrbFunction]>(d.Data);
        
            if (cm != nothing)
            {
                OperationContract.URBCompletionNoData[TsUrbFunction] m = cm as OperationContract.URBCompletionNoData[TsUrbFunction];
                if (TsUrbFunction == 0xFFFF)
                {
                    ValidationCheck(TsUrbFunction == 0xFFFF, null, "RDPEUSB: Missing TransferInRequest message.");
                    TsUrbFunction = 0xFFFF;
                }
                dispatch (endpoint Server) accepts m;
            }
            else
            {
                ThrowDecodingException("RDPEUSB", "URBCompletionNoData");
            }                       
        }
        else
        {
            ThrowDecodingException("RDPEUSB", UTILITY_LOST_INFO, []);
        }
    }
    
    // Common IDs for all interfaces are as follows.
    process server issues d:RDPEDYC.DVCDataPDU where d#EDYCChannelName != nothing && d#EDYCChannelName == "URBDRC" && d.Data.Count != 0
    {
        if ( d.Data.Segment(8, 4) == $[01000000] && d.Data.Count == 12 )
        {
            switch (d.Data)
            {
                case m:OperationContract.RimCallRelease from BinaryDecoder<OperationContract.RimCallRelease> =>
                    dispatch (endpoint Server over server) issues m;
                default => 
                    ThrowDecodingException("RDPEUSB", "RimCallRelease");
            }
        }
        else if (d.Data.Segment(8, 4) == $[02000000] && d.Data.Count == 28)
        {
            switch (d.Data)
            {
                case m:OperationContract.RimQueryInterfaceRequest from BinaryDecoder<OperationContract.RimQueryInterfaceRequest> =>
                    QueryInterfaceRequestFromServerInterfaceId[d.ChannelId] = m.Header.GetInterfaceId();
                    QueryInterfaceRequestFromServerMessageId[d.ChannelId] = m.Header.MessageId;
                    dispatch (endpoint Server over server) issues m;
                default => 
                    ThrowDecodingException("RDPEUSB", "RimQueryInterfaceRequest");
            }
        }
        else if ((d.ChannelId in QueryInterfaceRequestFromClientInterfaceId && d.ChannelId in QueryInterfaceRequestFromClientMessageId) 
                && MatchIDandMask(d.Data.Segment(0, 8), QueryInterfaceRequestFromClientInterfaceId[d.ChannelId], QueryInterfaceRequestFromClientMessageId[d.ChannelId], 0x0) )
        {
            switch (d.Data)
            {
                case m:OperationContract.RimQueryInterfaceResponse from BinaryDecoder<OperationContract.RimQueryInterfaceResponse> =>
                    dispatch (endpoint Server over server) issues m;
                default => 
                    ThrowDecodingException("RDPEUSB", "RimQueryInterfaceResponse");
            }
        }
        else if ( d.Data.Segment(0, 4) == $[00000000] && d.Data.Segment(8, 4) == $[00010000] )
        {
            switch (d.Data)
            {
                case m:OperationContract.RimExchangeCapabilityRequest from BinaryDecoder<OperationContract.RimExchangeCapabilityRequest> =>
                    RequestInterfaceId[d.ChannelId] = m.Header.GetInterfaceId();
                    RequestMessageId[d.ChannelId] = m.Header.MessageId;
                    dispatch (endpoint Server over server) issues m;
                default => 
                    ThrowDecodingException("RDPEUSB", "RimExchangeCapabilityRequest");
            }
        }
        else if ( d.Data.Segment(0, 4) == $[02000040] && d.Data.Segment(8, 4) == $[00010000] )
        {
            switch (d.Data)
            {
                case m:OperationContract.ChannelCreated from BinaryDecoder<OperationContract.ChannelCreated> =>
                    dispatch (endpoint Server over server) issues m;
                default => 
                    ThrowDecodingException("RDPEUSB", "ChannelCreated");
            }
        }
        else if ( d.ChannelId in AddDeviceUsbDevice 
            && MatchInterfaceID(d.Data.Segment(0, 8), AddDeviceUsbDevice[d.ChannelId], 0x1) 
            && d.Data.Segment(8, 4) == $[00010000] )
        {
            switch (d.Data)
            {
                case m:OperationContract.CancelRequest from BinaryDecoder<OperationContract.CancelRequest> =>
                    dispatch (endpoint Server over server) issues m;
                default => 
                    ThrowDecodingException("RDPEUSB", "CancelRequest");
            }
        }
        else if ( d.ChannelId in AddDeviceUsbDevice 
            && MatchInterfaceID(d.Data.Segment(0, 8), AddDeviceUsbDevice[d.ChannelId], 0x1) 
            && d.Data.Segment(8, 4) == $[01010000] )
        {
            switch (d.Data)
            {
                case m:OperationContract.RegisterRequestCallback from BinaryDecoder<OperationContract.RegisterRequestCallback> =>
                    RequestCompletion[d.ChannelId] = m.RequestCompletion as uint;
                    dispatch (endpoint Server over server) issues m;
                default => 
                    ThrowDecodingException("RDPEUSB", "RegisterRequestCallback");
            }
        }
        else if ( d.ChannelId in AddDeviceUsbDevice 
            && MatchInterfaceID(d.Data.Segment(0, 8), AddDeviceUsbDevice[d.ChannelId], 0x1) 
            && d.Data.Segment(8, 4) == $[02010000] )
        {
            switch (d.Data)
            {
                case m:OperationContract.IOControl from BinaryDecoder<OperationContract.IOControl> =>
                    dispatch (endpoint Server over server) issues m;
                default => 
                    ThrowDecodingException("RDPEUSB", "IOControl");
            }
        }
        else if ( d.ChannelId in AddDeviceUsbDevice 
            && MatchInterfaceID(d.Data.Segment(0, 8), AddDeviceUsbDevice[d.ChannelId], 0x1) 
            && d.Data.Segment(8, 4) == $[03010000] )
        {
            switch (d.Data)
            {
                case m:OperationContract.InternalIOControl from BinaryDecoder<OperationContract.InternalIOControl> =>
                    dispatch (endpoint Server over server) issues m;
                default => 
                    ThrowDecodingException("RDPEUSB", "InternalIOControl");
            }
        }
        else if ( d.ChannelId in AddDeviceUsbDevice 
            && MatchInterfaceID(d.Data.Segment(0, 8), AddDeviceUsbDevice[d.ChannelId], 0x1) 
            && d.Data.Segment(8, 4) == $[04010000] )
        {
            switch (d.Data)
            {
                case m:OperationContract.QueryDeviceText from BinaryDecoder<OperationContract.QueryDeviceText> =>
                    QueryDeviceTextInterfaceId[d.ChannelId] = m.Header.GetInterfaceId();
                    QueryDeviceTextMessageId[d.ChannelId] = m.Header.MessageId;
                    dispatch (endpoint Server over server) issues m;
                default => 
                    ThrowDecodingException("RDPEUSB", "QueryDeviceText");
            }
        }
        else if ( d.ChannelId in AddDeviceUsbDevice 
            && MatchInterfaceID(d.Data.Segment(0, 8), AddDeviceUsbDevice[d.ChannelId], 0x1) 
            && d.Data.Segment(8, 4) == $[05010000] )
        {
            switch (d.Data)
            {
                case m:OperationContract.TransferInRequest from BinaryDecoder<OperationContract.TransferInRequest> =>
                    ulong chreqId = (((d.ChannelId as ulong) << 32) + (m.TsUrb.TsUrbHeader.RequestIdAndNoAck.RequestId as uint)) as ulong;
                    QueryTsUrbFunctionFromChannelIdRequestId[chreqId] = m.TsUrb.TsUrbHeader.UrbFunction;
                    dispatch (endpoint Server over server) issues m;
                default => 
                    ThrowDecodingException("RDPEUSB", "TransferInRequest");
            }
        }
        else if ( d.ChannelId in AddDeviceUsbDevice 
            && MatchInterfaceID(d.Data.Segment(0, 8), AddDeviceUsbDevice[d.ChannelId], 0x1) 
            && d.Data.Segment(8, 4) == $[06010000] )
        {
            switch (d.Data)
            {
                case m:OperationContract.TransferOutRequest from BinaryDecoder<OperationContract.TransferOutRequest> =>
                    ulong chreqId = (((d.ChannelId as ulong) << 32) + (m.TsUrb.TsUrbHeader.RequestIdAndNoAck.RequestId as uint)) as ulong;
                    QueryTsUrbFunctionFromChannelIdRequestId[chreqId] = m.TsUrb.TsUrbHeader.UrbFunction;
                    dispatch (endpoint Server over server) issues m;
                default => 
                    ThrowDecodingException("RDPEUSB", "TransferOutRequest");
            }
        }
        else if ( d.ChannelId in AddDeviceUsbDevice 
            && MatchInterfaceID(d.Data.Segment(0, 8), AddDeviceUsbDevice[d.ChannelId], 0x1) 
            && d.Data.Segment(8, 4) == $[07010000] )
        {
            switch (d.Data)
            {
                case m:OperationContract.RetractDevice from BinaryDecoder<OperationContract.RetractDevice> =>
                    dispatch (endpoint Server over server) issues m;
                default => 
                    ThrowDecodingException("RDPEUSB", "RetractDevice");
            }
        }
        else
        {
            ThrowDecodingException("RDPEUSB", UTILITY_LOST_INFO, []);
        }
    }
    
    ~endpoint(RDPEDYC.Server server)
    {
        RequestInterfaceId = {};
        RequestMessageId = {};
        AddDeviceUsbDevice = {};
        QueryDeviceTextInterfaceId = {};
        QueryDeviceTextMessageId = {};
        RequestCompletion = {};
        QueryInterfaceRequestFromClientInterfaceId = {};
        QueryInterfaceRequestFromClientMessageId = {};
        QueryInterfaceRequestFromServerInterfaceId = {};
        QueryInterfaceRequestFromServerMessageId = {};
        QueryTsUrbFunctionFromChannelIdRequestId = {};
    }
}

bool MatchIDandMask(binary data, uint interfaceId, uint messageId, uint mask)
{
    bool result = false;
    
    var d = BinaryDecoder<SharedMessageHeader[true, FunctionIdType.FunctionIdType_CommonIds]>(data);
    if(d == nothing)
    {
        return result;
    }
    SharedMessageHeader[true, FunctionIdType.FunctionIdType_CommonIds] header = d as SharedMessageHeader;
    
    if (mask == 0x0)
    {
        if (header.GetInterfaceId() == interfaceId && header.MessageId == messageId)
        {
            result = true;
        }
    }
    else
    {
        if (header.GetInterfaceId() == interfaceId && header.MessageId == messageId && header.InterfaceIdAndMask.Mask == mask)
        {
            result = true;
        }
    }
    
    return result;
}

bool MatchInterfaceID(binary data, uint interfaceId, int mask)
{
    bool result = false;
    
    var d = BinaryDecoder<SharedMessageHeader[true, FunctionIdType.FunctionIdType_CommonIds]>(data);
    if(d == nothing)
    {
        return result;
    }
    SharedMessageHeader[true, FunctionIdType.FunctionIdType_CommonIds] header = d as SharedMessageHeader;

    if (header.GetInterfaceId() == interfaceId && header.InterfaceIdAndMask.Mask == mask)
    {
        result = true;
    }
    
    return result;
}

contract OperationContract
{
    // [MS-RDPEXPS] 2.2.2.2 Interface Release (IFACE_RELEASE)
    message RimCallRelease
    {
        SharedMessageHeader[false, FunctionIdType.FunctionIdType_CommonIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field MUST be set to 0x00000000. The Mask field MUST be set to STREAM_ID_NONE. The FunctionId field MUST be set to RIM_EXCHANGE_CAPABILITY_REQUEST (0x00000100)."};
        
        override string ToString()
        {
            return "RimCallRelease, Release the given interface ID: " + (Header.GetInterfaceId() as string);
        }
    }
    
    // [MS-RDPEXPS] 2.2.2.1.1 Query Interface Request (QI_REQ)
    message RimQueryInterfaceRequest
    {
        SharedMessageHeader[false, FunctionIdType.FunctionIdType_CommonIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field MUST be set to 0x00000000. The Mask field MUST be set to STREAM_ID_NONE. The FunctionId field MUST be set to RIM_EXCHANGE_CAPABILITY_REQUEST (0x00000100)."};
        GUID NewInterfaceGUID;
        
        override string ToString()
        {
            return "RimQueryInterfaceRequest, Query for a new interface ID: " + (Header.GetInterfaceId() as string);
        }
    }
    
    // [MS-RDPEXPS] 2.2.2.1.2 Query Interface Response (QI_RSP)
    message RimQueryInterfaceResponse
    {
        SharedMessageHeader[true, FunctionIdType.FunctionIdType_CommonIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field MUST be set to 0x00000000. The Mask field MUST be set to STREAM_ID_NONE. The FunctionId field MUST be set to RIM_EXCHANGE_CAPABILITY_REQUEST (0x00000100)."};
        uint NewInterfaceGUID;
        
        override string ToString()
        {
            return "RimQueryInterfaceResponse, Query for a new interface ID: " + (Header.GetInterfaceId() as string);
        }
    }
    
    // 2.2.3.1   Interface Manipulation Exchange Capabilities Request (RIM_EXCHANGE_CAPABILITY_REQUEST)
    message RimExchangeCapabilityRequest
    {
        SharedMessageHeader[false, FunctionIdType.FunctionIdType_CapabilitiesNegotiatorInterfaceIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field MUST be set to 0x00000000. The Mask field MUST be set to STREAM_ID_NONE. The FunctionId field MUST be set to RIM_EXCHANGE_CAPABILITY_REQUEST (0x00000100)."};
        uint CapabilityValue where ValidationCheckValue(value == 0x00000001, null, true, ReferenceType.Message, "RDPEUSB", "CapabilityValue", "RimExchangeCapabilityRequest", "0x00000001", value)
            with Documentation{Description = "A 32-bit unsigned integer that identifies the server\'s capability. The valid values for this field are as follows."}
            with DisplayInfo{ToText = CapabilityValueToString};
        
        override string ToString()
        {
            return "RimExchangeCapabilityRequest";
        }
    } with Documentation{Applicability = "2.2.3.1", Description = "This message is used by the server to request interface manipulation capabilities from the client."};
    
    
    // 2.2.3.2   Interface Manipulation Exchange Capabilities Response (RIM_EXCHANGE_CAPABILITY_RESPONSE)
    message RimExchangeCapabilityResponse
    {
        SharedMessageHeader[true, FunctionIdType.FunctionIdType_CapabilitiesNegotiatorInterfaceIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field and the MessageId field in this message header SHOULD contain the same values as the InterfaceId and MessageId fields in the corresponding RIM_EXCHANGE_CAPABILITY_REQUEST message. The Mask field MUST be set to STREAM_ID_NONE."};
        uint CapabilityValue with Documentation{Description = "A 32-bit unsigned integer that identifies the client\'s capability. The valid values for this field are as follows."}
            with DisplayInfo{ToText = CapabilityValueToString};
        uint Result with Documentation{Description = "A 32-bit unsigned integer that indicates the HRESULT of the operation."};
        
        override string ToString()
        {
            return "RimExchangeCapabilityResponse, Result: " + (Result as string);
        }
    } with Documentation{Applicability = "2.2.3.2", Description = "This message is sent by the client in response to RIM_EXCHANGE_CAPABILITY_REQUEST."};
    
    
    // 2.2.4.1   Add Virtual Channel Message (ADD_VIRTUAL_CHANNEL)
    message AddVirtualChannel
    {
        SharedMessageHeader[false, FunctionIdType.FunctionIdType_ClientDeviceSinkInterfaceIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field MUST be set to 0x00000001. The Mask field MUST be set to STREAM_ID_PROXY. The FunctionId field MUST be set to ADD_VIRTUAL_CHANNEL (0x00000100)."};
        
        override string ToString()
        {
            return "AddVirtualChannel";
        }
    } with Documentation{Applicability = "2.2.4.1", Description = "The ADD_VIRTUAL_CHANNEL message is sent from the client to the server to create a new instance of dynamic virtual channel."};
    
    
    // 2.2.4.2   Add Device Message (ADD_DEVICE)
    message AddDevice
    {
        SharedMessageHeader[false, FunctionIdType.FunctionIdType_ClientDeviceSinkInterfaceIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field MUST be set to 0x00000001. The Mask field MUST be set to STREAM_ID_PROXY. The FunctionId field MUST be set to ADD_DEVICE (0x00000101)."};
        uint NumUsbDevice where value == 0x00000001 
            with Documentation {Description = "A 32-bit unsigned integer. MUST be set to 0x00000001."};
        uint UsbDevice with Documentation{Description = "A 32-bit unsigned integer. A unique interface ID to be used by request messages defined in USB device interface."};
        uint CchDeviceInstanceId with Documentation{Description = "A 32-bit unsigned integer. This field MUST contain the number of Unicode characters in the DeviceInstanceId field."};
        string DeviceInstanceId with BinaryEncoding{Length = CchDeviceInstanceId}, Documentation{Description = "An array of bytes. A variable-length field that contains a null-terminated Unicode string that identifies an instance of a USB device."};
        uint CchHwIds 
            with Documentation{Description = "A 32-bit unsigned integer. This field MUST contain the number of Unicode characters in the HardwareIds field. This field MAY be 0x00000000."};
        optional [| CchHwIds != 0 |] array<string> HardwareIds 
            with BinaryEncoding{WidthForComposedType = CchHwIds * 16 as int}, 
                Documentation {Description = "An array of bytes. A variable-length field that specifies a multisz string representing the hardware IDs of the client-side device. If the value in the cchHwIds field is 0x00000000, the HardwareIds buffer MUST NOT be present."};
        uint CchCompatIds with Documentation{Description = "A 32-bit unsigned integer. This field MUST contain the number of Unicode characters in the CompatibilityIds field."};
        optional [| CchCompatIds != 0 |] array<string> CompatibilityIds 
            with BinaryEncoding{WidthForComposedType = CchCompatIds * 16 as int}, 
                Documentation{Description = "An array of bytes. A variable-length field that specifies a multisz string representing the compatibility IDs of the client-side device. If the value in the cchCompatIds field is 0x00000000, the CompatibilityIds buffer MUST NOT be present."};
        uint CchContainerId with Documentation{Description = "A 32-bit unsigned integer. This field MUST contain the number of Unicode characters in the ContainerId field."};
        string ContainerId with BinaryEncoding{Length = CchContainerId}, Documentation{Description = "An array of bytes. A variable-length field that contains a null-terminated Unicode string that contains the container ID in GUID, as specified in [MS-DTYP] section , format of the USB device. A group of devices that represent the same physical unit share the same container ID. The value of the container ID MUST be unique and MUST not be set to zero."};
        UsbDeviceCapabilities UsbDeviceCapabilities with Documentation{Description = "A 28-byte structure as specified in section ."};
        
        override string ToString()
        {
            return "AddDevice, UsbDevice: " + (UsbDevice as string);
        }
    } with Documentation{Applicability = "2.2.4.2", Description = "The ADD_DEVICE message is sent from the client to the server in order to create a redirected USB device on the server."};
    
    
    // 2.2.5.1   Channel Created Message (CHANNEL_CREATED)
    message ChannelCreated
    {
        SharedMessageHeader[false, FunctionIdType.FunctionIdType_ChannelNotificationInterfaceIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field MUST be set to 0x00000002 if sent by the server and it MUST be set to 0x000000003 if sent by the client. The Mask field MUST be set to STREAM_ID_PROXY. The FunctionId field MUST be set to CHANNEL_CREATED (0x00000100)."};
        uint MajorVersion where ValidationCheckValue(value == 1, this, true, ReferenceType.Message, "RDPBCGR", "MajorVersion", "ChannelCreated", 1, value)
            with Documentation{Description = "A 32-bit unsigned integer. The major version of RDP USB redirection supported. This value MUST be set to one."};
        uint MinorVersion where ValidationCheckZero(value == 0, this, true, ReferenceType.Message, "RDPBCGR", "MinorVersion", "ChannelCreated", value)
            with Documentation{Description = "A 32-bit unsigned integer. The minor version of RDP USB redirection supported. This value MUST be set to zero."};
        uint Capabilities where ValidationCheckZero(value == 0, this, true, ReferenceType.Message, "RDPBCGR", "Capabilities", "ChannelCreated", value)
            with Documentation{Description = "A 32-bit unsigned integer. The capabilities of RDP USB redirection supported. This value MUST be set to zero."};
        
        override string ToString()
        {
            return "ChannelCreated";
        }
    } with Documentation{Applicability = "2.2.5.1",Description = "The CHANNEL_CREATED message is sent from both the client and the server to inform the other side of the RDP USB device redirection version supported."};
    
    
    // 2.2.6.1   Cancel Request Message (CANCEL_REQUEST)
    message CancelRequest
    {
        SharedMessageHeader[false, FunctionIdType.FunctionIdType_ServerUSBDeviceInterfaceIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field MUST match the value sent previously in the UsbDevice field of the ADD_DEVICE message. The Mask field MUST be set to STREAM_ID_PROXY. The FunctionId field MUST be set to CANCEL_REQUEST (0x00000100)."};
        uint RequestId 
            with Documentation{Description = "A 32-bit unsigned integer. This value represents the ID of a request previously sent via IO_CONTROL, INTERNAL_IO_CONTROL, TRANSFER_IN_REQUEST, or TRANSFER_OUT_REQUEST message."},
                DisplayInfo{ToText = ServerUsbDeviceInterfaceIDToString};
        
        override string ToString()
        {
            return "CancelRequest, RequestId: " + (RequestId as string);
        }
    } with Documentation{Applicability = "2.2.6.1", Description = "The CANCEL_REQUEST message is sent from the server to the client to cancel an outstanding IO request."};
    
    
    // 2.2.6.2   Register Request Callback Message (REGISTER_REQUEST_CALLBACK)
    message RegisterRequestCallback
    {
        SharedMessageHeader[false, FunctionIdType.FunctionIdType_ServerUSBDeviceInterfaceIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field MUST match the value sent previously in the UsbDevice field of the ADD_DEVICE message. The Mask field MUST be set to STREAM_ID_PROXY. The FunctionId field MUST be set to REGISTER_REQUEST_CALLBACK (0x00000101)."};
        uint NumRequestCompletion 
            with Documentation{Description = "A 32-bit unsigned integer. If this field is set to 0x00000001 or greater, then the RequestCompletion field is also present. If this field is set to 0x0000000, the RequestCompletion field is not present."};
        optional [|NumRequestCompletion >= 0x00000001|] uint RequestCompletion with Documentation{Description = "A 32-bit unsigned integer. A unique InterfaceID to be used by all Request Completion messages defined in the Request Completion Interface (section )."};
        
        override string ToString()
        {
            string summary = "RegisterRequestCallback";
            if (RequestCompletion != nothing)
            {
                summary += ", RequestCompletion: " + (RequestCompletion as string);
            }
            return summary;
        }
    } with Documentation{Applicability = "2.2.6.2", Description = "The REGISTER_REQUEST_CALLBACK message is sent from the server to the client in order to provide a Request Completion Interface to the client."};
    
    
    // 2.2.6.3   IO Control Message (IO_CONTROL)
    message IOControl
    {
        SharedMessageHeader[false, FunctionIdType.FunctionIdType_ServerUSBDeviceInterfaceIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field MUST match the value sent previously in the UsbDevice field of the ADD_DEVICE message. The Mask field MUST be set to STREAM_ID_PROXY. The FunctionId field MUST be set to IO_CONTROL (0x00000102)."};
        IOControlCode IoControlCode with Documentation{Description = "A 32-bit unsigned integer. An IO control code as specified in section ."};
        uint InputBufferSize with Documentation{Description = "A 32-bit unsigned integer. The size, in bytes, of the InputBuffer field."};
        optional [|InputBufferSize != 0|] binary InputBuffer with BinaryEncoding{Length = InputBufferSize}, Documentation{Description = "A byte array. This value represents the input buffer for the IO control request."};
        uint OutputBufferSize with Documentation{Description = "A 32-bit unsigned integer. The maximum number of bytes the client can return to the server."};
        uint RequestId with Documentation{Description = "A 32-bit unsigned integer. This ID uniquely identifies the I/O control request."};
        
        override string ToString()
        {
            return "IOControl, IOControlCode: " + IOControlCodeFunction(IoControlCode.Function as uint) + ", RequestId: " + (RequestId as string);
        }
    } with Documentation{Applicability = "2.2.6.3", Description = "The IO_CONTROL message is sent from the server to the client in order to submit an IO control request to the USB device."};
    
    
    // 2.2.6.4   Internal IO Control Message (INTERNAL_IO_CONTROL)
    message InternalIOControl
    {
        SharedMessageHeader[false, FunctionIdType.FunctionIdType_ServerUSBDeviceInterfaceIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field MUST match the value sent previously in the UsbDevice field of the ADD_DEVICE message. The Mask field MUST be set to STREAM_ID_PROXY. The FunctionId field MUST be set to INTERNAL_IO_CONTROL (0x00000103)."};
        UsbInternalIoControlCode IoControlCode  
            where ValidationCheckValue(value == 0x00224000, this, false, ReferenceType.Message, "RDPEUSB", "IoControlCode", "InternalIOControl", "0x00224000 ", value)
            with Documentation{Description = "A 32-bit unsigned integer. An internal IO control code as specified in section ."};
        uint InputBufferSize with Documentation{Description = "A 32-bit unsigned integer. The size, in bytes, of the InputBuffer field."};
        optional [|InputBufferSize != 0|] binary InputBuffer with BinaryEncoding{Length = InputBufferSize},Documentation{Description = "A byte array. This value represents the input buffer for the internal IO control request."};
        uint OutputBufferSize with Documentation{Description = "A 32-bit unsigned integer. The maximum number of bytes the internal IO control request can return."};
        uint RequestId with Documentation{Description = "A 32-bit unsigned integer. This value represents an ID that uniquely identifies this internal IO control request."};
        
        override string ToString()
        {
            return "InternalIOControl, IoControlCode: " + IOControlCodeFunction(((IoControlCode >> 2) & 0x00000fff) as uint) + ", RequestId: " + (RequestId as string);
        }
    } with Documentation{Applicability = "2.2.6.4", Description = "The INTERNAL_IO_CONTROL message is sent from the server to the client in order to submit an internal IO control request to the USB device."};
    
    
    // 2.2.6.5   Query Device Text Message (QUERY_DEVICE_TEXT)
    message QueryDeviceText
    {
        SharedMessageHeader[false, FunctionIdType.FunctionIdType_ServerUSBDeviceInterfaceIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field MUST match the value sent previously in the UsbDevice field of the ADD_DEVICE message. The Mask field MUST be set to STREAM_ID_PROXY. The FunctionId field MUST be set to QUERY_DEVICE_TEXT (0x00000104)."};
        uint TextType with Documentation{Description = "A 32-bit unsigned integer. This value represents the type of text to query as described in [MSFT-W2KDDK], Volume 1, Part 1, Chapter 2."};
        uint LocaleId with DisplayInfo{ToText = LocaleIdToString},
            Documentation{Description = "A 32-bit unsigned integer. This value represents the locale of the text to query as described in [MSFT-W2KDDK], Volume 1, Part 1, Chapter 2."};
        
        override string ToString()
        {
            return "QueryDeviceText, TextType: " + (TextType as string) + ", LocaleId: " + LocaleIdToString(LocaleId);
        }
        
        static string LocaleIdToString(any data)
        {
            uint id = data as uint;
            switch (id)
            {
                case 0x0409 => return "English - United States";
                case 0x0413 => return "Dutch - Netherlands";
                case 0x040c => return "French - France";
                case 0x0407 => return "German - Germany";
                case 0x0410 => return "Italian - Italy";
                case 0x0411 => return "Japanese - Japan";
                case 0x0c0a => return "Spanish - Spain";
                case 0x0804 => return "Chinese - PRC";
                case 0x0c04 => return "Chinese - Hong Kong SAR";
                case 0x0404 => return "Chinese - Taiwan";
                case 0x0405 => return "Czech - Czech Republic";
                case 0x040e => return "Hungarian - Hungary";
                case 0x0412 => return "Korean - Korea";
                case 0x0415 => return "Polish - Poland";
                case 0x0416 => return "Portuguese - Brazil";
                case 0x0816 => return "Portuguese - Portugal";
                case 0x0419 => return "Russian - Russia";
                case 0x041d => return "Swedish - Sweden";
                case 0x041f => return "Turkish - Turkey";
                default => return Utility.DecToHexFormat(id);
            }
        }
    } with Documentation{Applicability = "2.2.6.5", Description = "The QUERY_DEVICE_TEXT message is sent from the server to the client in order to query the USB device\'s text when the server receives a query device test request (IRP_MN_QUERY_DEVICE_TEXT) from the system as described in [MSFT-W2KDDK], Volume 1, Part 1, Chapter 2."};
    
    
    // 2.2.6.6   Query Device Text Response Message (QUERY_DEVICE_TEXT_RSP)
    message QueryDeviceTextRsp
    {
        SharedMessageHeader[true, FunctionIdType.FunctionIdType_ServerUSBDeviceInterfaceIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId and MessageId fields in this header MUST contain the same values as the InterfaceId and MessageId fields in the corresponding QUERY_DEVICE_TEXT. The Mask field MUST be set to STREAM_ID_STUB."};
        uint CchDeviceDescription with Documentation{Description = "A 32-bit unsigned integer. This field MUST contain the number of Unicode characters in the DeviceDescription field."};
        string DeviceDescription with BinaryEncoding{Length = CchDeviceDescription}, Documentation{Description = "An array of bytes. A variable-length field that contains a null-terminated Unicode string that contains the requested device text."};
        uint HRESULT with Documentation{Description = "A 32-bit unsigned integer that indicates the HRESULT of the operation."};
        
        override string ToString()
        {
            return "QueryDeviceTextRsp, DeviceDescription: " + DeviceDescription;
        }
    } with Documentation{Applicability = "2.2.6.6", Description = "The QUERY_DEVICE_TEXT_RSP message is sent from the client in response to a QUERY_DEVICE_TEXT message sent by the server."};
    
    
    // 2.2.6.7   Transfer In Request (TRANSFER_IN_REQUEST)
    message TransferInRequest
    {
        SharedMessageHeader[false, FunctionIdType.FunctionIdType_ServerUSBDeviceInterfaceIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field MUST match the value sent previously in the UsbDevice field of the ADD_DEVICE message. The Mask field MUST be set to STREAM_ID_PROXY. The FunctionId field MUST be set to TRANSFER_IN_REQUEST (0x00000105)."};
        uint CbTsUrb with Documentation{Description = "A 32-bit unsigned integer. The size, in bytes, of the TsUrb field."};
        TsUrb TsUrb with BinaryEncoding{WidthForComposedType = (CbTsUrb as int) * 8}, Documentation {Description = "A TS_URB structure as defined in section ."};
        uint OutputBufferSize with Documentation{Description = "A 32-bit unsigned integer. This value represents the maximum number of bytes of data that is requested from the USB device."};
        
        override string ToString()
        {
            ushort URBFunction = TsUrb.TsUrbHeader.UrbFunction;
            return "TransferInRequest, TsUrb: " + UrbDataTypeCode(URBFunction);
        }
    } with Documentation{Applicability = "2.2.6.7",Description = "The TRANSFER_IN_REQUEST message is sent from the server to the client in order to request data from the USB device."};
    
    
    // 2.2.6.8   Transfer Out Request (TRANSFER_OUT_REQUEST)
    message TransferOutRequest
    {
        SharedMessageHeader[false, FunctionIdType.FunctionIdType_ServerUSBDeviceInterfaceIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field MUST match the value sent previously in the UsbDevice field of the ADD_DEVICE message. The Mask field MUST be set to STREAM_ID_PROXY. The FunctionId field MUST be set to TRANSFER_OUT_REQUEST (0x00000106)."};
        uint CbTsUrb with Documentation{Description = "A 32-bit unsigned integer. The size, in bytes, of the TsUrb field."};
        TsUrb TsUrb with BinaryEncoding{WidthForComposedType = (CbTsUrb as int) * 8}, Documentation {Description = "A TS_URB structure as defined in section ."};
        uint OutputBufferSize with Documentation{Description = "A 32-bit unsigned integer. The size in bytes of the OutputBuffer field."};
        binary OutputBuffer with BinaryEncoding{Length = OutputBufferSize}, Documentation{Description = "An array of bytes. The raw data to be sent to the device."};
        
        override string ToString()
        {
            ushort URBFunction = TsUrb.TsUrbHeader.UrbFunction;
            return "TransferOutRequest, TsUrb: " + UrbDataTypeCode(URBFunction);
        }
    } with Documentation{Applicability = "2.2.6.8", Description = "The TRANSFER_OUT_REQUEST message is sent from the server to the client in order to submit data to the USB device."};
    
    
    // 2.2.6.9   Retract Device (RETRACT_DEVICE)
    message RetractDevice
    {
        SharedMessageHeader[false, FunctionIdType.FunctionIdType_ServerUSBDeviceInterfaceIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field MUST match the value sent previously in the UsbDevice field of the ADD_DEVICE message. The Mask field MUST be set to STREAM_ID_PROXY. The FunctionId field MUST be set to RETRACT_DEVICE (0x00000107)."};
        UsbRetractReason Reason where ValidationCheckValue(value == 0x00000001, this, false, ReferenceType.Message, "RDPEUSB", "Reason", "RetractDevice", "0x00000001", value)
            with Documentation{Description = "A 32-bit unsigned integer. The reason code, as specified in section , to stop redirecting the USB device."};
        
        override string ToString()
        {
            return "RetractDevice";
        }
    } with Documentation{Applicability = "2.2.6.9", Description = "The RETRACT_DEVICE message is sent from the server to the client in order to stop redirecting the USB device."};
    
    
    // 2.2.7.1   IO Control Completion (IOCONTROL_COMPLETION)
    message IOControlCompletion
    {
        SharedMessageHeader[false, FunctionIdType.FunctionIdType_ClientRequestCompletionInterfaceIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field MUST match the value sent previously in the RequestCompletion field of the REGISTER_REQUEST_CALLBACK message. The Mask field MUST be set to STREAM_ID_PROXY. The FunctionId field MUST be set to IOCONTROL_COMPLETION (0x00000100)."};
        uint RequestId with Documentation{Description = "A 32-bit unsigned integer. This field MUST match the value sent previously in the RequestId field of the IO_CONTROL message, as specified in section ."};
        uint HRESULT with Documentation{Description = "A 32-bit unsigned integer that indicates the HRESULT of the operation."};
        uint Information with Documentation{Description = "A 32-bit unsigned integer. The number of bytes of data to be transferred by the request."};
        uint OutputBufferSize with Documentation{Description = "A 32-bit unsigned integer. The size, in bytes, of the OutputBuffer field. The value of this field MUST not exceed the value of OutputBufferSize field from IO_CONTROL message. If the HRESULT field indicates success, this field and the Information field MUST be equal. If the HRESULT field is equal to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) then this field is set to the value of OutputBufferSize from IO_CONTROL message and the Information field MUST indicate the expected size of the OutputBuffer field. For any other case this field MUST be set to 0 and the value of the Information field MUST be ignored."};
        binary OutputBuffer with BinaryEncoding{Length = OutputBufferSize}, Documentation{Description = "A data buffer that results from processing the request."};
        
        override string ToString()
        {
            return "IOControlCompletion, RequestId: " + (RequestId as string);
        }
    }with Documentation{Applicability = "2.2.7.1", Description = "The IOCONTROL_COMPLETION request is sent from the client to the server as the final result of an IO Control request or internal IO Control request."};
    
    
    // 2.2.7.2   URB Completion (URB_COMPLETION)
    message URBCompletion[ushort TsUrbFunction]
    {
        SharedMessageHeader[false, FunctionIdType.FunctionIdType_ClientRequestCompletionInterfaceIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field MUST match the value sent previously in the RequestCompletion field of the REGISTER_REQUEST_CALLBACK message. The Mask field MUST be set to STREAM_ID_PROXY. The FunctionId field MUST be set to URB_COMPLETION (0x00000101)."};
        uint RequestId with Documentation{Description = "A 32-bit unsigned integer. This field MUST match the value sent previously in the RequestId field of TsUrb structure in the TRANSFER_IN_REQUEST message."};
        uint CbTsUrbResult with Documentation{Description = "A 32-bit unsigned integer. The size, in bytes, of the TsUrbResult field."};
        TsUrbResult[TsUrbFunction] TsUrbResult with BinaryEncoding{Length = CbTsUrbResult}, Documentation {Description = "A TS_URB_RESULT structure as defined in ."};
        uint HRESULT with Documentation{Description = "A 32-bit unsigned integer that indicates the HRESULT of the operation."};
        uint OutputBufferSize with Documentation{Description = "A 32-bit unsigned integer. The size, in bytes, of the OutputBuffer field."};
        binary OutputBuffer with BinaryEncoding{Length = OutputBufferSize}, Documentation{Description = "A data buffer that results from processing the request."};
        
        override string ToString()
        {
            string summary = "URBCompletion, RequestId: " + (RequestId as string);
            if(TsUrbResult.TsUrbResultHeader.Size > 8)
            {
                summary += ", TsUrbResult: " + TsUrbResult.GetTsUrbResultDataType();
            }
            summary += ", HRESULT: " + (HRESULT as string);
            return summary;
        }
    } with Documentation{Applicability = "2.2.7.2", Description = "The URB_COMPLETION request is sent from the client to the server as the final result of a TRANSFER_IN_REQUEST that contains output data."};
    
    
    // 2.2.7.3   URB Completion No Data (URB_COMPLETION_NO_DATA)
    message URBCompletionNoData[ushort TsUrbFunction]
    {
        SharedMessageHeader[false, FunctionIdType.FunctionIdType_ClientRequestCompletionInterfaceIds] Header with Documentation{Description = "The SHARED_MSG_HEADER (as specified in section ). The InterfaceId field MUST match the value sent previously in the RequestCompletion field of the REGISTER_REQUEST_CALLBACK message. The Mask field MUST be set to STREAM_ID_PROXY. The FunctionId field MUST be set to URB_COMPLETION_NO_DATA (0x00000102)."};
        uint RequestId with Documentation{Description = "A 32-bit unsigned integer. This field MUST match the value sent previously in the RequestId field of TsUrb structure in the TRANSFER_IN_REQUEST or TRANSFER_OUT_REQUEST message."};
        uint CbTsUrbResult with Documentation{Description = "A 32-bit unsigned integer. The size, in bytes, of the TsUrbResult field."};
        TsUrbResult[TsUrbFunction] TsUrbResult with BinaryEncoding{Length = CbTsUrbResult}, Documentation {Description = "A TS_URB_RESULT structure as defined in ."};
        uint HRESULT with Documentation{Description = "A 32-bit unsigned integer that indicates the HRESULT of the operation."};
        uint OutputBufferSize with Documentation{Description = "A 32-bit unsigned integer. The size, in bytes, of data sent to the device of the RequestId that corresponds to a TRANSFER_OUT_REQUEST. This field MUST be zero if the RequestId corresponds to a TRANSFER_IN_REQUEST."};
        
        override string ToString()
        {
            string summary = "URBCompletionNoData, " + (RequestId as string);
            if(TsUrbResult.TsUrbResultHeader.Size > 8)
            {
                summary += ", TsUrbResult: " + TsUrbResult.GetTsUrbResultDataType();
            }
            summary += ", HRESULT: " + (HRESULT as string);
            return summary;
        }
    } with Documentation{Applicability = "2.2.7.3", Description = "The URB_COMPLETION_NO_DATA request is sent from the client to the server as the final result of a TRANSFER_IN_REQUEST that contains no output data or a TRANSFER_OUT_REQUEST."};
}

type IOControlCode 
{ 
    ushort DeviceType; 
    ushort Access with BinaryEncoding{Width = 2}; 
    ushort Function with BinaryEncoding{Width = 12, Endian=Endian.Big}; 
    ushort Method with BinaryEncoding{Width = 2}; 
} with BinaryEncoding{WidthForComposedType = 32, DecodeAsUnit = true};

// 2.2.1   Shared Message Header (SHARED_MSG_HEADER)
type SharedMessageHeader[bool IsResponse, FunctionIdType FuncIdType]
{
    InterfaceIdAndMask InterfaceIdAndMask;
    uint MessageId;
    optional [|IsResponse == false|] ( [|FuncIdType is FunctionIdType.FunctionIdType_CommonIds|] CommonIds
        | [|FuncIdType is FunctionIdType.FunctionIdType_CapabilitiesNegotiatorInterfaceIds|] CapabilitiesNegotiatorInterfaceIds
        | [|FuncIdType is FunctionIdType.FunctionIdType_ClientRequestCompletionInterfaceIds|] ClientRequestCompletionInterfaceIds
        | [|FuncIdType is FunctionIdType.FunctionIdType_ServerUSBDeviceInterfaceIds|] ServerUSBDeviceInterfaceIds
        | [|FuncIdType is FunctionIdType.FunctionIdType_ClientDeviceSinkInterfaceIds|] ClientDeviceSinkInterfaceIds
        | [|FuncIdType is FunctionIdType.FunctionIdType_ChannelNotificationInterfaceIds|] ChannelNotificationInterfaceIds) FunctionId with DisplayInfo{ToText = GetToTextMethodForFunctionId(FuncIdType)};
    uint GetInterfaceId()
    {
        return InterfaceIdAndMask.InterfaceId;
    }
}

//This is not a part of structure in TD, just for decoding logic
pattern FunctionIdType = enum byte
{
    FunctionIdType_CommonIds = 0x00,
    FunctionIdType_CapabilitiesNegotiatorInterfaceIds = 0x01,
    FunctionIdType_ClientRequestCompletionInterfaceIds = 0x02,
    FunctionIdType_ServerUSBDeviceInterfaceIds = 0x03,
    FunctionIdType_ClientDeviceSinkInterfaceIds = 0x04,
    FunctionIdType_ChannelNotificationInterfaceIds = 0x05
};

pattern CommonIds = enum uint
{
    RIMCALL_RELEASE = 0x00000001,
    RIMCALL_QUERYINTERFACE = 0x00000002,
    ...
};

pattern CapabilitiesNegotiatorInterfaceIds = enum uint
{
    RIM_EXCHANGE_CAPABILITY_REQUEST = 0x00000100,
    ...
};

pattern ClientRequestCompletionInterfaceIds = enum uint
{
    IOCONTROL_COMPLETION = 0x00000100,
    URB_COMPLETION = 0x00000101,
    URB_COMPLETION_NO_DATA = 0x00000102,
    ...
};

pattern ServerUSBDeviceInterfaceIds = enum uint
{
    CANCEL_REQUEST = 0x00000100,
    REGISTER_REQUEST_CALLBACK = 0x00000101,
    IO_CONTROL = 0x00000102,
    INTERNAL_IO_CONTROL = 0x00000103,
    QUERY_DEVICE_TEXT = 0x00000104,
    TRANSFER_IN_REQUEST = 0x00000105,
    TRANSFER_OUT_REQUEST = 0x00000106,
    RETRACT_DEVICE = 0x00000107,
    ...
};

pattern ClientDeviceSinkInterfaceIds = enum uint
{
    ADD_VIRTUAL_CHANNEL = 0x00000100,
    ADD_DEVICE = 0x00000101,
    ...
};

pattern ChannelNotificationInterfaceIds = enum uint
{
    CHANNEL_CREATED = 0x00000100,
    ...
};

// WORKAROUND for bug# 58507
string(any) GetToTextMethodForFunctionId(FunctionIdType FuncIdType)
{
    switch(FuncIdType)
    {
        case FunctionIdType.FunctionIdType_CommonIds =>
            return CommonIdsToText;
        case FunctionIdType.FunctionIdType_CapabilitiesNegotiatorInterfaceIds =>
            return CapabilitiesNegotiatorInterfaceIdsToText;
        case FunctionIdType.FunctionIdType_ClientRequestCompletionInterfaceIds =>
            return ClientRequestCompletionInterfaceIdsToText;
        case FunctionIdType.FunctionIdType_ServerUSBDeviceInterfaceIds =>
            return ServerUSBDeviceInterfaceIdsToText;
        case FunctionIdType.FunctionIdType_ClientDeviceSinkInterfaceIds =>
            return ClientDeviceSinkInterfaceIdsToText;
        case FunctionIdType.FunctionIdType_ChannelNotificationInterfaceIds =>
            return ChannelNotificationInterfaceIdsToText;
        default =>
            return null;
    }
}

static string CommonIdsToText(any input)
{
    var data = input as (optional CommonIds);
    if (data == nothing)
    {
        return "";
    }
    var v = data as CommonIds;
    if (InRange<CommonIds>(v))
    {
        return EnumToString(v, "RDPEUSB.CommonIds") + "(" + v.ToString() + ")";
    }
    else
    {
        return v.ToString();
    }
}

static string CapabilitiesNegotiatorInterfaceIdsToText(any input)
{
    var data = input as (optional CapabilitiesNegotiatorInterfaceIds);
    if (data == nothing)
    {
        return "";
    }
    var v = data as CapabilitiesNegotiatorInterfaceIds;
    if (InRange<CapabilitiesNegotiatorInterfaceIds>(v))
    {
        return EnumToString(v, "RDPEUSB.CapabilitiesNegotiatorInterfaceIds") + "(" + v.ToString() + ")";
    }
    else
    {
        return v.ToString();
    }
}

static string ClientRequestCompletionInterfaceIdsToText(any input)
{
    var data = input as (optional ClientRequestCompletionInterfaceIds);
    if (data == nothing)
    {
        return "";
    }
    var v = data as ClientRequestCompletionInterfaceIds;
    if (InRange<ClientRequestCompletionInterfaceIds>(v))
    {
        return EnumToString(v, "RDPEUSB.ClientRequestCompletionInterfaceIds") + "(" + v.ToString() + ")";
    }
    else
    {
        return v.ToString();
    }
}

static string ServerUSBDeviceInterfaceIdsToText(any input)
{
    var data = input as (optional ServerUSBDeviceInterfaceIds);
    if (data == nothing)
    {
        return "";
    }
    var v = data as ServerUSBDeviceInterfaceIds;
    if (InRange<ServerUSBDeviceInterfaceIds>(v))
    {
        return EnumToString(v, "RDPEUSB.ServerUSBDeviceInterfaceIds") + "(" + v.ToString() + ")";
    }
    else
    {
        return v.ToString();
    }
}

static string ClientDeviceSinkInterfaceIdsToText(any input)
{
    var data = input as (optional ClientDeviceSinkInterfaceIds);
    if (data == nothing)
    {
        return "";
    }
    var v = data as ClientDeviceSinkInterfaceIds;
    if (InRange<ClientDeviceSinkInterfaceIds>(v))
    {
        return EnumToString(v, "RDPEUSB.ClientDeviceSinkInterfaceIds") + "(" + v.ToString() + ")";
    }
    else
    {
        return v.ToString();
    }
}

static string ChannelNotificationInterfaceIdsToText(any input)
{
    var data = input as (optional ChannelNotificationInterfaceIds);
    if (data == nothing)
    {
        return "";
    }
    var v = data as ChannelNotificationInterfaceIds;
    if (InRange<ChannelNotificationInterfaceIds>(v))
    {
        return EnumToString(v, "RDPEUSB.ChannelNotificationInterfaceIds") + "(" + v.ToString() + ")";
    }
    else
    {
        return v.ToString();
    }
}
// WORKAROUND for bug# 58384
type InterfaceIdAndMask
{
    ShareMessageHeaderMask Mask with BinaryEncoding{Width = 2};
    uint InterfaceId with BinaryEncoding{Width = 30, Endian = Endian.Big};
} with BinaryEncoding{WidthForComposedType = 32, DecodeAsUnit = true};

pattern ShareMessageHeaderMask = enum byte
{
    STREAM_ID_STUB = 0x2,
    STREAM_ID_PROXY = 0x1,
    STREAM_ID_NONE = 0x0
};

// 2.2.8 USB_RETRACT_REASON
pattern UsbRetractReason = enum uint
{
    UsbRetractReason_BlockedByPolicy = 0x00000001,
    ...   
};

// 2.2.9.1.1   TS_URB_HEADER
type TsUrbHeader
{
    ushort Size;
    ushort UrbFunction;
    RequestIdAndNoAck RequestIdAndNoAck;
};

type RequestIdAndNoAck
{
    uint NoAck with BinaryEncoding{Width = 1};
    uint RequestId with BinaryEncoding{Width = 31, Endian = Endian.Big};
} with
    BinaryEncoding{WidthForComposedType = 32, DecodeAsUnit = true},
    Documentation{EmbeddedType = true};
 
// 2.2.9.1.2   TS_USBD_INTERFACE_INFORMATION
type TsUsbdInterfaceInformation
{
    ushort Length with Documentation{Description = "A 16-bit unsigned integer. The size in bytes of the TS_USBD_INTERFACE_INFORMATION structure."};
    ushort NumberOfPipesExpected with Documentation{Description = "A 16-bit unsigned integer. The number of USBD_PIPE_INFORMATION structures found in the USBD_INTERFACE_INFORMATION."};
    byte InterfaceNumber with Documentation{Description = "A 8-bit unsigned integer. This value is from the InterfaceNumber field in USBD_INTERFACE_INFORMATION."};
    byte AlternateSetting with Documentation{Description = "A 8-bit unsigned integer. This value is from the AlternateSetting field in USBD_INTERFACE_INFORMATION."};
    ushort Padding with Documentation{Description = "A 16-bit unsigned integer for padding. This field can be set to any value and MUST be ignored upon receipt."};
    uint NumberOfPipes with Documentation{Description = "A 32-bit unsigned integer. This value is from the NumberOfPipes field in USBD_INTERFACE_INFORMATION."};
    array<TsUsbdPipeInformation> TsUsbdPipeInformation with BinaryEncoding{Length = NumberOfPipes}, Documentation{Description = "An array of TS_USBD_PIPE_INFORMATION structures, as specified in section . The number of array elements is determined by the NumberOfPipes field."};

    override string ToString()
    {
        return "TsUsbdInterfaceInformation, NumberOfPipesExpected: " + NumberOfPipesExpected.ToString() + ", InterfaceNumber: " + InterfaceNumber.ToString() + 
            ", NumberOfPipes: " + NumberOfPipes.ToString();
    }
} with Documentation{Applicability = "2.2.9.1.2", Description = "The TS_USBD_INTERFACE_INFORMATION is based on the USBD_INTERFACE_INFORMATION structure as described in [MSFT-W2KDDK], Volume 2, Part 4, Chapter 3."};

// 2.2.9.1.3   TS_USBD_PIPE_INFORMATION
type TsUsbdPipeInformation
{
    ushort MaximumPacketSize with Documentation{Description = "A 16-bit unsigned integer. This value is from the MaximumPacketSize field in USBD_PIPE_INFORMATION."};
    ushort Padding with Documentation{Description = "A 16-bit unsigned integer for padding. This field can be set to any value and MUST be ignored upon receipt."};
    uint MaximumTransferSize with Documentation{Description = "A 32-bit unsigned integer. This value is from the MaximumTransferSize field in USBD_PIPE_INFORMATION."};
    uint PipeFlags with Documentation {Description = "A 32-bit unsigned integer. This value is from the PipeFlags field in USBD_PIPE_INFORMATION."};

    override string ToString()
    {
        return "TsUsbdPipeInformation, MaximumPacketSize: " + MaximumPacketSize.ToString() + ", MaximumTransferSize: " + MaximumTransferSize.ToString();
    }
} with Documentation{Applicability = "2.2.9.1.3", Description = "The TS_USBD_PIPE_INFORMATION is based on the USBD_PIPE_INFORMATION structure as described in [MSFT-W2KDDK], Volume 2, Part 4, Chapter 3.The field MaximumTransferSize of USBD_PIPE_INFORMATION is ignored."};

// 2.2.9.2   TS_URB_SELECT_CONFIGURATION
type TsUrbSelectConfiguration
{
    uint ConfigurationDescriptorIsValid with BinaryEncoding{Width = 8}, Documentation{Description = "A 8-bit unsigned integer. A non-zero value indicates that the TS_URB_SELECT_CONFIGURATION contains the USB_CONFIGURATION_DESCRIPTOR field."};
    uint Padding with BinaryEncoding{Width = 24}, Documentation{Description = "A 24-bit unsigned integer for padding. This field can be set to any value and MUST be ignored upon receipt."};
    uint NumInterfaces with Documentation{Description = "A 32-bit unsigned integer. The number of TS_USBD_INTERFACE_INFORMATION structures that are in the TS_URB_SELECT_CONFIGURATION."};
    array<TsUsbdInterfaceInformation> TsUsbdInterfaceInformation with BinaryEncoding{Length = NumInterfaces}, Documentation{Description = "An array of TS_USBD_INTERFACE_INFORMATION structure as specified in section . The number of elements is determined by the NumInterfaces field."};
    array<UsbDescriptor> UsbConfigurationDescriptor with Documentation{Description = "All data for the configuration with a USB_CONFIGURATION_DESCRIPTOR as specified in [MSFT-W2KDDK] Volume 2, Part 4, Chapter 3."};
} with Documentation{Applicability = "2.2.9.2", Description = "This packet represents the URB structure URB_SELECT_CONFIGURATION, as specified in [MSFT-W2KDDK] Volume 2, Part 4, Chapter 3. The packet is sent using TRANSFER_IN_REQUEST. OutputBufferSize MUST be set to zero."};

pattern UsbDescriptor = UsbDeviceDescriptor 
    | UsbConfigurationDescriptor
    | UsbStringDescriptor 
    | UsbInterfaceDescriptor 
    | UsbEndpointDescriptor 
    | UsbBOSDescriptor
    | UsbInterfaceAssociationDescriptor 
    | UsbDeviceCapabilityDescriptor
    | UsbSuperSpeedEndpointCompanionDescriptor
    | UsbClassSpecificInterfaceDescriptor
    | UsbClassSpecificEndpointDescriptor
    | UsbUnknownDescriptor;

// USB Descripters: http://www.gaw.ru/pdf/interface/usb/USB%203%200_english.pdf, Universal Serial Bus 3.0 Specification, Section 9.4
pattern USB_DESCRIPTER_TYPE = enum byte
{
    USB_DEVICE_DESCRIPTER_TYPE = 0x01,
    USB_CONFIGURATION_DESCRIPTOR_TYPE = 0x02,
    USB_STRING_DESCRIPTOR_TYPE = 0x03,
    USB_INTERFACE_DESCRIPTOR_TYPE = 0x04,
    USB_ENDPOINT_DESCRIPTOR_TYPE = 0x05,
    USB_INTERFACE_POWER_DESCRIPTOR_TYPE = 0x08,
    USB_OTG_DESCRIPTOR_TYPE = 0x09,
    USB_DEBUG_DESCRIPTOR_TYPE = 0x0a,
    USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE = 0x0b,
    USB_BOS_DESCRIPTOR_TYPE = 0x0f,
    USB_DEVICE_CAPABILITY_DESCRIPTOR_TYPE = 0x10,
    USB_SUPERSPEED_USB_ENDPOINT_COMPANION = 0x30,
    // http://www.usb.org/developers/devclass_docs/audio10.pdf Section B.3
    USB_CS_INTERFACE_DESCRIPTOR_TYPE = 0x24, 
    USB_CS_ENDPOINT_DESCRIPTOR_TYPE = 0x25,
    ...   
};

// Universal Serial Bus 3.0 Specification, Section 9.6.2
type UsbBOSDescriptor
{
    (byte where value == 5) bLength;
    USB_DESCRIPTER_TYPE bDescriptorType where value == USB_DESCRIPTER_TYPE.USB_BOS_DESCRIPTOR_TYPE;
    ushort wTotalLength;
    byte bNumDeviceCaps;

    override string ToString()
    {
        return "UsbBOSDescriptor, wTotalLength: " + wTotalLength.ToString() + ", bNumDeviceCaps: " + bNumDeviceCaps.ToString();
    }
}

// Universal Serial Bus 3.0 Specification, Section 9.6.2
type UsbDeviceCapabilityDescriptor
{
    (byte where value > 2) bLength;
    USB_DESCRIPTER_TYPE bDescriptorType where value == USB_DESCRIPTER_TYPE.USB_DEVICE_CAPABILITY_DESCRIPTOR_TYPE;
    byte bDevCapabilityType;
    binary CapabilityData with BinaryEncoding{Length = (bLength - 3)};

    override string ToString()
    {
        return "UsbDeviceCapabilityDescriptor, bDevCapabilityType: " + bDevCapabilityType.ToString();
    }
}

// Universal Serial Bus 3.0 Specification, Section 9.6.7
type UsbSuperSpeedEndpointCompanionDescriptor
{
    (byte where value == 6) bLength;
    USB_DESCRIPTER_TYPE bDescriptorType where value == USB_DESCRIPTER_TYPE.USB_SUPERSPEED_USB_ENDPOINT_COMPANION;
    byte bMsxBurst;
    byte bmAttributes;
    ushort wBytesPerInterval;

    override string ToString()
    {
        return "UsbSuperSpeedEndpointCompanionDescriptor, bMsxBurst: " + bMsxBurst.ToString() + 
            ", bmAttributes: " + bmAttributes.ToString() + ", wBytesPerInterval: " + wBytesPerInterval.ToString();
    }
}

// Universal Serial Bus 3.0 Specification, Section 9.6.8
type UsbStringDescriptor
{
    (byte where value > 1) bLength;
    USB_DESCRIPTER_TYPE bDescriptorType where value == USB_DESCRIPTER_TYPE.USB_STRING_DESCRIPTOR_TYPE;
    string bString with BinaryEncoding{Length = (bLength - 2)};

    override string ToString()
    {
        return "UsbStringDescriptor, bString: " + bString;
    }
}

// USB_DEVICE_DESCRIPTOR: http://msdn.microsoft.com/en-us/library/ff539280(v=vs.85).aspx
type UsbDeviceDescriptor
{
    (byte where value == 18) bLength;
    USB_DESCRIPTER_TYPE bDescriptorType where value == USB_DESCRIPTER_TYPE.USB_DEVICE_DESCRIPTER_TYPE;
    ushort BcdUSB;
    byte BDeviceClass;
    byte BDeviceSubClass;
    byte BDeviceProtocol;
    byte BMaxPacketSize0;
    ushort IdVendor;
    ushort IdProduct;
    ushort BcdDevice;
    byte IManufacturer;
    byte IProduct;
    byte ISerialNumber;
    byte BNumConfigurations;

    override string ToString()
    {
        return "UsbDeviceDescriptor, BcdUSB: " + BcdUSB.ToString() + 
            ", BDeviceClass: " + BDeviceClass.ToString() + ", BDeviceProtocol: " + BDeviceProtocol.ToString();
    }
}

// USB_CONFIGURATION_DESCRIPTOR: http://msdn.microsoft.com/en-us/library/ff539241(VS.85).aspx
type UsbConfigurationDescriptor
{
    (byte where value == 9) bLength;
    USB_DESCRIPTER_TYPE bDescriptorType where value == USB_DESCRIPTER_TYPE.USB_CONFIGURATION_DESCRIPTOR_TYPE;
    ushort WTotalLength;
    byte BNumInterfaces;
    byte BConfigurationValue;
    byte IConfiguration;
    Attributes BmAttributes;
    byte MaxPower;

    override string ToString()
    {
        return "UsbConfigurationDescriptor, WTotalLength: " + WTotalLength.ToString() + 
            ", BNumInterfaces: " + BNumInterfaces.ToString() + ", BConfigurationValue: " + BConfigurationValue.ToString();
    }
}

// USB_INTERFACE_DESCRIPTOR: http://msdn.microsoft.com/en-us/library/ff540065(VS.85).aspx
type UsbInterfaceDescriptor
{
    (byte where value == 9) bLength;
    USB_DESCRIPTER_TYPE bDescriptorType where value == USB_DESCRIPTER_TYPE.USB_INTERFACE_DESCRIPTOR_TYPE;
    byte bInterfaceNumber;
    byte bAlternateSetting;
    byte bNumEndpoints;
    byte bInterfaceClass;
    byte bInterfaceSubClass;
    byte bInterfaceProtocol;
    byte iInterface;

    override string ToString()
    {
        return "UsbInterfaceDescriptor, bInterfaceNumber: " + bInterfaceNumber.ToString() + 
            ", bAlternateSetting: " + bAlternateSetting.ToString() + ", bNumEndpoints: " + bNumEndpoints.ToString();
    }
}

// USB_ENDPOINT_DESCRIPTOR: http://msdn.microsoft.com/en-us/library/ff539317(VS.85).aspx
type UsbEndpointDescriptor
{
    (byte where value == 7) bLength;
    USB_DESCRIPTER_TYPE bDescriptorType where value == USB_DESCRIPTER_TYPE.USB_ENDPOINT_DESCRIPTOR_TYPE;
    byte bEndpointAddress;
    Attributes bAttributes;
    ushort wMaxPacketSize;
    byte bInterval;

    override string ToString()
    {
        return "UsbEndpointDescriptor, bEndpointAddress: " + bEndpointAddress.ToString() + 
            ", wMaxPacketSize: " + wMaxPacketSize.ToString();
    }
}

// USB_INTERFACE_ASSOCIATION_DESCRIPTOR: http://msdn.microsoft.com/en-us/library/gg159474.aspx
type UsbInterfaceAssociationDescriptor
{
    (byte where value == 8) bLength;
    USB_DESCRIPTER_TYPE bDescriptorType where value == USB_DESCRIPTER_TYPE.USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE;
    byte bFirstInterface;
    byte bInterfaceCount;
    byte bFunctionClass;
    byte bFunctionSubClass;
    byte bFunctionProtocol;
    byte iFunction;

    override string ToString()
    {
        return "UsbInterfaceAssociationDescriptor, bFirstInterface: " + bFirstInterface.ToString() + 
            ", bInterfaceCount: " + bInterfaceCount.ToString();
    }
}

// Class-specific Interface Descriptor: http://www.usb.org/developers/devclass_docs/audio10.pdf Section B.3
type UsbClassSpecificInterfaceDescriptor
{
    (byte where value > 2) bLength;
    USB_DESCRIPTER_TYPE bDescriptorType where value == USB_DESCRIPTER_TYPE.USB_CS_INTERFACE_DESCRIPTOR_TYPE;
    byte bDescriptorSubtype;
    binary descriptorData with BinaryEncoding{Length = (bLength - 3)};

    override string ToString()
    {
        return "UsbClassSpecificInterfaceDescriptor, bDescriptorSubtype: " + bDescriptorSubtype.ToString();
    }
}

// Class-specific Endpoint Descriptor: http://www.usb.org/developers/devclass_docs/audio10.pdf Section B.3
type UsbClassSpecificEndpointDescriptor
{
    (byte where value > 2) bLength;
    USB_DESCRIPTER_TYPE bDescriptorType where value == USB_DESCRIPTER_TYPE.USB_CS_ENDPOINT_DESCRIPTOR_TYPE;
    byte bDescriptorSubtype;
    binary descriptorData with BinaryEncoding{Length = (bLength - 3)};

    override string ToString()
    {
        return "UsbClassSpecificEndpointDescriptor, bDescriptorSubtype: " + bDescriptorSubtype.ToString();
    }
}

type UsbUnknownDescriptor
{
    (byte where value > 1) bLength;
    USB_DESCRIPTER_TYPE bDescriptorType where value > 0;
    Blob[(bLength - 2) as uint] DescriptorData;

    override string ToString()
    {
        return "UsbUnknownDescriptor";
    }
}

type Attributes
{
    byte Attribute4 with BinaryEncoding{Width = 1};
    byte Attribute3 with BinaryEncoding{Width = 1};
    byte Attribute2 with BinaryEncoding{Width = 1};
    byte Attribute1 with BinaryEncoding{Width = 5};
}

// 2.2.9.3   TS_URB_SELECT_INTERFACE
type TsUrbSelectInterface
{
    uint ConfigurationHandle with Documentation{Description = "A 32-bit unsigned integer. The handle returned from the client after it successfully completes a TS_URB_SELECT_CONFIGURATION request."};
    TsUsbdInterfaceInformation TsUsbdInterfaceInformation with Documentation{Description = "A TS_USBD_INTERFACE_INFORMATION structure as specified in section ."};
} with Documentation{Applicability = "2.2.9.3", Description = "This packet represents the URB structure URB_SELECT_INTERFACE, as specified in [MSFT-W2KDDK] Volume 2, Part 4, Chapter 3. The packet is sent using the TRANSFER_IN_REQUEST message with OutputBufferSize set to zero."};

// 2.2.9.4   TS_URB_PIPE_REQUEST
type TsUrbPipeRequest
{
    uint PipeHandle with Documentation{Description = "A 32-bit unsigned integer. This is either the ConfigurationHandle field used in TS_URB_SELECT_INTERFACE request or the ConfigurationHandle field returned by the client with TS_URB_SELECT_CONFIGURATION_RESULT."};
} with Documentation{Applicability = "2.2.9.4",Description = "This packet represents the URB structure URB_PIPE_REQUEST, as specified in [MSFT-W2KDDK] Volume 2, Part 4, Chapter 3. The packet is sent using the TRANSFER_IN_REQUEST message with OutputBufferSize set to zero."};

// 2.2.9.5   TS_URB_GET_CURRENT_FRAME_NUMBER
type TsUrbGetCurrentFrameNumber
{
} with Documentation{Applicability = "2.2.9.5", Description = "This packet represents the URB structure URB_GET_CURRENT_FRAME_NUMBER, as specified in [MSFT-W2KDDK] Volume 2, Part 4, Chapter 3. The packet is sent using the TRANSFER_IN_REQUEST. The OutputBufferSize field MUST be set to 0."};

// 2.2.9.6   TS_URB_CONTROL_TRANSFER
type TsUrbControlTransfer
{
    uint PipeHandle with Documentation{Description = "A 32-bit unsigned integer. The handle returned from the client after it successfully completes a TS_URB_SELECT_INTERFACE request."};
    uint TransferFlags with Documentation{Description = "A 32-bit unsigned integer. This value is from the TransferFlags field in URB_CONTROL_TRANSFER."};
    array<byte> SetupPacket with BinaryEncoding{Length = 8}, Documentation{Description = "An 8-byte array. This value is from the SetupPacket field in URB_CONTROL_TRANSFER."};
} with Documentation{Applicability = "2.2.9.6", Description = "This packet represents the URB structure URB_CONTROL_TRANSFER, as specified in [MSFT-W2KDDK] Volume 2, Part 4, Chapter 3. If the TransferFlags field in URB_CONTROL_TRANSFER contains the USBD_TRANSFER_DIRECTION_IN flag, the packet is sent using the TRANSFER_IN_REQUEST message with OutputBufferSize set to TransferBufferLength as defined in URB_CONTROL_TRANSFER; otherwise, the packet is sent using the TRANSFER_OUT_REQUEST message with InputBufferSize set to TransferBufferLength and InputBuffer set to data in TransferBuffer or TransferBufferMDL as defined in URB_CONTROL_TRANSFER."};

// 2.2.9.7   TS_URB_BULK_OR_INTERRUPT_TRANSFER
type TsUrbBulkOrInterruptTransfer
{
    uint PipeHandle with Documentation{Description = "A 32-bit unsigned integer. The handle returned from the client after it successfully completes a TS_URB_SELECT_INTERFACE request."};
    uint TransferFlags with Documentation{Description = "A 32-bit unsigned integer. This value is from the TransferFlags field in URB_BULK_OR_INTERRUPT_TRANSFER."};
} with Documentation{Applicability = "2.2.9.7", Description = "The packet represents the URB structure URB_BULK_OR_INTERRUPT_TRANSFER, as specified in [MSFT-W2KDDK] Volume 2, Part 4, Chapter 3. If the TransferFlags field in URB_BULK_OR_INTERRUPT_TRANSFER contains the USBD_TRANSFER_DIRECTION_IN flag, the packet is sent using the TRANSFER_IN_REQUEST message with the OutputBufferSize field set to TransferBufferLength as defined in URB_BULK_OR_INTERRUPT_TRANSFER; otherwise, the packet is sent using the TRANSFER_OUT_REQUEST message with the InputBufferSize field set to TransferBufferLength and the InputBuffer field set to the data in TransferBuffer or TransferBufferMDL as defined in URB_BULK_OR_INTERRUPT_TRANSFER."};

// 2.2.9.8   TS_URB_ISOCH_TRANSFER
type TsUrbIsochTransfer
{
    uint PipeHandle with Documentation{Description = "A 32-bit unsigned integer. The handle returned from the client after it successfully completes a TS_URB_SELECT_INTERFACE request."};
    uint TransferFlags with Documentation{Description = "A 32-bit unsigned integer. This value is from the TransferFlags field in URB_ISOCH_TRANSFER."};
    uint StartFrame with Documentation{Description = "A 32-bit unsigned integer. This value is from the StartFrame field in URB_ISOCH_TRANSFER."};
    uint NumberOfPackets with Documentation{Description = "A 32-bit unsigned integer. This value is from the NumberOfPackets field in URB_ISOCH_TRANSFER."};
    uint ErrorCount with Documentation{Description = "A 32-bit unsigned integer. This value is from the ErrorCount field in URB_ISOCH_TRANSFER."};
    array<UsbdIsoPacketDescriptor> IsoPacket with BinaryEncoding{Length = NumberOfPackets}, Documentation{Description = "An array of USBD_ISO_PACKET_DESCRIPTOR structures. This value is from the IsoPacket field in URB_ISOCH_TRANSFER."};
} with Documentation{Applicability = "2.2.9.8", Description = "This packet represents the URB structure URB_ISOCH_TRANSFER, as specified in [MSFT-W2KDDK] Volume 2, Part 4, Chapter 3. If the TransferFlags field in URB_ISOCH_TRANSFER contains the USBD_TRANSFER_DIRECTION_IN flag, the packet is sent using the TRANSFER_IN_REQUEST message with the OutputBufferSize field set to TransferBufferLength as defined in URB_ISOCH_TRANSFER; otherwise, the packet is sent using the TRANSFER_OUT_REQUEST message with the InputBufferSize field set to TransferBufferLength and the InputBuffer field set to the data in TransferBuffer or TransferBufferMDL as defined in URB_ISOCH_TRANSFER."};

// 2.2.9.9   TS_URB_CONTROL_DESCRIPTOR_REQUEST
type TsUrbControlDescriptorRequest
{
    byte Index with Documentation{Description = "A 8-bit unsigned integer. This value is from the Index field in URB_CONTROL_DESCRIPTOR_REQUEST."};
    byte DescriptorType with Documentation{Description = "A 8-bit unsigned integer. This value is from the DescriptorType field in URB_CONTROL_DESCRIPTOR_REQUEST."};
    ushort LanguageId with Documentation{Description = "A 16-bit unsigned integer. This value is from the LanguageId field in URB_CONTROL_DESCRIPTOR_REQUEST."};
} with Documentation{Applicability = "2.2.9.9", Description = "This packet represents the URB structure URB_CONTROL_DESCRIPTOR_REQUEST, as specified in [MSFT-W2KDDK] Volume 2, Part 4, Chapter 3. If the URB Function in URB_CONTROL_DESCRIPTOR_REQUEST is URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE, URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT, or URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE, the packet is sent using the TRANSFER_IN_REQUEST message with the OutputBufferSize field set to TransferBufferLength as defined in URB_CONTROL_DESCRIPTOR_REQUEST; otherwise, the packet is sent using the TRANSFER_OUT_REQUEST message with the InputBufferSize field set to TransferBufferLength and the InputBuffer field set to the data in TransferBuffer or TransferBufferMDL as defined in URB_CONTROL_DESCRIPTOR_REQUEST."};

// 2.2.9.10   TS_URB_CONTROL_FEATURE_REQUEST
type TsUrbControlFeatureRequest
{
    ushort FeatureSelector with Documentation{Description = "A 16-bit unsigned integer. This value is from the FeatureSelector field in URB_CONTROL_FEATURE_REQUEST."};
    ushort Index with Documentation{Description = "A 16-bit unsigned integer. This value is from the Index field in URB_CONTROL_FEATURE_REQUEST."};
} with Documentation{Applicability = "2.2.9.10", Description = "This packet represents the URB structure URB_CONTROL_FEATURE_REQUEST, as specified in [MSFT-W2KDDK] Volume 2, Part 4, Chapter 3. The packet is sent using the TRANSFER_IN_REQUEST message with the OutputBufferSize field set to zero."};

// 2.2.9.11   TS_URB_CONTROL_GET_STATUS_REQUEST
type TsUrbControlGetStatusRequest
{
    ushort Index with Documentation{Description = "A 16-bit unsigned integer. This value is from the Index field in URB_CONTROL_GET_STATUS_REQUEST."};
    ushort Padding with Documentation{Description = "A 16-bit unsigned integer for padding. This field can be set to any value and MUST be ignored upon receipt."};
} with Documentation{Applicability = "2.2.9.11", Description = "This packet represents the URB structure URB_CONTROL_GET_STATUS_REQUEST, as specified in [MSFT-W2KDDK] Volume 2, Part 4, Chapter 3. The packet is sent using the TRANSFER_IN_REQUEST message with the OutputBufferSize field set to TransferBufferLength as defined in URB_CONTROL_GET_STATUS_REQUEST."};

// 2.2.9.12   TS_URB_CONTROL_VENDOR_OR_CLASS_REQUEST
type TsUrbControlVendorOrClassRequest
{
    uint TransferFlags with Documentation{Description = "A 32-bit unsigned integer. This value is from the TransferFlags field in URB_CONTROL_VENDOR_OR_CLASS_REQUEST."};
    byte RequestTypeReservedBits with Documentation{Description = "An 8-bit unsigned integer. This value is from the RequestTypeReservedBits field in URB_CONTROL_VENDOR_OR_CLASS_REQUEST."};
    byte Request with Documentation{Description = "An 8-bit unsigned integer. If the operating system (OS) descriptor request has been successfully retrieved the Request field is set to the value, see section  Processing an OS descriptor request on how to retrieve an OS descriptor. Otherwise this value contains the value from the Request field in URB_CONTROL_VENDOR_OR_CLASS_REQUEST."};
    ushort Value with Documentation{Description = "A 16-bit unsigned integer. This value is from the Value field in URB_CONTROL_VENDOR_OR_CLASS_REQUEST."};
    ushort Index with Documentation{Description = "A 16-bit unsigned integer. This value is from the Index field in URB_CONTROL_VENDOR_OR_CLASS_REQUEST."};
    ushort Padding with Documentation{Description = "A 16-bit unsigned integer for padding. This field can be set to any value and MUST be ignored upon receipt."};
} with Documentation{Applicability = "2.2.9.12", Description = "This packet represents the URB structure URB_CONTROL_VENDOR_OR_CLASS_REQUEST, as specified in [MSFT-W2KDDK] Volume 2, Part 4, Chapter 3. If the TransferFlags field in URB_CONTROL_VENDOR_OR_CLASS_REQUEST contains the USBD_TRANSFER_DIRECTION_IN flag, the packet is sent using the TRANSFER_IN_REQUEST message with the OutputBufferSize field set to TransferBufferLength as defined in URB_CONTROL_VENDOR_OR_CLASS_REQUEST; otherwise, the packet is sent using the TRANSFER_OUT_REQUEST message with the InputBufferSize field set to TransferBufferLength and the InputBuffer field set to the data in TransferBuffer or TransferBufferMDL as defined in URB_CONTROL_VENDOR_OR_CLASS_REQUEST."};

// 2.2.9.13   TS_URB_CONTROL_GET_CONFIGURATION_REQUEST
type TsUrbControlGetConfigurationRequest
{
} with Documentation{Applicability = "2.2.9.13",Description = "This packet represents the URB structure URB_CONTROL_GET_CONFIGURATION_REQUEST, as specified in [MSFT-W2KDDK] Volume 2, Part 4, Chapter 3. The packet is sent using the TRANSFER_IN_REQUEST message with the OutputBufferSize field set to TransferBufferLength as defined in URB_CONTROL_GET_CONFIGURATION_REQUEST."};

// 2.2.9.14   TS_URB_CONTROL_GET_INTERFACE_REQUEST
type TsUrbControlGetInterfaceRequest
{
    ushort Interface with Documentation{Description = "A 16-bit unsigned integer. This value is from the Interface field in URB_CONTROL_GET_INTERFACE_REQUEST."};
    ushort Padding with Documentation{Description = "A 16-bit unsigned integer for padding. This field can be set to any value and MUST be ignored upon receipt."};
} with Documentation{Applicability = "2.2.9.14", Description = "This packet represents the URB structure URB_CONTROL_GET_INTERFACE_REQUEST, as specified in [MSFT-W2KDDK] Volume 2, Part 4, Chapter 3. The packet is sent using the TRANSFER_IN_REQUEST message with the OutputBufferSize field set to TransferBufferLength as defined in URB_CONTROL_GET_INTERFACE_REQUEST."};

// 2.2.9.15   TS_URB_OS_FEATURE_DESCRIPTOR_REQUEST
type TsUrbOSFeatureDescriptorRequest
{
    byte Recipient with BinaryEncoding{Width = 5}, Documentation{Description = "A 5-bit field. This value is from the Recipient field in URB_OS_FEATURE_DESCRIPTOR_REQUEST. When converting this value from the 8-bit field in URB_OS_FEATURE_DESCRIPTOR_REQUEST into the 5-bit field in TS_URB_OS_FEATURE_DESCRIPTOR_REQUEST, the highest 3 bits MUST be ignored. In an inverse conversion, the highest 3 bits MUST be set to 0."};
    byte Padding1 with BinaryEncoding{Width = 3}, Documentation{Description = "A 3-bit field for padding. This field can be set to any value and MUST be ignored upon receipt."};
    byte InterfaceNumber with Documentation{Description = "An 8-bit unsigned integer. This value is from the InterfaceNumber field in URB_OS_FEATURE_DESCRIPTOR_REQUEST."};
    byte MS_PageIndex with Documentation{Description = "An 8-bit unsigned integer. This value is from the MS_PageIndex field in URB_OS_FEATURE_DESCRIPTOR_REQUEST."};
    ushort MS_FeatureDescriptorIndex with Documentation{Description = "A 16-bit unsigned integer. This value is from the MS_FeatureDescriptorIndex field in URB_OS_FEATURE_DESCRIPTOR_REQUEST."};
    array<byte> Padding2 with BinaryEncoding{Length = 3}, Documentation{Description = "A 24-bit unsigned integer for padding. This field can be set to any value and MUST be ignored upon receipt."};
} with Documentation{Applicability = "2.2.9.15", Description = "This packet represents the URB structure URB_OS_FEATURE_DESCRIPTOR_REQUEST, as specified in [MSFT-W2KDDK] Volume 2, Part 4, Chapter 3. The packet is sent using the TRANSFER_IN_REQUEST message with the OutputBufferSize field set to TransferBufferLength as defined in URB_OS_FEATURE_DESCRIPTOR_REQUEST."};

// 2.2.9.16   TS_URB_CONTROL_TRANSFER_EX
type TsUrbControlTransferEx
{
    uint PipeHandle with Documentation{Description = "A 32-bit unsigned integer. The handle returned from the client after it successfully completes a TS_URB_SELECT_INTERFACE request."};
    uint TransferFlags with Documentation{Description = "A 32-bit unsigned integer. This value is from the TransferFlags field in URB_CONTROL_TRANSFER_EX."};
    uint Timeout with Documentation{Description = "A 32-bit unsigned integer. This value is from the Timeout field in URB_CONTROL_TRANSFER_EX. This value indicates the time, in milliseconds, before the request times out. A value of zero indicates that there is no timeout for this request. The value of this field is passed to the physical device."};
    array<byte> SetupPacket with BinaryEncoding{Length = 8}, Documentation{Description = "An array of 8-bytes. This value is from the SetupPacket field in URB_CONTROL_TRANSFER_EX."};
} with Documentation{Applicability = "2.2.9.16", Description = "This packet represents the URB structure URB_CONTROL_TRANSFER_EX, as specified in [MSFT-W2KDDK] Volume 2, Part 4, Chapter 3. URB_CONTROL_TRANSFER_EX is same as URB_CONTROL_TRANSFER except URB_CONTROL_TRANSFER_EX contains a new field called timeout following the TransferBufferMDL field. The timeout field in URB_CONTROL_TRANSFER_EX is 32-bit unsigned integer. If the TransferFlags field in URB_CONTROL_TRANSFER_EX contains the USBD_TRANSFER_DIRECTION_IN flag, the packet is sent using the TRANSFER_IN_REQUEST message with the OutputBufferSize field set to TransferBufferLength as defined in URB_CONTROL_TRANSFER_EX; otherwise, the packet is sent using the TRANSFER_OUT_REQUEST message with the InputBufferSize field set to TransferBufferLength and the InputBuffer field set to the data in TransferBuffer or TransferBufferMDL as defined in URB_CONTROL_TRANSFER_EX."};

// http://msdn.microsoft.com/en-us/library/ff540409(VS.85).aspx
// http://www.devdaily.com/scw/c/cygwin/src/winsup/w32api/include/ddk/usb.h.shtml
type TsUrb
{
    TsUrbHeader TsUrbHeader with Documentation{Description = "A TS_URB_HEADER as specified in section ."};
    ( [|TsUrbHeader.UrbFunction == 0x0000|] TsUrbSelectConfiguration 
    | [|TsUrbHeader.UrbFunction == 0x0001|] TsUrbSelectInterface
    | [|TsUrbHeader.UrbFunction == 0x0002 || TsUrbHeader.UrbFunction == 0x001E || TsUrbHeader.UrbFunction == 0x0030 || TsUrbHeader.UrbFunction == 0x0031|] TsUrbPipeRequest 
    | [|TsUrbHeader.UrbFunction == 0x0007|] TsUrbGetCurrentFrameNumber 
    | [|TsUrbHeader.UrbFunction == 0x0008|] TsUrbControlTransfer 
    | [|TsUrbHeader.UrbFunction == 0x0009|] TsUrbBulkOrInterruptTransfer 
    | [|TsUrbHeader.UrbFunction == 0x000A|] TsUrbIsochTransfer 
    | [|TsUrbHeader.UrbFunction == 0x000B || TsUrbHeader.UrbFunction == 0x000C || TsUrbHeader.UrbFunction == 0x0024 || TsUrbHeader.UrbFunction == 0x0025 || TsUrbHeader.UrbFunction == 0x0028 || TsUrbHeader.UrbFunction == 0x0029|] TsUrbControlDescriptorRequest 
    | [|TsUrbHeader.UrbFunction == 0x000D || TsUrbHeader.UrbFunction == 0x000E || TsUrbHeader.UrbFunction == 0x000F || TsUrbHeader.UrbFunction == 0x0023 || TsUrbHeader.UrbFunction == 0x0010 || TsUrbHeader.UrbFunction == 0x0011 || TsUrbHeader.UrbFunction == 0x0012 || TsUrbHeader.UrbFunction == 0x0022|] TsUrbControlFeatureRequest 
    | [|TsUrbHeader.UrbFunction == 0x0013 || TsUrbHeader.UrbFunction == 0x0014 || TsUrbHeader.UrbFunction == 0x0015 || TsUrbHeader.UrbFunction == 0x0021|] TsUrbControlGetStatusRequest 
    | [|TsUrbHeader.UrbFunction == 0x0017 || TsUrbHeader.UrbFunction == 0x0018 || TsUrbHeader.UrbFunction == 0x0019 || TsUrbHeader.UrbFunction == 0x0020 || TsUrbHeader.UrbFunction == 0x001A || TsUrbHeader.UrbFunction == 0x001B || TsUrbHeader.UrbFunction == 0x001C || TsUrbHeader.UrbFunction == 0x001F|] TsUrbControlVendorOrClassRequest 
    | [|TsUrbHeader.UrbFunction == 0x0026|] TsUrbControlGetConfigurationRequest 
    | [|TsUrbHeader.UrbFunction == 0x0027|] TsUrbControlGetInterfaceRequest 
    | [|TsUrbHeader.UrbFunction == 0x002A|] TsUrbOSFeatureDescriptorRequest
    | [|TsUrbHeader.UrbFunction == 0x0032|] TsUrbControlTransferEx
    | Blob[(TsUrbHeader.Size - 8) as uint]) UrbData with BinaryEncoding{WidthForComposedType = (TsUrbHeader.Size - 8) * 8};
}

type TsUrbResult[ushort TsUrbFunction]
{
    TsUrbResultHeader TsUrbResultHeader;
    ( [|TsUrbResultHeader.Size > 8 && TsUrbFunction == 0x0000|] TsUrbSelectConfigurationResult 
    | [|TsUrbResultHeader.Size > 8 && TsUrbFunction == 0x0001|] TsUrbSelectInterfaceResult 
    | [|TsUrbResultHeader.Size > 8 && TsUrbFunction == 0x0007|] TsUrbGetCurrentFrameNumberResult 
    | [|TsUrbResultHeader.Size > 8 && TsUrbFunction == 0x000A|] TsUrbIsochTransferResult 
    | Blob[(TsUrbResultHeader.Size - 8) as uint] ) UrbResultData;
    string GetTsUrbResultDataType()
    {
       if (TsUrbResultHeader.Size > 8)
       {
           if (TsUrbFunction == 0x0000)
           {
               return "TsUrbSelectConfigurationResult";
           }
           else if (TsUrbFunction == 0x0001)
           {
               return "TsUrbSelectInterfaceResult";
           }
           else if (TsUrbFunction == 0x0007)
           {
               return "TsUrbGetCurrentFrameNumberResult";
           }
           else if (TsUrbFunction == 0x000A)
           {
               return "TsUrbIsochTransferResult";
           }
           else
           {
               return "Unknown(" + DecToHexFormat(TsUrbFunction) + ")";
           }
       }
       else
       {
           return "";
       }
    }
}

// 2.2.10.1.1   TS_URB_RESULT_HEADER
type TsUrbResultHeader
{
    ushort Size with Documentation{Description = "A 16-bit unsigned integer. The size, in bytes, of the TS_URB_RESULT structure."};
    ushort Padding with Documentation{Description = "A 16-bit unsigned integer for padding. This field can be set to any value and MUST be ignored upon receipt."};
    uint UsbdStatus with Documentation{Description = "A 32-bit unsigned integer. This value represents the Status field of the URB_STATUS structure as specified in [MSFT-W2KDDK], Volume 2, Part 4, Chapter 3."};
} with Documentation{Applicability = "2.2.10.1.1", Description = "Every TS_URB_RESULT structure begins with a common header called TS_URB_RESULT_HEADER."};

// 2.2.10.1.2   TS_USBD_INTERFACE_INFORMATION_RESULT
type TsUsbdInterfaceInformationResult
{
    ushort Length with Documentation{Description = "A 16-bit unsigned integer. The size, in bytes, of the TS_USBD_INTERFACE_INFORMATION_RESULT structure."};
    byte InterfaceNumber with Documentation{Description = "A 8-bit unsigned integer. This value represents the InterfaceNumber field in USBD_INTERFACE_INFORMATION."};
    byte AlternateSetting with Documentation{Description = "A 8-bit unsigned integer. This value represents the AlternateSetting field in USBD_INTERFACE_INFORMATION."};
    byte Class with Documentation{Description = "A 8-bit unsigned integer. This value represents the Class field in USBD_INTERFACE_INFORMATION."};
    byte SubClass with Documentation{Description = "A 8-bit unsigned integer. This value represents the SubClass field in USBD_INTERFACE_INFORMATION."};
    byte Protocol with Documentation{Description = "A 8-bit unsigned integer. This value represents the Protocol field in USBD_INTERFACE_INFORMATION."};
    byte Padding with Documentation{Description = "A 8-bit unsigned integer for padding. This field can be set to any value and MUST be ignored upon receipt."};
    uint InterfaceHandle with Documentation{Description = "A 32-bit unsigned integer. This value represents the InterfaceHandle field in USBD_INTERFACE_INFORMATION."};
    uint NumberOfPipes with Documentation{Description = "A 32-bit unsigned integer. This value represents the NumberOfPipes field in USBD_INTERFACE_INFORMATION. It also indicates the number of Pipes array elements that are to follow."};
    array<TsUsbdPipeInformationResult> Pipes with BinaryEncoding{Length = NumberOfPipes}, Documentation{Description = "An array of TS_USBD_PIPE_INFORMATION_RESULT structures. The number of array elements is determined by the NumberOfPipes field."};

    override string ToString()
    {
        return "TsUsbdInterfaceInformationResult, InterfaceNumber: " + InterfaceNumber.ToString() + ", AlternateSetting: " + AlternateSetting.ToString();
    }
} with Documentation{Applicability = "2.2.10.1.2", Description = "The TS_USBD_INTERFACE_INFORMATION_RESULT structure is based on the USBD_INTERFACE_INFORMATION structure as described in [MSFT-W2KDDK], Volume 2, Part 4, Chapter 3."};


// 2.2.10.1.3   TS_USBD_PIPE_INFORMATION_RESULT
type TsUsbdPipeInformationResult
{
    ushort MaximumPacketSize with Documentation{Description = "A 16-bit unsigned integer. This value represents the MaximumPacketSize field in USBD_PIPE_INFORMATION."};
    byte EndpointAddress with Documentation{Description = "A 8-bit unsigned integer. This value represents the EndpointAddress field in USBD_PIPE_INFORMATION."};
    byte Interval with Documentation{Description = "A 8-bit unsigned integer. This value represents the Interval field in USBD_PIPE_INFORMATION."};
    uint PipeType with Documentation{Description = "A 32-bit unsigned integer. This value represents the PipeType field in USBD_PIPE_INFORMATION."};
    uint PipeHandle with Documentation{Description = "A 32-bit unsigned integer. This value represents the PipeHandle field in USBD_PIPE_INFORMATION."};
    uint MaximumTransferSize with Documentation{Description = "A 32-bit unsigned integer. This value represents the MaximumTransferSize field in USBD_PIPE_INFORMATION."};
    uint PipeFlags with Documentation{Description = "A 32-bit unsigned integer. This value represents the PipeFlags field in USBD_PIPE_INFORMATION."};

    override string ToString()
    {
        return "TsUsbdPipeInformationResult, MaximumPacketSize: " + MaximumPacketSize.ToString() + ", EndpointAddress: " + EndpointAddress.ToString();
    }
} with Documentation{Applicability = "2.2.10.1.3", Description = "The TS_USBD_PIPE_INFORMATION_RESULT is based on the USBD_PIPE_INFORMATION structure as described in [MSFT-W2KDDK], Volume 2, Part 4, Chapter 3."};

// 2.2.10.2   TS_URB_SELECT_CONFIGURATION_RESULT
type TsUrbSelectConfigurationResult
{
    uint ConfigurationHandle with Documentation {Description = "A 32-bit unsigned integer. An opaque handle that identifies the configuration described by the TS_URB_SELECT_CONFIGURATION operation."};
    uint NumInterfaces with Documentation{Description = "A 32-bit unsigned integer. The number of Interface fields that are to follow."};
    array<TsUsbdInterfaceInformationResult> Interface 
        with
            BinaryEncoding{Length = NumInterfaces},
            Documentation{Description = "An array of TS_USBD_INTERFACE_INFORMATION_RESULT structures as specified in section . The number of elements is determined by the NumInterfaces field."};
} with Documentation{Applicability = "2.2.10.2", Description = "This packet represents the result of the TRANSFER_IN_REQUEST with TS_URB_SELECT_CONFIGURATION. The TS_URB_SELECT_CONFIGURATION_RESULT is sent via the URB_COMPLETION_NO_DATA message."};


// 2.2.10.3   TS_URB_SELECT_INTERFACE_RESULT
type TsUrbSelectInterfaceResult
{
    TsUsbdInterfaceInformationResult Interface with Documentation{Description = "A TS_USBD_INTERFACE_INFORMATION_RESULT structure as specified in section ."};
} with Documentation{Applicability = "2.2.10.3", Description = "This packet represents the result of the TRANSFER_IN_REQUEST with TS_URB_SELECT_INTERFACE. The TS_URB_SELECT_CONFIGURATION_RESULT structure is sent via the URB_COMPLETION_NO_DATA message."};

// 2.2.10.4   TS_URB_GET_CURRENT_FRAME_NUMBER_RESULT
type TsUrbGetCurrentFrameNumberResult
{
    uint FrameNumber with Documentation{Description = "A 32-bit unsigned integer. The current frame number whose value is the same as the one returned by IOCTL_TSUSBGD_IOCTL_USBDI_QUERY_BUS_TIME. Each frame represents a 1 millisecond (ms) interval."};
} with Documentation{Applicability = "2.2.10.4", Description = "This packet represents the result of the TRANSFER_IN_REQUEST with TS_URB_GET_CURRENT_FRAME_NUMBER. The TS_URB_GET_CURRENT_FRAME_NUMBER_RESULT structure is sent via the URB_COMPLETION_NO_DATA message."};

// 2.2.10.5   TS_URB_ISOCH_TRANSFER_RESULT
type TsUrbIsochTransferResult
{
    uint StartFrame with Documentation{Description = "A 32-bit unsigned integer. The resulting StartFrame value as specified in URB_ISOCH_TRANSFER."};
    uint NumberOfPackets with Documentation{Description = "A 32-bit unsigned integer. This value is the number of URB_ISOCH_TRANSFER following the IsoPacket field."};
    uint ErrorCount with Documentation{Description = "A 32-bit unsigned integer. The resulting ErrorCount value as described in URB_ISOCH_TRANSFER."};
    array<UsbdIsoPacketDescriptor> IsoPacket with BinaryEncoding{Length = NumberOfPackets}, Documentation{Description = "The resulting array of USBD_ISO_PACKET_DESCRIPTOR structures as described in URB_ISOCH_TRANSFER."};
} with Documentation{Applicability = "2.2.10.5", Description = "This packet represents the result of TRANSFER_IN_REQUEST or TRANSFER_OUT_REQUEST with TS_URB_ISOCH_TRANSFER. The TS_URB_ISOCH_TRANSFER_RESULT structure is sent via the URB_COMPLETION message if the result contains the data buffer to be sent back; otherwise, the TS_URB_ISOCH_TRANSFER_RESULT is sent via the URB_COMPLETION_NO_DATA message."};

// 2.2.11   USB_DEVICE_CAPABILITIES
type UsbDeviceCapabilities
{
    uint CbSize where value == 28 with Documentation{Description = "A 32-bit unsigned integer. The byte size of this structure. This value MUST be 28."};
    UsbDeviceCapabilitiesUsbBusInterfaceVersion UsbBusInterfaceVersion with Documentation{Description = "A 32-bit unsigned integer. The USB version the device supports."};
    uint USBDI_Version with Documentation{Description = "A 32-bit unsigned integer. The highest USBDI version the device supports. This value can be 0x00000500 or 0x00000600."};
    UsbDeviceCapabilitiesSupportedUSBVersion Supported_USB_Version with Documentation {Description = "A 32-bit unsigned integer. The version of USB the device supports. The value MUST be one of the following:"};
    uint HcdCapabilities with Documentation{Description = "A 32-bit unsigned integer. The host capabilities supported. This value MUST always be zero."};
    uint DeviceIsHighSpeed with Documentation{Description = "A 32-bit unsigned integer. This value represents the device speed. 0x00000000 if the device is full speed and 0x00000001 if the device is high speed. If UsbBusInterfaceVersion is 0x00000000, DeviceIsHighSpeed MUST be 0x00000000. A high speed device operates as a USB 2.0 device while a full speed device operates as a USB 1.1 device."};
    uint NoAckIsochWriteJitterBufferSizeInMs with Documentation{Description = "A 32-bit unsigned integer. If the value is nonzero, the client supports TS_URB_ISOCH_TRANSFER messages that do not expect URB_COMPLETION messages; otherwise, if the value is zero, the client does not support TS_URB_ISOCH_TRANSFER messages. If the value is not zero, the value represents the amount of outstanding isochronous data the client expects from the server. If this value is nonzero, it MUST be greater than or equal to 10 and less than or equal to 512."};
} with Documentation{Applicability = "2.2.11", Description = "The USB_DEVICE_CAPABILITIES structure defines the capabilities of a USB device."};

// 2.2.13 USB Internal IO Control Code
pattern UsbInternalIoControlCode = enum uint
{
    IOCTL_TSUSBGD_IOCTL_USBDI_QUERY_BUS_TIME = 0x00224000,
    ...
};

// 2.2.3.1  
// CapabilityValue (4 bytes):  A 32-bit unsigned integer that identifies the server's capability. The valid values for this field are as follows.
pattern CapabilityValue = enum uint
{
    RIM_CAPABILITY_VERSION_01 = 0x00000001,
    ...
} with Documentation {EmbeddedType = true};

// Server USB Device Interface IDs
pattern ServerUsbDeviceInterfaceID = enum uint
{
    CANCEL_REQUEST = 0x00000100,
    REGISTER_REQUEST_CALLBACK = 0x00000101,
    IO_CONTROL = 0x00000102,
    INTERNAL_IO_CONTROL = 0x00000103,
    QUERY_DEVICE_TEXT = 0x00000104,
    TRANSFER_IN_REQUEST = 0x00000105,
    TRANSFER_OUT_REQUEST = 0x00000106,
    RETRACT_DEVICE = 0x00000107,
    ...
} with Documentation {EmbeddedType = true};

// The 2 bits of the Mask field MUST be set to one of the following values.
pattern Mask = enum byte
{
    STREAM_ID_STUB = 0x2,
    STREAM_ID_PROXY = 0x1,
    STREAM_ID_NONE = 0x0,
    ...
} with Documentation {EmbeddedType = true};

pattern UsbDeviceCapabilitiesUsbBusInterfaceVersion = enum uint
{
    USBVersion0 = 0x00000000,
    USBVersion1 = 0x00000001,
    USBVersion2 = 0x00000002
} with Documentation {EmbeddedType = true};

pattern UsbDeviceCapabilitiesSupportedUSBVersion = enum uint
{
    USB_1_0 = 0x100,
    USB_1_1 = 0x110,
    USB_2_0 = 0x200
} with Documentation {EmbeddedType = true};

//
// USBD_ISO_PACKET_DESCRIPTOR: http://msdn.microsoft.com/en-us/library/ff539084(v=VS.85).aspx
//
type UsbdIsoPacketDescriptor
{
    uint Offset with Documentation{Description = "Specifies the offset, in bytes, of the buffer for this packet from the beginning of the entire isochronous transfer buffer."};
    uint Length with Documentation{Description = "Set by the host controller to indicate the actual number of bytes received from the device for isochronous IN transfers. Length not used for isochronous OUT transfers."};
    UsbdStatus Status with Documentation{Description = "Contains the status, on return from the host controller driver, of this transfer packet."};

    override string ToString()
    {
        return "UsbdIsoPacketDescriptor, Offset: " + Offset.ToString() + ", Length: " + Length.ToString() + ", Status: " + Status.ToString();
    }
}with Documentation{Description = "The USBD_ISO_PACKET_DESCRIPTOR structure is used by USB client drivers to describe an isochronous transfer packet."};

type UsbdStatus
{
    int Status;

    override string ToString()
    {
        return "UsbdStatus, Status: " + Status.ToString();
    }
}

// ---------------------------------- Utilities -------------------------------------

string CapabilityValueToString(any input)
{
    uint capability = input as uint;
    return EnumToString(capability, "RDPEUSB.CapabilityValue");
}

string ServerUsbDeviceInterfaceIDToString(any input)
{
    uint id = input as uint;
    return EnumToString(id, "RDPEUSB.ServerUsbDeviceInterfaceID");
}

string MaskToString(any input)
{
    byte mask = input as byte;
    return EnumToString(mask, "RDPEUSB.Mask");
}

string UrbDataTypeCode(ushort urbFunction)
{
    switch(urbFunction)
    {
        case 0x0000 => return "TsUrbSelectConfiguration";
        case 0x0001 => return "TsUrbSelectInterface";
        case 0x0002 => return "TsUrbPipeRequest";
        case 0x0007 => return "TsUrbGetCurrentFrameNumber";
        case 0x0008 => return "TsUrbControlTransfer";
        case 0x0009 => return "TsUrbBulkOrInterruptTransfer";
        case 0x000a => return "TsUrbIsochTransfer";
        case 0x000b => return "TsUrbControlDescriptorRequest";
        case 0x000c => return "TsUrbControlDescriptorRequest";
        case 0x000d => return "TsUrbControlFeatureRequest";
        case 0x000e => return "TsUrbControlFeatureRequest";
        case 0x000f => return "TsUrbControlFeatureRequest";
        case 0x0010 => return "TsUrbControlFeatureRequest";
        case 0x0011 => return "TsUrbControlFeatureRequest";
        case 0x0012 => return "TsUrbControlFeatureRequest";
        case 0x0013 => return "TsUrbControlGetStatusRequest";
        case 0x0014 => return "TsUrbControlGetStatusRequest";
        case 0x0015 => return "TsUrbControlGetStatusRequest";
        case 0x0017 => return "TsUrbControlVendorOrClassRequest";
        case 0x0018 => return "TsUrbControlVendorOrClassRequest";
        case 0x0019 => return "TsUrbControlVendorOrClassRequest";
        case 0x001a => return "TsUrbControlVendorOrClassRequest";
        case 0x001b => return "TsUrbControlVendorOrClassRequest";
        case 0x001c => return "TsUrbControlVendorOrClassRequest";
        case 0x001e => return "TsUrbPipeRequest";
        case 0x001f => return "TsUrbControlVendorOrClassRequest";
        case 0x0020 => return "TsUrbControlVendorOrClassRequest";
        case 0x0021 => return "TsUrbControlGetStatusRequest";
        case 0x0022 => return "TsUrbControlFeatureRequest";
        case 0x0023 => return "TsUrbControlFeatureRequest";
        case 0x0024 => return "TsUrbControlDescriptorRequest";
        case 0x0025 => return "TsUrbControlDescriptorRequest";
        case 0x0026 => return "TsUrbControlGetConfigurationRequest";
        case 0x0027 => return "TsUrbControlGetInterfaceRequest";
        case 0x0028 => return "TsUrbControlDescriptorRequest";
        case 0x0029 => return "TsUrbControlDescriptorRequest";
        case 0x002a => return "TsUrbOSFeatureDescriptorRequest";
        case 0x0030 => return "TsUrbPipeRequest";
        case 0x0031 => return "TsUrbPipeRequest";
        case 0x0032 => return "TsUrbControlTransferEx";
        default => return "Unknown(" + (urbFunction as string) + ")";
    }
}

string UrbFuctionCode(ushort urbFunction)
{
    switch(urbFunction)
    {
        case 0x0000 => return "URB_FUNCTION_SELECT_CONFIGURATION";
        case 0x0001 => return "URB_FUNCTION_SELECT_INTERFACE";
        case 0x0002 => return "URB_FUNCTION_ABORT_PIPE";
        case 0x0003 => return "URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL";
        case 0x0004 => return "URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL";
        case 0x0005 => return "URB_FUNCTION_GET_FRAME_LENGTH";
        case 0x0006 => return "URB_FUNCTION_SET_FRAME_LENGTH";
        case 0x0007 => return "URB_FUNCTION_GET_CURRENT_FRAME_NUMBER";
        case 0x0008 => return "URB_FUNCTION_CONTROL_TRANSFER";
        case 0x0009 => return "URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER";
        case 0x000a => return "URB_FUNCTION_ISOCH_TRANSFER";
        case 0x000b => return "URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE";
        case 0x000c => return "URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE";
        case 0x000d => return "URB_FUNCTION_SET_FEATURE_TO_DEVICE";
        case 0x000e => return "URB_FUNCTION_SET_FEATURE_TO_INTERFACE";
        case 0x000f => return "URB_FUNCTION_SET_FEATURE_TO_ENDPOINT";
        case 0x0010 => return "URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE";
        case 0x0011 => return "URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE";
        case 0x0012 => return "URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT";
        case 0x0013 => return "URB_FUNCTION_GET_STATUS_FROM_DEVICE";
        case 0x0014 => return "URB_FUNCTION_GET_STATUS_FROM_INTERFACE";
        case 0x0015 => return "URB_FUNCTION_GET_STATUS_FROM_ENDPOINT";
        case 0x0016 => return "URB_FUNCTION_RESERVED_0X0016";
        case 0x0017 => return "URB_FUNCTION_VENDOR_DEVICE";
        case 0x0018 => return "URB_FUNCTION_VENDOR_INTERFACE";
        case 0x0019 => return "URB_FUNCTION_VENDOR_ENDPOINT";
        case 0x001a => return "URB_FUNCTION_CLASS_DEVICE";
        case 0x001b => return "URB_FUNCTION_CLASS_INTERFACE";
        case 0x001c => return "URB_FUNCTION_CLASS_ENDPOINT";
        case 0x001d => return "URB_FUNCTION_RESERVE_0X001D";
        case 0x001e => return "URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL";
        case 0x001f => return "URB_FUNCTION_CLASS_OTHER";
        case 0x0020 => return "URB_FUNCTION_VENDOR_OTHER";
        case 0x0021 => return "URB_FUNCTION_GET_STATUS_FROM_OTHER";
        case 0x0022 => return "URB_FUNCTION_CLEAR_FEATURE_TO_OTHER";
        case 0x0023 => return "URB_FUNCTION_SET_FEATURE_TO_OTHER";
        case 0x0024 => return "URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT";
        case 0x0025 => return "URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT";
        case 0x0026 => return "URB_FUNCTION_GET_CONFIGURATION";
        case 0x0027 => return "URB_FUNCTION_GET_INTERFACE";
        case 0x0028 => return "URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE";
        case 0x0029 => return "URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE";
        case 0x002a => return "URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR";
        case 0x002b => return "URB_FUNCTION_RESERVE_0X002B";
        case 0x002c => return "URB_FUNCTION_RESERVE_0X002C";
        case 0x002d => return "URB_FUNCTION_RESERVE_0X002D";
        case 0x002e => return "URB_FUNCTION_RESERVE_0X002E";
        case 0x002f => return "URB_FUNCTION_RESERVE_0X002F";
        case 0x0030 => return "URB_FUNCTION_SYNC_RESET_PIPE";
        case 0x0031 => return "URB_FUNCTION_SYNC_CLEAR_STALL";
        case 0x0032 => return "URB_FUNCTION_CONTROL_TRANSFER_EX";
        case 0x0033 => return "URB_FUNCTION_RESERVE_0X0033";
        case 0x0034 => return "URB_FUNCTION_RESERVE_0X0034";
        default => return ("Unknown(" + (urbFunction as string) + ")");
    }
}


string IOControlCodeFunction(uint function)
{
    switch(function)
    {
        case 0 => return "USB_SUBMIT_URB";
        case 1 => return "USB_RESET_PORT";
        case 3 => return "USB_GET_ROOTHUB_PDO";
        case 4 => return "USB_GET_PORT_STATUS";
        case 5 => return "USB_ENABLE_PORT";
        case 6 => return "USB_GET_HUB_COUNT";
        case 7 => return "USB_CYCLE_PORT";
        case 8 => return "USB_GET_HUB_NAME";
        case 9 => return "USB_IDLE_NOTIFICATION";
        case 10 => return "USB_RECORD_FAILURE";
        case 264 => return "USB_GET_BUS_INFO";
        case 265 => return "USB_GET_CONTROLLER_NAME";
        case 266 => return "USB_GET_BUSGUID_INFO";
        case 267 => return "USB_GET_PARENT_HUB_INFO";
        case 268 => return "USB_GET_DEVICE_HANDLE";
        case 269 => return "USB_GET_DEVICE_HANDLE_EX";
        case 270 => return "USB_GET_TT_DEVICE_HANDLE";
        case 271 => return "USB_GET_TOPOLOGY_ADDRESS";
        case 272 => return "USB_IDLE_NOTIFICATION_EX";
        case 273 => return "USB_REQ_GLOBAL_SUSPEND";
        case 274 => return "USB_REQ_GLOBAL_RESUME";
        case 275 => return "USB_GET_HUB_CONFIG_INFO";
        default => return ("Unknown(" + (function as string) + ")");
    }
}

// WORKAROUND: for minimum set of DTYP, remove all types only used for parsing from DTYP. TASK ID: 47115
pattern GUID = guid;
