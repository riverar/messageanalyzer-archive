protocol WiFi with 
BinaryEncodingDefaults {Endian = Endian.Little, TextEncoding = TextEncoding.ASCII},
Documentation
{
    ProtocolName = "WiFi Protocols",
    ShortName = "WiFi",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
    [
    new Reference{Name = "IEEE Std 802.11k", Version = "2008 Edition", Link = "http://standards.ieee.org/getieee802/download/802.11k-2008.pdf"},
    new Reference{Name = "IEEE Std 802.11r", Version = "2008 Edition", Link = "http://standards.ieee.org/getieee802/download/802.11r-2008.pdf"},
    new Reference{Name = "IEEE Std 802.11y", Version = "2008 Edition", Link = "http://standards.ieee.org/getieee802/download/802.11y-2008.pdf"},
    new Reference{Name = "IEEE Std 802.11w", Version = "2009 Edition", Link = "http://standards.ieee.org/getieee802/download/802.11w-2009.pdf"},
    new Reference{Name = "IEEE Std 802.11n", Version = "2009 Edition", Link = "http://standards.ieee.org/getieee802/download/802.11n-2009.pdf"},
    new Reference{Name = "IEEE Std 802.11u", Version = "2011 Edition", Link = "http://standards.ieee.org/getieee802/download/802.11u-2011.pdf"},
    new Reference{Name = "IEEE Std 802.11", Version = "2012 Edition", Link = "http://standards.ieee.org/getieee802/download/802.11-2012.pdf"},
    new Reference{Name = "IEEE Std 802.11ac", Version = "2013 Edition", Link = "http://standards.ieee.org/getieee802/download/802.11ac-2013.pdf"},
    ],
    RevisionSummary = 
    [
    new Revision{Class = RevisionClass.Major, Version="382196", Date="10/14/2015"}
    ]
};

using Standard;
using Utility;
using Diagnostics;
using IPv6;
using IPv4;
using CoreNetworkingResources;
using Reassembly;
using InfrastructureResources;

endpoint Node
    accepts mutable WiFiMessage;

endpoint GasReassembleNode
    over ReassembleNode
    accepts mutable WiFiMessage
{
    WiFiGasReassemblyHelper gasHelper = new WiFiGasReassemblyHelper{};

    // Cache GasComebackRequest for reassemble
    observe this accepts wifiMsg:WiFi.WiFiMessage where IsGasComebackRequest(wifiMsg)
    {
        GasComebackRequest cbReq = (wifiMsg.Body as PublicActionFrame).Action as GasComebackRequest;
        if (cbReq.DialogToken in gasHelper.CachedRequest)
        {
            gasHelper.CachedRequest[cbReq.DialogToken] += [wifiMsg];
        }
        else
        {
            gasHelper.CachedRequest[cbReq.DialogToken] = [wifiMsg];
        } 
    }

    // Deal with GasComebackResponse reassemble scenario
    process this accepts wifiMsg:WiFi.WiFiMessage where IsGasComebackResponse(wifiMsg)
    {
        GasComebackResponse res = (wifiMsg.Body as PublicActionFrame).Action as GasComebackResponse;
        byte curId = res.GasQueryResponseFragmentId.GasQueryResponseFragmentId;

        if (!res.GasQueryResponseFragmentId.MoreGasFragments) // received the last response fragment
        {
            // try to reassemble requests
            if (curId == 0) // only one fragment, don't need reassemble
            {
                // dispatch cached request;
                foreach (var r in gasHelper.CachedRequest[res.DialogToken])
                {
                    dispatch endpoint WiFi.Node accepts r;
                }
                gasHelper.CachedRequest = gasHelper.CachedRequest.Remove(res.DialogToken);
                // dispatch current response;
                dispatch endpoint WiFi.Node accepts wifiMsg;
                return;
            }
            else // more than one fragments, do reassembling
            {
                var reassembledReq = ReassembleGasComebackRequest(res.DialogToken);
                dispatch endpoint WiFi.Node accepts reassembledReq;
            }
        }

        if (res.DialogToken in gasHelper.Fragments)
        {
            if (curId in gasHelper.Fragments[res.DialogToken]) // duplicate fragment
            {
                ErrorCodeIf(true, wifiMsg, DiagnosisLevel.Warning, CoreNetworkingResources.WIFI_DUPLICATE_GAS_RES_FRAGMENT);
                DisplayTopLevelMessage(wifiMsg);
                return;
            }
            if (!res.GasQueryResponseFragmentId.MoreGasFragments) // last fragment
            {
                gasHelper.ExpectedFragmentCount[res.DialogToken] = (curId + 1) as byte;
            }
            gasHelper.Fragments[res.DialogToken] += {curId -> wifiMsg};
        }
        else
        {
            // It's the first fragment of this Dialog, initialize the ExpectedFragmentCount[res.DialogToken].
            // If the last fragments is not received, the ExpectedFragmentCount would be 0  
            gasHelper.ExpectedFragmentCount[res.DialogToken] = res.GasQueryResponseFragmentId.MoreGasFragments ? 0 : (curId + 1) as byte;
            gasHelper.Fragments += {res.DialogToken -> {curId -> wifiMsg}};
        }

        // Reassemble
        if (gasHelper.ExpectedFragmentCount[res.DialogToken] == gasHelper.Fragments[res.DialogToken].Count)
        {
            WiFiMessage reassembledResp = ReassembleGasComebackResponse(wifiMsg, res);
            dispatch endpoint WiFi.Node accepts reassembledResp;
        }
    }
    
    // destructor
    ~endpoint(WiFi.GasReassembleNode reassembleNode)
    {
        // display cached GAS Comeback Response messages
        foreach (byte outterKey in reassembleNode.gasHelper.Fragments.Keys())
        {
            foreach (byte innerKey in reassembleNode.gasHelper.Fragments[outterKey].Keys())
            {
                ReportInsufficientData(reassembleNode.gasHelper.Fragments[outterKey][innerKey], DiagnosisLevel.Error, Format(CoreNetworkingResources.WIFI_INSUFFICIENT_DATA, "GAS Query Response"));
                DisplayTopLevelMessage(reassembleNode.gasHelper.Fragments[outterKey][innerKey]);
            }
        }

        // dispatch cached GAS Comeback Request messages
        foreach (byte key in reassembleNode.gasHelper.CachedRequest.Keys())
        {
            foreach (var req in reassembleNode.gasHelper.CachedRequest[key])
            {
                dispatch endpoint WiFi.Node accepts req;
            }
        }

        reassembleNode.gasHelper = null;
    }
    
    void DecodeAnqpResponse(GasComebackResponse gasRes)
    {
        if (IsAnqpProtocol(gasRes.AdvertisementProtocolElement) && gasRes.QueryResponse is data:binary)
        {
            switch (data)
            {
                case m:AnqpElementArrayWrapper from BinaryDecoder<AnqpElementArrayWrapper> =>
                    gasRes.QueryResponse = m.Elements;
                default =>
                    ThrowDecodingException("WiFi", "GasComebackResponse");
            }
        }
    }
    
    int ComparerOfGasComebackResponse(WiFiMessage t1, WiFiMessage t2)
    {
        return  ((t1.Body as PublicActionFrame).Action as GasComebackResponse).GasQueryResponseFragmentId.GasQueryResponseFragmentId -
            ((t2.Body as PublicActionFrame).Action as GasComebackResponse).GasQueryResponseFragmentId.GasQueryResponseFragmentId;
    }
    
    optional binary GetGasQueryResponseData(WiFiMessage m)
    {
        if (((m.Body as PublicActionFrame).Action as GasComebackResponse).QueryResponse is data:binary)
        {
            return data;
        }
        return nothing;
    }

    WiFiMessage ReassembleGasComebackRequest(byte token)
    {
        if (token in gasHelper.CachedRequest)
        { 
            if (gasHelper.CachedRequest[token].Count == 1) // only 1 fragment, don't need reassemble
            {
                return gasHelper.CachedRequest[token][0];
            }
            else
            {
                WiFiMessage first = gasHelper.CachedRequest[token][0];
                WiFiMessage reassembledWifiMsg = new WiFiMessage
                {
                    MacHeader = first.MacHeader,
                    Body = first.Body
                };
                // associate source data
                binary sourceData = first.SourceData as binary;
                reassembledWifiMsg.SourceData = sourceData;
                int headerLength = (first.MacHeader as MacHeaderBase).GetByteLength();
                reassembledWifiMsg.AssignFieldEncodingInfo("MacHeader", 0, headerLength * 8);
                int bodyLength = sourceData.Count - headerLength;
                if (first.FCS != nothing)
                {
                    bodyLength -= 4;
                }
                reassembledWifiMsg.AssignFieldEncodingInfo("Body", headerLength * 8, bodyLength * 8);

                reassembledWifiMsg#SeqControl = first#SeqControl;
                reassembledWifiMsg#IsEncrypted = first#IsEncrypted;
                reassembledWifiMsg#SourceAddress = first#SourceAddress;
                reassembledWifiMsg#DestinationAddress = first#DestinationAddress;

                foreach (var msg in gasHelper.CachedRequest[token])
                {
                    reassembledWifiMsg.Origins += [msg];
                }
                gasHelper.CachedRequest = gasHelper.CachedRequest.Remove(token);
                return reassembledWifiMsg;
            }
        }
        else
        {
            ThrowDecodingException("WiFi", "WiFiMessage", UTILITY_LOST_SEGEMENT, []);
            return null;
        }
    }

    WiFiMessage ReassembleGasComebackResponse(WiFiMessage wifiMsg, GasComebackResponse res)
    {
        array<WiFiMessage> frags = gasHelper.Fragments[res.DialogToken].Values();
        frags = frags.Sort<WiFiMessage>(ComparerOfGasComebackResponse);
        binary payload = EmptyBinary;
        binary sourceData = null;

        WiFiMessage reassembledWifiMsg = new WiFiMessage
        {
            MacHeader = wifiMsg.MacHeader
        };

        foreach (var frag in frags)
        {
            if (GetGasQueryResponseData(frag) is data:binary)
            {
                payload += data;
            }
            reassembledWifiMsg.Origins += [frag];
            binary fragSourceData = (frag.SourceData as binary);
            if (sourceData == null)
            {
                // first source data contains header and body
                sourceData = frag.FCS == nothing ? fragSourceData : fragSourceData.Segment(0, fragSourceData.Count - 4);
            }
            else
            {
                // following source data only contains body
                int macHeaderLength = (frag.MacHeader as MacHeaderBase).GetByteLength();
                sourceData += fragSourceData.Segment(macHeaderLength, (frag.FCS == nothing ? fragSourceData.Count - macHeaderLength: fragSourceData.Count - macHeaderLength - 4));
            }
        }
        reassembledWifiMsg.SourceData = sourceData;
        int firstFragMacHeaderLength = (frags[0].MacHeader as MacHeaderBase).GetByteLength();
        reassembledWifiMsg.AssignFieldEncodingInfo("MacHeader", 0, firstFragMacHeaderLength * 8);
        reassembledWifiMsg.AssignFieldEncodingInfo("Body", firstFragMacHeaderLength * 8, (sourceData.Count - firstFragMacHeaderLength) * 8);

        GasComebackResponse reassembledGasRes = new GasComebackResponse
            {
                Category = res.Category,
                Action = res.Action,
                DialogToken = res.DialogToken,
                StatusCode = res.StatusCode,
                GasQueryResponseFragmentId = new GasQueryResponseFragmentId{MoreGasFragments = false, GasQueryResponseFragmentId = 0},
                GasComebackDelay = res.GasComebackDelay,
                AdvertisementProtocolElement = res.AdvertisementProtocolElement,
                QueryResponseLength = payload.Count as ushort,
                QueryResponse = payload
            };

        DecodeAnqpResponse(reassembledGasRes); // parse the ANQP elements in GAS Query Response

        reassembledWifiMsg.Body = new PublicActionFrame{Action = reassembledGasRes};
        reassembledWifiMsg#IsEncrypted = wifiMsg#IsEncrypted;
        reassembledWifiMsg#SourceAddress = wifiMsg#SourceAddress;
        reassembledWifiMsg#DestinationAddress = wifiMsg#DestinationAddress;
        
        // Associate Fields
        int adProtoElementLen = (reassembledGasRes.AdvertisementProtocolElement.Length + 2) * 8;
        int gasRespLen = 80 + adProtoElementLen + reassembledGasRes.QueryResponseLength * 8;
        int actionFrameLen = gasRespLen + 192;

        reassembledGasRes.AssignFieldEncodingInfo("Category", 192, 8);
        reassembledGasRes.AssignFieldEncodingInfo("Action", 200, 8);
        reassembledGasRes.AssignFieldEncodingInfo("DialogToken", 208, 8);
        reassembledGasRes.AssignFieldEncodingInfo("StatusCode", 216, 16);
        reassembledGasRes.AssignFieldEncodingInfo("GasQueryResponseFragmentId", 232, 8);
        reassembledGasRes.AssignFieldEncodingInfo("GasComebackDelay", 240, 16);
        reassembledGasRes.AssignFieldEncodingInfo("AdvertisementProtocolElement", 256, adProtoElementLen);
        reassembledGasRes.AssignFieldEncodingInfo("QueryResponseLength", 256 + adProtoElementLen, 16);
        if (reassembledGasRes.QueryResponse != nothing)
        {
            DataChunks dc = CreateDataChunks(payload, 0, payload.Count * 8);
            reassembledGasRes.AssociateField("QueryResponse", dc);
        }

        if (res.DialogToken in gasHelper.Fragments)
        {
            gasHelper.Fragments = gasHelper.Fragments.Remove(res.DialogToken);
        }
        if (res.DialogToken in gasHelper.ExpectedFragmentCount)
        {
            gasHelper.ExpectedFragmentCount = gasHelper.ExpectedFragmentCount.Remove(res.DialogToken);
        }
        return reassembledWifiMsg;
    }
}

// The index is binary concatenate of source MAC address and destination MAC address
endpoint ReassembleNode[binary SaDa]
    accepts mutable WiFiMessage
{
    WiFiReassemblyHelper reassemblyHelper = new WiFiReassemblyHelper{EPT = this, Direction = MessageDirection.Accepts};
    process this accepts wifiMsg:WiFi.WiFiMessage
    {
        reassemblyHelper.Reassemble(wifiMsg);
    }

    ~endpoint(ReassembleNode reassemblyNode)
    {
        reassemblyHelper.ClearInDestructor();
    }
}

type WiFiReassemblyCache
{
    bool LastFragmentArrived;
    // FragmentNumber -> WiFiMessage
    map<ushort, WiFiMessage> FragmentsOfOneMsg;
}

type WiFiReassemblyHelper : Reassembly.ReassemblyHelper<WiFiMessage>
{
    // SequenceNumber -> WiFiReassemblyCache
    map<ushort, WiFiReassemblyCache> ReassemblyCaches = {};

    override void DispatchMessage(WiFiMessage msg)
    {
        // parse the Body before dispatching message
        if (msg#IsEncrypted is false && msg.Body is data:binary && data.Count > 0)
        {
            stream body = data;

            MacHeaderBase header = msg.MacHeader as MacHeaderBase;
            var decodedBody = DecodeWiFiMessageBody(data, header.FrameControl.Type, header.FrameControl.SubType);

            if (decodedBody == nothing)
            {
                ValidationCheck(false, msg, WIFI_INVALID_BODY);
            }
            else
            {
                msg.Body = decodedBody;

                // WORKAROUND:
                // If 4 bytes remains, we'll decode it as FCS;
                if (body.BytePosition > 0 && body.ByteLength == body.BytePosition + 4)
                {
                    msg.FCS = body.PeekUInt(body.BytePosition * 8, Endian.Big);
                }
            }
        }

        if (IsNeedGasReassemble(msg))
        {
            dispatch endpoint WiFi.GasReassembleNode over EPT accepts msg;
        }
        else
        {
            dispatch endpoint WiFi.Node accepts msg;
        }
    }

    override bool IsCompleteMessage(WiFiMessage msg)
    {
        MacHeaderBase header = msg.MacHeader as MacHeaderBase;
        return msg#SeqControl == nothing || !header.FrameControl.MoreFrag && (msg#SeqControl is seqCtrl:SequenceControl && seqCtrl.FragmentNumber == 0);
    }

    override void Add(WiFiMessage msg)
    {
        SequenceControl seqCtrl = null;
        MacHeaderBase header = msg.MacHeader as MacHeaderBase;
        switch (header.FrameControl.Type)
        {
            case MessageType.Management =>
                if (msg.MacHeader is mgmtHeader:ManagementFrameMacHeader)
                {
                    seqCtrl = mgmtHeader.SequenceControl;
                }
            case MessageType.Control =>
                return;
            case MessageType.Data =>
                if (msg#SeqControl is seq:SequenceControl)
                {
                    seqCtrl = seq;
                }
            default =>
                return;
        }
        if (seqCtrl != null)
        {
            if (!(seqCtrl.SequenceNumber in ReassemblyCaches))
            {
                // This is the first arrived fragment
                map<ushort, WiFiMessage> fragmentsOfOneMsg = {seqCtrl.FragmentNumber -> msg};
                ReassemblyCaches[seqCtrl.SequenceNumber] = new WiFiReassemblyCache{LastFragmentArrived = !header.FrameControl.MoreFrag, FragmentsOfOneMsg = fragmentsOfOneMsg};
            }
            else
            {
                // This is a follow up fragment
                map<ushort, WiFiMessage> fragmentsOfOneMsg = ReassemblyCaches[seqCtrl.SequenceNumber].FragmentsOfOneMsg;
                if (seqCtrl.FragmentNumber in fragmentsOfOneMsg)
                {
                    ErrorCodeIf(true, msg, DiagnosisLevel.Warning, CoreNetworkingResources.WIFI_DUPLICATE_FRAGMENT);
                    DisplayTopLevelMessage(msg);
                    return;
                }
                else
                {
                    fragmentsOfOneMsg[seqCtrl.FragmentNumber] = msg;
                    ReassemblyCaches[seqCtrl.SequenceNumber].FragmentsOfOneMsg = fragmentsOfOneMsg;
                    if (!header.FrameControl.MoreFrag)
                    {
                        ReassemblyCaches[seqCtrl.SequenceNumber].LastFragmentArrived = true;
                    }
                }
            }
        } 
    }

    override bool IsAllFragmentsArrived(WiFiMessage msg)
    {
        return (msg#SeqControl is seqCtrl:SequenceControl) &&
                ReassemblyCaches[seqCtrl.SequenceNumber].LastFragmentArrived && 
                Utility.IsFragmentsSequentialCompleted<WiFiMessage>(
                    GetSorted(msg),
                    (WiFiMessage f) => (f#SeqControl as SequenceControl).FragmentNumber == 0, // Function to identify the first fragment
                    (WiFiMessage f) => (!(msg.MacHeader as MacHeaderBase).FrameControl.MoreFrag), // Function to identify the last fragment 
                    (WiFiMessage f) => (f#SeqControl as SequenceControl).FragmentNumber, // Function to get the sequence token of current fragment
                    (WiFiMessage f) => (f#SeqControl as SequenceControl).FragmentNumber + 1); // function to get the expected next sequence token
    }

    override array<WiFiMessage> GetSorted(WiFiMessage msg)
    {
        return ReassemblyCaches[(msg#SeqControl as SequenceControl).SequenceNumber].FragmentsOfOneMsg.Values.Sort();
    }

    override optional WiFiMessage GetMessageFromFragments(array<WiFiMessage> sortedMsg)
    {
        WiFiMessage msg = new WiFiMessage{};
        binary sourceData = null;
        binary body = EmptyBinary;
        foreach (var frag in sortedMsg)
        {
            if (frag#SeqControl is seqCtrl:SequenceControl && seqCtrl.FragmentNumber == 0)
            {
                msg.MacHeader = frag.MacHeader;
                body = frag.Body as binary;
                msg.FCS = frag.FCS;
                msg#SeqControl = seqCtrl;
                msg#IsEncrypted = frag#IsEncrypted;
                msg#SourceAddress = frag#SourceAddress;
                msg#DestinationAddress = frag#DestinationAddress;
            }
            else
            {
                body += frag.Body as binary;
            }
            msg.Body = body;
            msg.Origins += [frag];
            binary fragSourceData = (frag.SourceData as binary);
            if (sourceData == null)
            {
                // first source data contains header and body
                sourceData = frag.FCS == nothing ? fragSourceData : fragSourceData.Segment(0, fragSourceData.Count - 4);
            }
            else
            {
                // following source data only contains body
                int macHeaderLength = (frag.MacHeader as MacHeaderBase).GetByteLength();
                sourceData += fragSourceData.Segment(macHeaderLength, (frag.FCS == nothing ? fragSourceData.Count - macHeaderLength : fragSourceData.Count - macHeaderLength - 4));
            }
        }
        msg.SourceData = sourceData;
        int firstFragMacHeaderLength = (sortedMsg[0].MacHeader as MacHeaderBase).GetByteLength();
        msg.AssignFieldEncodingInfo("MacHeader", 0, firstFragMacHeaderLength * 8);
        msg.AssignFieldEncodingInfo("Body", firstFragMacHeaderLength * 8, (sourceData.Count - firstFragMacHeaderLength) * 8);
        return msg;
    }

    override void ClearAfterSuccess(WiFiMessage msg)
    {
        ReassemblyCaches = ReassemblyCaches.Remove((msg#SeqControl as SequenceControl).SequenceNumber);
    }

    override void ClearInDestructor()
    {
        foreach (WiFiReassemblyCache cache in ReassemblyCaches.Values)
        {
            if (cache.FragmentsOfOneMsg != null)
            {
                foreach (WiFiMessage msg in cache.FragmentsOfOneMsg.Values)
                {
                    ReportInsufficientData(msg, DiagnosisLevel.Error, Format(CoreNetworkingResources.WIFI_INSUFFICIENT_DATA, "WiFi"));
                    DisplayTopLevelMessage(msg);
                }
            }
        }
        ReassemblyCaches = {};
    }
}

const set<byte> APToClientWithQoSControlWithTXOPLimitSubTypeCodes = {0x0A, 0x0B, 0x0E, 0x0F};
const set<byte> APToClientWithQoSControlWithQAPPSBufferStateSubTypeCodes = {0x08, 0x09, 0x0C};

// WORKAROUND:
// Some implementation may not contain FCS field in the wifi message.
// To address this issue, we decode the frame body first, then decode the remaining 4 bytes as FCS if there is.
optional WiFiMessageBodyPattern DecodeWiFiMessageBody(stream data, byte msgType, byte subType)
{
    if (msgType == MessageType.Management)
    {
        switch (subType)
        {
            case ManagementSubType.AssociationRequest =>
                return BinaryDecoder<AssociationRequestFrame>(data);
            case ManagementSubType.AssociationResponse =>
                return BinaryDecoder<AssociationResponseFrame>(data);
            case ManagementSubType.ReassociationRequest =>
                return BinaryDecoder<ReassociationRequestFrame>(data);
            case ManagementSubType.ReassociationResponse =>
                return BinaryDecoder<ReassociationResponseFrame>(data);
            case ManagementSubType.ProbeRequest =>
                return BinaryDecoder<ProbeRequestFrame>(data);
            case ManagementSubType.ProbeResponse =>
                return BinaryDecoder<ProbeResponseFrame>(data);
            case ManagementSubType.Beacon =>
                return BinaryDecoder<BeaconFrame>(data);
            case ManagementSubType.ATIM =>
                return BinaryDecoder<ATIM>(data);
            case ManagementSubType.Disassociation =>
                return BinaryDecoder<DisassociationFrame>(data);
            case ManagementSubType.Authentication =>
                return BinaryDecoder<AuthenticationFrame>(data);
            case ManagementSubType.Deauthentication =>
                return BinaryDecoder<Deauthentication>(data);
            case ManagementSubType.Action =>
                switch (data.CurrentByte)
                {
                    case ActionCategory.SpectrumManagement =>
                        return BinaryDecoder<ActionFrame>(data);
                    case ActionCategory.QoS =>
                        return BinaryDecoder<ActionFrame>(data);
                    case ActionCategory.DLS =>
                        return BinaryDecoder<ActionFrame>(data);
                    case ActionCategory.BlockAck =>
                        return BinaryDecoder<ActionFrame>(data);
                    case ActionCategory.Public =>
                        return BinaryDecoder<PublicActionFrame>(data);
                    case ActionCategory.RadioMeasurement =>
                        return BinaryDecoder<ActionFrame>(data);
                    case ActionCategory.FastBSSTransition =>
                        return BinaryDecoder<ActionFrame>(data);
                    case ActionCategory.HT =>
                        return BinaryDecoder<ActionFrame>(data);
                    case ActionCategory.SAQuery =>
                        return BinaryDecoder<ActionFrame>(data);
                    case ActionCategory.VendorSpecific =>
                        return BinaryDecoder<VendorSpecificActionFrame>(data);
                    case ActionCategory.VHT => // defined in 802.11ac
                        return BinaryDecoder<ActionFrame>(data);
                    default =>;
                        return BinaryDecoder<binary>(data);
                }
            case ManagementSubType.ActionNoAck =>
                return BinaryDecoder<ActionNoAckFrame>(data);
            default =>;
                return BinaryDecoder<binary>(data);
        }
    }
    else if (msgType == MessageType.Control)
    {
        switch (subType)
        {
            case ControlSubType.BeamformingReportPoll =>
                return BinaryDecoder<BeamformingReportPollBody>(data);
            case ControlSubType.VHTNDPAnnouncement =>
                return BinaryDecoder<VHTNDPAnnouncementBody>(data);
            default =>
                return BinaryDecoder<binary>(data);
        }
    }
    else
    {
        return BinaryDecoder<binary>(data);
    }
}

/* 802.11 - 2012 section 8.2.3 General Frame Format
 *      2          2         6         6         6         2          6         2        4      variable  4
 * +---------+----------+---------+---------+---------+----------+---------+---------+---------+-------+-----+
 * |  Frame  | Duration | Address | Address | Address | Sequence | Address |   QoS   |    HT   | Frame | FCS |
 * | Control |  /ID     |    1    |    2    |    3    | Control  |    4    | Control | Control | Body  |     |
 * +---------+----------+---------+---------+---------+----------+---------+---------+---------+-------+-----+
 * In 802.11ac, it remove the length restriction of Frame Body
 */
message WiFiMessage[bool CanBeEncrypted, WiFi.HasFCS WiFiMessageHasFCS] : IComparable<WiFiMessage>
{
    WiFiMessageHeaderPattern MacHeader with Encoding{Decoder = AssignAnnotation, SourcePattern = TypeOf<WiFiMessageHeaderPattern>()};
    optional WiFiMessageBodyPattern Body with Encoding{Decoder = DecodeWifiBody};
    // Although FCS is a mandatory field per 802.11 spec. However, in real scenario:
    // 1) FCS may not be contained in some protocol implementation;
    // 2) Or may not be captrued into the traffic in some scenarios.
    optional uint FCS with BinaryEncoding{Endian = Endian.Big};

    override string ToString()
    {
        MacHeaderBase header = MacHeader as MacHeaderBase;
        string summary =  MessageNaming(header.FrameControl.Type, header.FrameControl.SubType) + ((this#IsEncrypted is bl:bool && bl) ? ", Encrypted" : ", Flags: " + GetControlInfor(this));
        if (header.FrameControl.Type == 0)
        {
            summary += GetSSIDString(this, header.FrameControl.SubType);
        }
        return summary;
    }

    int CompareTo(WiFiMessage other)
    {
        // This interface is only applicable when the 2 wifi message are fragments of the same MSDU (has the same SequenceNumber)
        if (this#SeqControl is thisSeqCtrl:SequenceControl && other#SeqControl is otherSeqCtrl:SequenceControl && thisSeqCtrl.SequenceNumber == otherSeqCtrl.SequenceNumber)
        {
            return thisSeqCtrl.FragmentNumber - otherSeqCtrl.FragmentNumber;
        }
        return 1;
    }

    optional WiFiMessageHeaderPattern AssignAnnotation(WiFiMessageHeaderPattern header)
    {
        // assign SequenceControl
        switch (header)
        {
            case apToAPMacHeader:APToAPMacHeader =>
                this#SeqControl = apToAPMacHeader.SequenceControl;
            case clientToApWithQoSControlMacHeader:ClientToApWithQoSControlMacHeader =>
                this#SeqControl = clientToApWithQoSControlMacHeader.SequenceControl;
            case clientToApMacHeader:ClientToApMacHeader =>
                this#SeqControl = clientToApMacHeader.SequenceControl;
            case adHocMacHeader:AdHocMacHeader =>
                this#SeqControl = adHocMacHeader.SequenceControl;
            case apToClientWithQoSControlWithTXOPLimitMacHeader:APToClientWithQoSControlWithTXOPLimitMacHeader =>
                this#SeqControl = apToClientWithQoSControlWithTXOPLimitMacHeader.SequenceControl;
            case apToClientWithQoSControlWithQAPPSBufferStateMacHeader:APToClientWithQoSControlWithQAPPSBufferStateMacHeader =>
                this#SeqControl = apToClientWithQoSControlWithQAPPSBufferStateMacHeader.SequenceControl;
            case apToClientMacHeader:APToClientMacHeader =>
                this#SeqControl = apToClientMacHeader.SequenceControl;
            default =>
                this#SeqControl = nothing;
        }
        return header;
    }

    optional WiFiMessageBodyPattern DecodeWifiBody(stream s)
    {
        MacHeaderBase header = this.MacHeader as MacHeaderBase;
        // if it is invalid or unknown Wi-Fi message, then decode the remaining binary as Wi-Fi body
        if (!IsKnownWiFiMessage(header.FrameControl.Type, header.FrameControl.SubType))
        {
            return BinaryDecoder<binary>(s);
        }

        bool isEncrypted = CanBeEncrypted && header.FrameControl.ProtectedFrame;
        this#IsEncrypted = isEncrypted;

        // =================================
        // WORKAROUND:
        // Some implementation of 802.11 protocol may not contain FCS field;
        // To workaround this, we'll decode frame body first, then if there is data remaining, it will be decoded as FCS.
        // The drawback of this workaround is: frame body of some wifi messages is variable (eg. wifi data frame), 
        // for this cases, we'll put the FCS data into the body part and lose the FCS field.

        bool existFCS;
        // Workaround codes:
        // 1.Control frame has no body, so the remaining data will be decoded as FCS;
        // 2.If data frame has body, the length of it will probably be greater than 4 bytes in real scenario. So, if there are only 4 bytes data remains, we assume FCS exists.
        if (WiFiMessageHasFCS == HasFCS.Unknown && 
            (header.FrameControl.Type == MessageType.Control || header.FrameControl.Type == MessageType.Data) &&
            (s.ByteLength == s.BytePosition + 4))
        {
            existFCS = true;
        }
        else
        {
            existFCS = (WiFiMessageHasFCS == HasFCS.Yes) && (s.ByteLength >= s.BytePosition + 4);
        }

        if (existFCS)
        {
            if (s.ByteLength > s.BytePosition + 4)
            {
                // update the decode stream if exist FCS
                s = (BinaryDecoder<Blob[(s.ByteLength - s.BytePosition - 4) as uint]>(s) as Blob).Data;
            }
            else
            {
                return nothing;
            }
        }
        // WORKAROUND END
        // =================================

        if (isEncrypted)
        {
            this#IsEncrypted = true;

            // decode encryption header
            return DecodeWiFiEncryptionHeader(s);
        }
        else
        {
            if ((this#SeqControl == nothing || (!header.FrameControl.MoreFrag && (this#SeqControl as SequenceControl).FragmentNumber == 0)) && // Not Fragmented
                !(header.FrameControl.Type == MessageType.Management && header.FrameControl.SubType == ManagementSubType.Action)) // Not GAS message
            {
                var wifiBody = DecodeWiFiMessageBody(s, header.FrameControl.Type, header.FrameControl.SubType);

                if (wifiBody == nothing)
                {
                    ValidationCheck(false, this, WIFI_INVALID_BODY);
                    return BinaryDecoder<binary>(s);
                }
                else
                {
                    return wifiBody;
                }
            }
            else
            {
                // decode Wi-Fi body as binary, it will be reassembled and then decoded as WiFi body
                return BinaryDecoder<binary>(s);
            }
        }    
    }
}

pattern WiFiMessageHeaderPattern = [|stream.RemainingByteLength() > 1|]
(
[|GetWiFiMessageType(stream.CurrentByte) == MessageType.Management && GetWiFiMessageSubType(stream.CurrentByte) != ManagementSubType.Reserved1 &&
    GetWiFiMessageSubType(stream.CurrentByte) != ManagementSubType.Reserved2 && InRange<ManagementSubType>(GetWiFiMessageSubType(stream.CurrentByte))|] ManagementFrameMacHeader |
[|GetWiFiMessageType(stream.CurrentByte) == MessageType.Control|] WiFiMessageControlHeaderPattern |
[|GetWiFiMessageType(stream.CurrentByte) == MessageType.Data|] WiFiMessageDataHeaderPattern |
MacHeaderBase
);

pattern WiFiMessageControlHeaderPattern = 
[|GetWiFiMessageSubType(stream.CurrentByte) == ControlSubType.ControlWrapper|] ControlWrapperMacHeader |
[|GetWiFiMessageSubType(stream.CurrentByte) == ControlSubType.BlockAckReq|] BlockAckReqFrameMacHeader |
[|GetWiFiMessageSubType(stream.CurrentByte) == ControlSubType.BlockAck|] BlockAckFrameMacHeader |
[|GetWiFiMessageSubType(stream.CurrentByte) == ControlSubType.PSPoll|] PSPollFrameMacHeader |
[|GetWiFiMessageSubType(stream.CurrentByte) == ControlSubType.RTS|] RtsFrameMacHeader |
[|GetWiFiMessageSubType(stream.CurrentByte) == ControlSubType.CTS|] CtsFrameMacHeader |
[|GetWiFiMessageSubType(stream.CurrentByte) == ControlSubType.ACK|] AckFrameMacHeader |
[|GetWiFiMessageSubType(stream.CurrentByte) == ControlSubType.CFEnd|] CFEndFrameMacHeader |
[|GetWiFiMessageSubType(stream.CurrentByte) == ControlSubType.CFEndCFAck|] CFEndCFAckFrameMacHeader |
// defined in 802.11ac - 2013
[|GetWiFiMessageSubType(stream.CurrentByte) == ControlSubType.BeamformingReportPoll|] BeamformingReportPollMacHeader |
[|GetWiFiMessageSubType(stream.CurrentByte) == ControlSubType.VHTNDPAnnouncement|] VHTNDPAnnouncementMacHeader |
MacHeaderBase;

pattern WiFiMessageDataHeaderPattern = 
[|IsWiFiMessageToDS(stream.PeekByte(8)) && IsWiFiMessageFromDS(stream.PeekByte(8))|] APToAPMacHeader |
[|IsWiFiMessageToDS(stream.PeekByte(8)) && !IsWiFiMessageFromDS(stream.PeekByte(8)) && GetWiFiMessageSubType(stream.CurrentByte) >= 8|] ClientToApWithQoSControlMacHeader |
[|IsWiFiMessageToDS(stream.PeekByte(8)) && !IsWiFiMessageFromDS(stream.PeekByte(8)) && GetWiFiMessageSubType(stream.CurrentByte) < 8|] ClientToApMacHeader |
[|!IsWiFiMessageToDS(stream.PeekByte(8)) && !IsWiFiMessageFromDS(stream.PeekByte(8))|] AdHocMacHeader |
[|!IsWiFiMessageToDS(stream.PeekByte(8)) && IsWiFiMessageFromDS(stream.PeekByte(8)) && GetWiFiMessageSubType(stream.CurrentByte) in APToClientWithQoSControlWithTXOPLimitSubTypeCodes|] APToClientWithQoSControlWithTXOPLimitMacHeader |
[|!IsWiFiMessageToDS(stream.PeekByte(8)) && IsWiFiMessageFromDS(stream.PeekByte(8)) && GetWiFiMessageSubType(stream.CurrentByte) in APToClientWithQoSControlWithQAPPSBufferStateSubTypeCodes|] APToClientWithQoSControlWithQAPPSBufferStateMacHeader |
[|!IsWiFiMessageToDS(stream.PeekByte(8)) && IsWiFiMessageFromDS(stream.PeekByte(8))|] APToClientMacHeader |
MacHeaderBase;

internal byte GetWiFiMessageType(byte b)
{
    return ((b >> 2) & 0x03) as byte;
}

internal byte GetWiFiMessageSubType(byte b)
{
    return (b >> 4) as byte;
}

internal bool IsWiFiMessageToDS(byte b)
{
    return (b & 0x01) as bool;
}

internal bool IsWiFiMessageFromDS(byte b)
{
    return ((b & 0x02) >> 1) as bool;
}


pattern WiFiMessageBodyPattern = AssociationRequestFrame |
             AssociationResponseFrame |
             ReassociationRequestFrame |
             ReassociationResponseFrame |
             ProbeRequestFrame |
             ProbeResponseFrame |
             BeaconFrame |
             ATIM |
             DisassociationFrame |
             AuthenticationFrame |
             Deauthentication |
             ActionFramePattern |
             ActionNoAckFrame |
             EncryptedFramePattern |
             VHTNDPAnnouncementBody |
             BeamformingReportPollBody |
             binary;

annotation bool WiFiMessage#IsEncrypted;
annotation MacAddress WiFiMessage#SourceAddress;
annotation MacAddress WiFiMessage#DestinationAddress;
annotation SequenceControl WiFiMessage#SeqControl;

MacAddress get Source(this WiFiMessage wifi)
{
    return wifi#SourceAddress as MacAddress;
}

MacAddress get Destination(this WiFiMessage wifi)
{
    return wifi#DestinationAddress as MacAddress;
}

MacAddress get SourceMACAddress(this WiFiMessage wifi)
{
    return wifi#SourceAddress as MacAddress;
}

MacAddress get DestinationMACAddress(this WiFiMessage wifi)
{
    return wifi#DestinationAddress as MacAddress;
}

string get Network(this WiFiMessage wifi)
{
    MacAddress sourceAddress = wifi#SourceAddress as MacAddress;
    MacAddress destinationAddress = wifi#DestinationAddress as MacAddress;
    string src = GetAlias("Utility.MacAddress", sourceAddress, this) ?? sourceAddress.ToString();
    string dst = GetAlias("Utility.MacAddress", destinationAddress, this) ?? destinationAddress.ToString();
    return (sourceAddress.Octets > destinationAddress.Octets ? (dst + " - " + src) : (src + " - " + dst));
}

const binary BlankMacAddress = $[000000000000];

bool IsGasComebackRequest(WiFiMessage msg)
{
    return msg.Body != nothing && msg.Body is f:PublicActionFrame && f.Action is GasComebackRequest;
}

bool IsGasComebackResponse(WiFiMessage msg)
{
    return msg.Body != nothing && msg.Body is f:PublicActionFrame && f.Action is GasComebackResponse;
}

bool IsNeedGasReassemble(WiFiMessage wifiMsg)
{
    return IsGasComebackRequest(wifiMsg) || IsGasComebackResponse(wifiMsg); // for now, only consider GAS reassemble
}

optional WiFiMessageBodyPattern DecodeWiFiEncryptionHeader(stream body)
{
    if (body.RemainingByteLength >= 4)
    {
        byte octet3 = body.PeekByte(body.BitPosition + 16); // the 3rd byte
        byte octet4 = body.PeekByte(body.BitPosition + 24); // the 4th byte
        // 802.11 - 2012, section 11.4.2.2 TKIP MPDU formats
        // 802.11 - 2012, section 11.4.3.2 CCMP MPDU format
        // rule#1: for TKIP and CCMP (and for WEP, see rule#2), the least significant 5 bits of the 4th octet is reserved, should be 0;
        if ((octet4 & 0x1F) == 0)
        {
            // 802.11 - 2012, section 11.2.2.2 WEP MPDU format
            // rule#2: for WEP, the least significant six bits of the 4th octet should be 0;
            if ((octet4 & 0x3F) != 0) // Not WEP
            {
                // 802.11 - 2012, section 11.4.3.2 CCMP MPDU format
                // rule#3: for CCMP, the 3rd byte is reserved, should be 0;
                if (octet3 != 0)
                {
                    // 802.11 - 2012, section 11.4.2.2 TKIP MPDU formats
                    // rule#4: for TKIP, the WEPSeed is set to (TSC1 | 0x20 ) & 0x7F.
                    byte tsc1 = body.PeekByte(body.BitPosition); // TSC1 is the first octet; 
                    byte wepSeed = body.PeekByte(body.BitPosition + 8); // WEPSeed is the second octet;
                    if (((tsc1 | 0x20) & 0x7F) == wepSeed)
                    {
                        if (BinaryDecoder<TKIP>(body) is tkip:TKIP)
                        {
                            return tkip;
                        }
                    }
                }
                else if (BinaryDecoder<CCMP>(body) is ccmp:CCMP)
                {
                    return ccmp;
                }
            }
            else if (BinaryDecoder<WEP>(body) is wep:WEP)
            {
                return wep;
            }
        }
    }
    // otherwise, will not decode the encryption header

    return BinaryDecoder<binary>(body); // decode Wi-Fi body as binary if it cannot be decoded as encrypted header
}

bool DecodeWiFiMessageAndDispatch(binary bin)
{
    return DecodeWiFiMessageAndDispatch(bin, false, WiFi.HasFCS.Unknown);
}

bool DecodeWiFiMessageAndDispatch(binary bin, bool canBeEncrypted)
{
    return DecodeWiFiMessageAndDispatch(bin, canBeEncrypted, WiFi.HasFCS.Unknown);
}

const set<byte> MessageHaveSourceAddressSubTypeCodes = {7, 10, 12, 13};

bool DecodeWiFiMessageAndDispatch(binary bin, bool canBeEncrypted, WiFi.HasFCS hasFCS)
{
    int pointer = 0; // used for association source data
    bool existFCS;
    stream strm = bin;
    WiFiMessage wifi = new WiFiMessage{Body = nothing, FCS = nothing};
    wifi.SourceData = bin;

    if (BinaryDecoder<WiFiMessage[canBeEncrypted, hasFCS]>(strm) is wifiMessage:WiFiMessage)
    {
        wifi = wifiMessage;
    }
    else
    {
        ThrowDecodingException("WiFi", "WiFiMessage", UTILITY_PARSE_ERROR, ["MacHeader"]);
    }

    MacHeaderBase header = wifi.MacHeader as MacHeaderBase;
    if (!IsKnownWiFiMessage(header.FrameControl.Type, header.FrameControl.SubType))
    {
        wifi#SourceAddress = new MacAddress{Octets = BlankMacAddress};
        wifi#DestinationAddress = new MacAddress{Octets = BlankMacAddress};
        dispatch endpoint WiFi.Node accepts wifi;
        return true;
    }

    MacAddress sourceAddress = null;
    MacAddress destinationAddress = null;
    switch (wifi.MacHeader)
    {
        // for some Mac Header, destination address and source address 
        // is not from 4th byte and 10th byte
        case apToAPMacHeader:APToAPMacHeader =>
            sourceAddress = apToAPMacHeader.SA;
            destinationAddress = apToAPMacHeader.DA;
        case clientToApMacHeader:ClientToApMacHeader =>
            sourceAddress = clientToApMacHeader.SA;
            destinationAddress = clientToApMacHeader.DA;
        case apToClientWithQoSControlWithTXOPLimitMacHeader:APToClientWithQoSControlWithTXOPLimitMacHeader =>
            sourceAddress = apToClientWithQoSControlWithTXOPLimitMacHeader.SA;
            destinationAddress = apToClientWithQoSControlWithTXOPLimitMacHeader.DA;
        case apToClientWithQoSControlWithQAPPSBufferStateMacHeader:APToClientWithQoSControlWithQAPPSBufferStateMacHeader =>
            sourceAddress = apToClientWithQoSControlWithQAPPSBufferStateMacHeader.SA;
            destinationAddress = apToClientWithQoSControlWithQAPPSBufferStateMacHeader.DA;
        case apToClientMacHeader:APToClientMacHeader =>
            sourceAddress = apToClientMacHeader.SA;
            destinationAddress = apToClientMacHeader.DA;
        default =>
            // by default, destination address start from the 4th byte
            destinationAddress = new MacAddress{Octets = strm.PeekBytes(32, 6)};
            if (!((header.FrameControl.Type == 1) &&
                (header.FrameControl.SubType in MessageHaveSourceAddressSubTypeCodes)))
            {
                // source address start from the 10th byte
                sourceAddress = new MacAddress{Octets = strm.PeekBytes(80, 6)};
            }
            else
            {
                sourceAddress = new MacAddress{Octets = BlankMacAddress};
            }
    }
    
    wifi#SourceAddress = sourceAddress;
    wifi#DestinationAddress = destinationAddress;
    binary index;
    if (sourceAddress.Octets <= destinationAddress.Octets)
    {
        index = sourceAddress.Octets + destinationAddress.Octets;
    }
    else
    {
        index = destinationAddress.Octets + sourceAddress.Octets;
    }

    if (canBeEncrypted && header.FrameControl.ProtectedFrame)
    {
        dispatch endpoint WiFi.Node accepts wifi;
        return true;
    }
    else
    {
        wifi#IsEncrypted = false;
        if ((wifi#SeqControl == nothing || (!header.FrameControl.MoreFrag && (wifi#SeqControl as SequenceControl).FragmentNumber == 0)) && // Not Fragmented
            !(header.FrameControl.Type == MessageType.Management && header.FrameControl.SubType == ManagementSubType.Action)) // Not GAS message
        {
            dispatch endpoint WiFi.Node accepts wifi;
        }
        else
        {
            dispatch endpoint WiFi.ReassembleNode[index] accepts wifi;
        }
        return true;
    }
}

bool DecodeWirelessWanMessage(binary binaryValue)
{
    if (binaryValue.Count <= 0)
    {
        return false;
    }
    else
    {
        // Check IP version. According to the definition in IPv4 and IPv6, version of IP is 4 bit width
        byte ipVersion = (binaryValue[0] >> 4) as byte;

        if (ipVersion == 4)
        {
            switch (binaryValue)
            {
                case d:IPv4.Datagram from BinaryDecoder =>
                    DispatchIPv4DatagramToReassemblyNode(d);
                    return true;
                default => 
                    return false;
            }
        }
        // IPv6
        else if (ipVersion == 6)
        {
            switch (binaryValue)
            {
                case d:IPv6.Datagram from IPv6Decoder =>
                    DispatchIPv6DatagramToReassemblyNode(d);
                    return true;
                default =>
                    return false;
            }
        }
        else
        {
            return false;
        }
    }
}

const set<byte> SubTypeDonnotHaveData = {4, 5, 6, 7, 12, 14, 15};

bool WiFiDataFrameHasNoData(byte subType)
{
    return subType in SubTypeDonnotHaveData;
}

// =========== 8.2.4 Frame fields ===============
// 802.11 - 2012 section 8.2.4.1 Frame Control field
type FrameControl
{
    bool Order              with BinaryEncoding{Width = 1};
    bool ProtectedFrame     with BinaryEncoding{Width = 1};
    bool MoreData           with BinaryEncoding{Width = 1};
    bool PwrMgt             with BinaryEncoding{Width = 1};
    bool Retry              with BinaryEncoding{Width = 1};
    bool MoreFrag           with BinaryEncoding{Width = 1};
    bool FromDS             with BinaryEncoding{Width = 1};
    bool ToDS               with BinaryEncoding{Width = 1};
    byte SubType            with BinaryEncoding{Width = 4}, DisplayInfo{ToText = FrameControlSubTypeToString};
    MessageType Type        with BinaryEncoding{Width = 2};
    byte ProtocolVersion    with BinaryEncoding{Width = 2};

    string FrameControlSubTypeToString(any subType)
    {
        if (subType is byteNum:byte)
        {
            switch (Type)
            {
                case MessageType.Management =>
                    return EnumToString<ManagementSubType>(byteNum, true);
                case MessageType.Control =>
                    if (!InRange<ControlSubType>(byteNum))
                        return "Reserved";
                    else
                        return EnumToString<ControlSubType>(byteNum, true);
                case MessageType.Data =>
                    return EnumToString<DataSubType>(byteNum, true);
                default =>
                    return "Reserved";
            }
        }
        else
            return subType.ToString();
    }

} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 802.11 - 2012 section 8.2.4.1.3 Type and Subtype fields
pattern MessageType = enum byte
{
    Management = 0,
    Control = 1,
    Data = 2,
    Reserved = 3,
    ...
};

pattern ManagementSubType = enum byte
{
    AssociationRequest = 0,
    AssociationResponse = 1,
    ReassociationRequest = 2,
    ReassociationResponse = 3,
    ProbeRequest = 4,
    ProbeResponse = 5,
    TimeAdvertisement = 6,
    Reserved1 = 7,
    Beacon = 8,
    ATIM = 9,
    Disassociation = 10,
    Authentication = 11,
    Deauthentication = 12,
    Action = 13,
    ActionNoAck = 14,
    Reserved2 = 15,
    ...
};

pattern ControlSubType = enum byte
{
    ControlWrapper = 7,
    BlockAckReq = 8,
    BlockAck = 9,
    PSPoll = 10,
    RTS = 11,
    CTS = 12,
    ACK = 13,
    CFEnd = 14,
    CFEndCFAck = 15,
    // defined in 802.11ac
    BeamformingReportPoll = 4,
    VHTNDPAnnouncement = 5,
    ...
};

pattern DataSubType = enum byte
{
    Data = 0,
    DataCFAck = 1,
    DataCFPoll = 2,
    DataCFAckCFPoll = 3,
    Null = 4,
    CFAck = 5,
    CFPoll = 6,
    CFAckCFPoll = 7,
    QoSData = 8,
    QoSDataCFAck = 9,
    QoSDataCFPoll = 10,
    QoSDataCFAckCFPoll = 11,
    QoSNull = 12,
    Reserved= 13,
    QoSCFPoll= 14,
    QoSCFAckCFPoll= 15,
    ...
};

// 802.11 - 2012 section 8.4.1.11 Action field Table 8-38 Category values
pattern ActionCategory = enum byte
{
    SpectrumManagement = 0,
    QoS = 1,
    DLS = 2,
    BlockAck = 3,
    Public = 4,
    RadioMeasurement = 5,
    FastBSSTransition = 6,
    HT = 7,
    SAQuery = 8,
    ProtectedDualOfPublicAction = 9,
    WNM = 10,
    UnprotectedWNM = 11,
    TDLS = 12,
    Mesh = 13,
    Multihop = 14,
    SelfProtected = 15,
    VHT = 21,
    VendorSpecificProtected = 126,
    VendorSpecific = 127,
    ...
};

// 802.11 - 2012 section 8.2.4.4 Sequence Control field
type SequenceControl
{
    ushort SequenceNumber with BinaryEncoding{Width = 12, Endian = Endian.Big};
    ushort FragmentNumber with BinaryEncoding{Width = 4};
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// Updated by 802.11ac - 2013 Section 8.2.4.6 HT Control Field
pattern HTControl = [|stream.RemainingByteLength > 1|]
([|(stream.CurrentByte & 0x80) == 0|] HTVariant |
[|(stream.CurrentByte & 0x80) > 0|] VHTVariant);

// Updated by 802.11ac - 2013 Section 8.2.4.6.2 HT variant
type HTVariant
{
    LinkAdaptationControl LinkAdaptationControl;
    
    byte CSISteering            with BinaryEncoding{Width = 2};
    byte Reserved1 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved1", "HTControl", value) with BinaryEncoding{Width = 2};
    byte CalibrationSequence    with BinaryEncoding{Width = 2};
    byte CalibrationPosition    with BinaryEncoding{Width = 2};
    
    byte RDGMorePPDU            with BinaryEncoding{Width = 1};
    byte ACConstraint           with BinaryEncoding{Width = 1};
    byte Reserved2 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved2", "HTControl", value) with BinaryEncoding{Width = 5};
    byte NDPAnnouncement        with BinaryEncoding{Width = 1};
}

type LinkAdaptationControl
{
    byte MFSIL           with BinaryEncoding{Width = 2};
    byte MAI             with BinaryEncoding{Width = 4};
    byte TRQ             with BinaryEncoding{Width = 1};
    byte Reserved        with BinaryEncoding{Width = 1};
    
    byte MFBASELC        with BinaryEncoding{Width = 7};
    byte MFSIH           with BinaryEncoding{Width = 1};
}

// Updated by 802.11ac - 2013 Section 8.2.4.6.3 VHT variant
type VHTVariant
{
    byte RDGMorePPDU with BinaryEncoding{Width = 1};
    byte ACConstraint with BinaryEncoding{Width = 1};
    byte UnsolicitedMFB with BinaryEncoding{Width = 1};
    byte FbTxType with BinaryEncoding{Width = 1};
    byte CodingType with BinaryEncoding{Width = 1};
    byte GidH with BinaryEncoding{Width = 3};
    ushort Mfb with BinaryEncoding{Width = 15};
    byte MfsiGidl with BinaryEncoding{Width = 3};
    byte MsiStbc with BinaryEncoding{Width = 3};
    bool MRQ with BinaryEncoding{Width = 1};
    byte Reserved with BinaryEncoding{Width = 1};
    bool VHT with BinaryEncoding{Width = 1};
} with BinaryEncoding{WidthForComposedType = 32, DecodeAsUnit = true};

type MacHeaderBase
{
    FrameControl FrameControl;

    virtual int GetByteLength()
    {
        return 2;
    }
}

// =========== 8.3.1 Control frames ===============
// 802.11 - 2012 section 8.3.1.2 RTS frame format
type RtsFrameMacHeader : MacHeaderBase
{
    ushort Duration;
    MacAddress RA;
    MacAddress TA;

    override int GetByteLength()
    {
        return base.GetByteLength() + 14; // 2 + 6 + 6
    }
}

// 802.11 - 2012 section 8.3.1.3 CTS frame format
type CtsFrameMacHeader : MacHeaderBase
{
    ushort Duration;
    MacAddress RA;

    override int GetByteLength()
    {
        return base.GetByteLength() + 8; // 2 + 6
    }
}

// 802.11 - 2012 section 8.3.1.4 ACK frame format
type AckFrameMacHeader : MacHeaderBase
{
    ushort Duration;
    MacAddress RA;

    override int GetByteLength()
    {
        return base.GetByteLength() + 8; // 2 + 6
    }
}

// 802.11 - 2012 section 8.3.1.5 PS-Poll frame format
type PSPollFrameMacHeader : MacHeaderBase
{
    ushort AID;
    MacAddress BSSID;
    MacAddress TA;

    override int GetByteLength()
    {
        return base.GetByteLength() + 14; // 2 + 6 + 6
    }
}

// 802.11 - 2012 section 8.3.1.6 CF-End frame format
type CFEndFrameMacHeader : MacHeaderBase
{
    ushort Duration where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Duration", "CFEndFrame", value);
    MacAddress RA;
    MacAddress BSSID;

    override int GetByteLength()
    {
        return base.GetByteLength() + 14; // 2 + 6 + 6
    }
}

// 802.11 - 2012 section 8.3.1.7 CF-End+CF-Ack frame format
type CFEndCFAckFrameMacHeader : MacHeaderBase
{
    ushort Duration where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Duration", "CFEndCFAckFrame", value);
    MacAddress RA;
    MacAddress BSSID;

    override int GetByteLength()
    {
        return base.GetByteLength() + 14; // 2 + 6 + 6
    }
}

// 802.11 - 2012 section 8.3.1.8 BlockAckReq frame format
type BlockAckReqFrameMacHeader : MacHeaderBase
{
    ushort DurationID;
    MacAddress RA;
    MacAddress TA;

    override int GetByteLength()
    {
        return base.GetByteLength() + 14; // 2 + 6 + 6
    }
}

type BARControl
{
    ushort TID        with BinaryEncoding{Width = 4};
    ushort Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "BARControl", value) with BinaryEncoding{Endian = Endian.Big, Width = 12};
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

type BlockAckStartingSequenceControl
{
    ushort StartSequenceNumber with BinaryEncoding{Endian = Endian.Big, Width = 12};
    ushort FragmentNumber where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "WiFi", "FragmentNumber", "BlockAckStartingSequenceControl", value) with BinaryEncoding{Width = 4};
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 802.11 - 2012 section 8.3.1.9 BlockAck frame format
type BlockAckFrameMacHeader : MacHeaderBase
{
    ushort DurationID;
    MacAddress RA;
    MacAddress TA;

    override int GetByteLength()
    {
        return base.GetByteLength() + 14; // 2 + 6 + 6
    }
}

// 802.11 - 2012 section 8.3.1.10 Control Wrapper frame
type ControlWrapperMacHeader : MacHeaderBase
{
    ushort DurationID;
    MacAddress Address1;
    byte SubType            with BinaryEncoding{Width = 4};
    byte Type               with BinaryEncoding{Width = 2};
    byte ProtocolVersion    with BinaryEncoding{Width = 2};
    bool Order              with BinaryEncoding{Width = 1};
    bool ProtectedFrame     with BinaryEncoding{Width = 1};
    bool MoreData           with BinaryEncoding{Width = 1};
    bool PwrMgt             with BinaryEncoding{Width = 1};
    bool Retry              with BinaryEncoding{Width = 1};
    bool MoreFrag           with BinaryEncoding{Width = 1};
    bool FromDS             with BinaryEncoding{Width = 1};
    bool ToDS               with BinaryEncoding{Width = 1};
    HTControl HTControl;

    override int GetByteLength()
    {
        return base.GetByteLength() + 14; // 2 + 6 + 2 + 4
    }
}

// 802.11 - 2013 section 8.3.1.20 VHT NDP Announcement frame format
type VHTNDPAnnouncementMacHeader : MacHeaderBase
{
    ushort DurationID;
    MacAddress RA;
    MacAddress TA;
}

type SoundingDialogToken
{
    byte Reserved with BinaryEncoding{Width = 2};
    byte SoundingDialogTokenNumber with BinaryEncoding{Width = 6};
}

type STAInfo
{
    byte NcIndex with BinaryEncoding{Width = 3};
    StaInfoFeedbackType FeedbackType with BinaryEncoding{Width = 1};
    ushort AID12 with BinaryEncoding{Width = 12};
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

pattern StaInfoFeedbackType = enum byte
{
    SU = 0,
    MU = 1,
    ...
};

type VHTNDPAnnouncementBody
{
    SoundingDialogToken SoundingDialogToken;
    array<STAInfo> STAInfo;
}

// 802.11 - 2013 section 8.3.1.21 Beamforming Report Poll Frame Format
type BeamformingReportPollMacHeader : MacHeaderBase
{
    ushort DurationID;
    MacAddress RA;
    MacAddress TA;
}

type BeamformingReportPollBody
{
    byte FeedbackSegmentRetransmissionBitmap;
}

// =========== 8.3.2 Data frames ===============
// 802.11 - 2012 section 8.3.2 Data Frame
type AdHocMacHeader[bool Order, byte SubType] : MacHeaderBase
{
    ushort Duration;
    MacAddress DA;
    MacAddress SA;
    MacAddress BSSID;
    SequenceControl SequenceControl;
    optional [|(SubType >= 8) && Order|] HTControl HTControl;

    override int GetByteLength()
    {
        return base.GetByteLength() + 22 + (HTControl == nothing ? 0 : 4); // 2 + 6 + 6 + 6 + 2
    }
}

type AdHoc[bool NoData]
{
    optional [|!NoData|] binary Data;
}

type ClientToApMacHeader : MacHeaderBase
{
    ushort Duration;
    MacAddress BSSID;
    MacAddress SA;
    MacAddress DA;
    SequenceControl SequenceControl;

    override int GetByteLength()
    {
        return base.GetByteLength() + 22; // 2 + 6 + 6 + 6 + 2
    }
}

type ClientToApWithQoSControlMacHeader[bool Order] : ClientToApMacHeader
{
    // QoSControlWithQueueSize QoSControl;
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "ClientToApWithQoSControlMacHeader", value) with BinaryEncoding{Width = 1};
    byte AckPolicy               with BinaryEncoding{Width = 2};
    byte BIT4 with BinaryEncoding{Width = 1};
    bool TID                     with BinaryEncoding{Width = 4};
    optional [|BIT4 == 1|] byte QueueSize;
    optional [|BIT4 == 0|] byte TXOPDurationRequested;
    optional [|Order|] HTControl HTControl;
}

type APToClientMacHeader[bool Order, byte SubType] : MacHeaderBase
{
    ushort Duration;
    MacAddress DA;
    MacAddress BSSID;
    MacAddress SA;
    SequenceControl SequenceControl;
    optional [|(SubType >= 8) && Order|] HTControl HTControl;

    override int GetByteLength()
    {
        return base.GetByteLength() + 22 + (HTControl == nothing ? 0 : 4); // 2 + 6 + 6 + 6 + 2
    }
}

type APToClientWithQoSControlWithTXOPLimitMacHeader[bool Order, byte SubType] : MacHeaderBase
{
    ushort Duration;
    MacAddress DA;
    MacAddress BSSID;
    MacAddress SA;
    SequenceControl SequenceControl;
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "APToClientWithQoSControlWithTXOPLimitMacHeader", value) with BinaryEncoding{Width = 1};
    byte AckPolicy  with BinaryEncoding{Width = 2};
    byte EOSP       with BinaryEncoding{Width = 1};
    byte TID        with BinaryEncoding{Width = 4};
    byte TXOPLimit;
    optional [|Order|] HTControl HTControl;

    override int GetByteLength()
    {
        return base.GetByteLength() + 24 + (HTControl == nothing ? 0 : 4); // 2 + 6 + 6 + 6 + 2 + 2
    }
}

type APToClientWithQoSControlWithQAPPSBufferStateMacHeader[bool Order, byte SubType] : MacHeaderBase
{
    ushort Duration;
    MacAddress DA;
    MacAddress BSSID;
    MacAddress SA;
    SequenceControl SequenceControl;
    byte Reserved1 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved1", "APToClientWithQoSControlWithQAPPSBufferStateMacHeader", value) with BinaryEncoding{Width = 1};
    byte AckPolicy                  with BinaryEncoding{Width = 2};
    bool EOSP                       with BinaryEncoding{Width = 1};
    byte TID                        with BinaryEncoding{Width = 4};
    
    byte QAPBufferedLoad            with BinaryEncoding{Width = 4};
    byte HighestPriorityBufferedAC  with BinaryEncoding{Width = 2};
    bool BufferedStateIndicated     with BinaryEncoding{Width = 1};
    byte Reserved2 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved2", "APToClientWithQoSControlWithQAPPSBufferStateMacHeader", value) with BinaryEncoding{Width = 1};
    optional [|Order|] HTControl HTControl;

    override int GetByteLength()
    {
        return base.GetByteLength() + 24 + (HTControl == nothing ? 0 : 4); // 2 + 6 + 6 + 6 + 2 + 2
    }
}

type APToAPMacHeader[bool Order, byte SubType] : MacHeaderBase
{
    ushort Duration;
    MacAddress RA;
    MacAddress TA;
    MacAddress DA;
    SequenceControl SequenceControl;
    MacAddress SA;
    optional [|(SubType >= 8) && Order|] HTControl HTControl;

    override int GetByteLength()
    {
        return base.GetByteLength() + 28 + (HTControl == nothing ? 0 : 4); // 2 + 6 + 6 + 6 + 2 + 6
    }
}

// =========== 8.3.3 Management frames ===============
// 802.11 - 2012 section 8.3.3.1 Format of management frames
type ManagementFrameMacHeader : MacHeaderBase
{
    ushort Duration;
    MacAddress DA;
    MacAddress SA;
    MacAddress BSSID;
    SequenceControl SequenceControl;

    override int GetByteLength()
    {
        return base.GetByteLength() + 22; // 2 + 6 + 6 + 6 + 2
    }
}

// 802.11 - 2012 section 8.3.3.2 Beacon frame format
type BeaconFrame
{
    ulong TimeStamp;
    ushort BeaconInterval;
    Capability Capability;
    array<InformationField> InformationElements;
}

// 802.11 - 2012 section 8.3.3.3 ATIM frame format
type ATIM
{
    // empty
}

// 802.11 - 2012 section 8.3.3.4 Disassociation frame format
type DisassociationFrame
{
    ushort Reason;
    array<InformationField> InformationElements;
}

// 802.11 - 2012 section 8.3.3.5 Association Request frame format
type AssociationRequestFrame
{
    Capability Capability;
    ushort ListenInterval;
    array<InformationField> InformationElements;
}

// 802.11 - 2012 section 8.3.3.6 Association Response frame format
type AssociationResponseFrame
{
    Capability Capability;
    ushort Status;
    AssociationID AssociationID;
    array<InformationField> InformationElements;
}

type AssociationID
{
    byte AssociationIDL;
    byte Reserved where ValidationCheck(value == 3, null, "WiFi: The Reserved field in type AssociationID is reserved and should be set to 3, not " + (value as string) + ".") with BinaryEncoding{Width = 2};
    byte AssociationIDH with BinaryEncoding{Width = 6};
}

// 802.11 - 2012 section 8.3.3.7 Reassociation Request frame format
type ReassociationRequestFrame
{
    Capability Capability;
    ushort ListenInterval;
    MacAddress CurrentAP;
    array<InformationField> InformationElements;
}

// 802.11 - 2012 section 8.3.3.8 Reassociation Response frame format
type ReassociationResponseFrame
{
    Capability Capability;
    ushort Status;
    AssociationID AssociationID;
    array<InformationField> InformationElements;
}

// 802.11 - 2012 section 8.3.3.9 Probe Request frame format
type ProbeRequestFrame
{
    array<InformationField> InformationElements;
}

// 802.11 - 2012 section 8.3.3.10 Probe Response frame format
type ProbeResponseFrame
{
    ulong TimeStamp;
    ushort BeaconInterval;
    Capability Capability;
    array<InformationField> InformationElements;
}

// 802.11 - 2012 section 8.3.3.11 Authentication frame format
type AuthenticationFrame
{
    AuthenticationAlgorithmNumber AuthenticationAlgorithmNumber;
    ushort AuthenticationTransactionSequenceNumber;
    ushort StatusCode;
    array<InformationField> InformationElements;
}

// 802.11 - 2012 section 8.3.3.12 Deauthentication
type Deauthentication
{
    ushort ReasonCode;
    array<InformationField> InformationElements;
}

// 802.11 - 2012 section 8.3.3.13 Action frame format
type ActionNoAckFrame
{
    ActionFrameBody Action;
    array<InformationField> InformationElements;
}

// 802.11 - 2012 section 8.3.3.14 Action No Ack frame format
type ActionFrame
{
    ActionFrameBody Action;
    optional [|RemainingBitLength(stream) > 0|] array<InformationField> InformationElements; // The last Management MIC element (if exist) will be contained in this array.
}

// 802.11 - 2012 section 8.3.3.15 Timing Advertisement frame format
// Not Covered

// =================== 8.4.1 Fields that are not information elements ==================
// 802.11 - 2012 section 8.4.1.1 Authentication Algorithm Number field
pattern AuthenticationAlgorithmNumber = enum ushort
{
    OpenSystem = 0,
    SharedKey = 1,
    FastBSSTransition = 2,
    SimultaneousAuthenticationOfEquals = 3,
    VendorSpecificUse = 65535,
    ...
};

// 802.11 - 2012 section 8.4.1.4 Capability Information field
pattern Capability = flags ushort
{
    ESS                = 0x0001,
    IBSS               = 0x0002,
    CFPollable         = 0x0004,
    CFPollRequest      = 0x0008,
    Privacy            = 0x0010,
    ShortPreamble      = 0x0020,
    PBCC               = 0x0040,
    ChannelAgility     = 0x0080,
    SpectrumManagement = 0x0100,
    QoS                = 0x0200,
    ShortSlotTime      = 0x0400,
    APSD               = 0x0800,
    RadioMeasurement   = 0x1000,
    DSSSOFDM           = 0x2000,
    DelayedBlockAck    = 0x3000,
    ImmediateBlockAck  = 0x8000,
    ...
};

// 802.11 - 2012 section 8.4.1.14 Block Ack Parameter Set field
type BlockAckParameterSet
{
    byte BufferSizeL    with BinaryEncoding{Width = 2};
    byte TID            with BinaryEncoding{Width = 4};
    byte BlockAckPolicy with BinaryEncoding{Width = 1};
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "BlockAckParameterSet", value) with BinaryEncoding{Width = 1};
    byte BufferSizeH;
}

// 802.11 8.4.1.16 DELBA Parameter Set field
type DELBAParameterSet
{
    byte Reserved1 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved1", "DELBAParameterSet", value);
    byte TID            with BinaryEncoding{Width = 4};
    byte BlockAckPolicy with BinaryEncoding{Width = 1};
    byte Reserved2 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved2", "DELBAParameterSet", value) with BinaryEncoding{Width = 3};
}

// 802.11 - 2012 section 8.4.1.22 SM Power Control field
type SMPowerControl
{
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "SMPowerControl", value) with BinaryEncoding{Width = 6};
    byte SMMode             with BinaryEncoding{Width = 1};
    byte SMPowerSaveEnabled with BinaryEncoding{Width = 1};
}

// 802.11 - 2012 section 8.4.1.24 PSMP Parameter Set field
type PSMPParameterSet
{
    byte PSMPSequenceDurationL  with BinaryEncoding{Width = 2};
    byte MorePSMP               with BinaryEncoding{Width = 1};
    byte NSTA                   with BinaryEncoding{Width = 5};
    byte PSMPSequenceDurationH;
}

// 802.11 - 2012 section 8.4.1.25 PSMP STA Info field
type PSMPSTAInfo
{
    (PSMPSTAInfoGroupAddressed | PSMPSTAInfoIndividuallyAddressed) Info;
}

type PSMPSTAInfoGroupAddressed
{
    byte PSMPDTTStartOffsetL    with BinaryEncoding{Width = 6};
    byte STAINFOType where value == 1 with BinaryEncoding{Width = 2};
    byte PSMPDTTDurationL       with BinaryEncoding{Width = 6};
    byte PSMPDTTStartOffsetH    with BinaryEncoding{Width = 2};
    byte PSMPGroupAddressIDL    with BinaryEncoding{Width = 3};
    byte PSMPDTTDurationH       with BinaryEncoding{Width = 5};
    byte PSMPGroupAddressIDM;
    uint PSMPGroupAddressIDH;
}

type PSMPSTAInfoIndividuallyAddressed
{
    byte PSMPDTTStartOffsetL    with BinaryEncoding{Width = 6};
    byte STAINFOType where value == 2 with BinaryEncoding{Width = 2};
    byte PSMPDTTDurationL       with BinaryEncoding{Width = 6};
    byte PSMPDTTStartOffsetH    with BinaryEncoding{Width = 2};
    byte StaIdL                 with BinaryEncoding{Width = 3};
    byte PSMPDTTDurationH       with BinaryEncoding{Width = 5};
    byte StaIdM;
    byte PSMPUTTStartOffsetL    with BinaryEncoding{Width = 3};
    byte StaIdH                 with BinaryEncoding{Width = 5};
    byte PSMPUTTStartOffsetH;
    byte PSMPUTTDurationL;
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "PSMPSTAInfoIndividuallyAddressed", value) with BinaryEncoding{Width = 6};
    byte PSMPUTTDurationH       with BinaryEncoding{Width = 2};
}

// 802.11 - 2012 section 8.4.1.26 MIMO Control field
type MIMOControl
{
    byte CoefficientSizeL          with BinaryEncoding{Width = 1};
    byte Grouping                  with BinaryEncoding{Width = 2};
    byte MIMOControlChannelWidth   with BinaryEncoding{Width = 1};
    byte NrIndex                   with BinaryEncoding{Width = 2};
    byte NcIndex                   with BinaryEncoding{Width = 2};
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "MIMOControl", value) with BinaryEncoding{Width = 2};
    byte RemainingMatrixSegment    with BinaryEncoding{Width = 3};
    byte CodebookInformation       with BinaryEncoding{Width = 2};
    byte CoefficientSizeH          with BinaryEncoding{Width = 1};
    uint SoundingTimestamp;
}

int get CoefficientSize(this MIMOControl mimo)
{
    return mimo.CoefficientSizeH * 2 + mimo.CoefficientSizeL;
}

// 802.11 - 2012 section 8.4.1.27 CSI Report field
type CSIReport[uint NcCount, uint NbCount, uint NrCount, uint CarrierCount]
{
    array<byte> SNR with BinaryEncoding{Length = NrCount};
    array<Matrix[NcCount, NbCount, NrCount]> Matrixes with BinaryEncoding{Length = CarrierCount};
}

type Matrix[uint NcCount, uint NbCount, uint NrCount]
{
    array<Bit> Bits with BinaryEncoding{Length = (3 + 2 * NbCount * NcCount * NrCount)};
}

uint CountIncrease(uint input)
{
    return input + 1;
}

uint CSIReportNbCountTransform(uint input)
{
    switch (input)
    {
        case 0 =>
            return 4;
        case 1 =>
            return 5;
        case 2 =>
            return 6;
        case 3 =>
            return 8;
        default =>
            return 0;
    }
}

uint CarrierCountTransform20MHz(uint input)
{
    switch (input)
    {
        case 0 =>
            return 56;
        case 1 =>
            return 30;
        case 2 =>
            return 16;
        default =>
            return 0;
    }
}

uint CarrierCountTransform40MHz(uint input)
{
    switch (input)
    {
        case 0 =>
            return 114;
        case 1 =>
            return 58;
        case 2 =>
            return 30;
        default =>
            return 0;
    }
}

type Bit
{
    byte Bit with BinaryEncoding{Width = 1};
}

// 802.11 - 2012 section 8.4.1.33 GAS Query Response Fragment ID field
type GasQueryResponseFragmentId
{
    bool MoreGasFragments with BinaryEncoding{Width = 1};
    byte GasQueryResponseFragmentId with BinaryEncoding{Width = 7};
}

// 802.11 - 2012 section 8.4.1.34 Venue Info field
type VenueInfo
{
    VenueGroup VenueGroup;
    ([|VenueGroup == 0|] VenueType0
    | [|VenueGroup == 1|] VenueType1
    | [|VenueGroup == 2|] VenueType2
    | [|VenueGroup == 3|] VenueType3
    | [|VenueGroup == 4|] VenueType4
    | [|VenueGroup == 5|] VenueType5
    | [|VenueGroup == 6|] VenueType6
    | [|VenueGroup == 7|] VenueType7
    | [|VenueGroup == 8|] VenueType8
    | [|VenueGroup == 9|] VenueType9
    | [|VenueGroup == 10|] VenueType10
    | [|VenueGroup == 11|] VenueType11
    | byte) VenueType;
}

pattern VenueGroup = enum byte
{
    Unspecified = 0,
    Assembly = 1,
    Business = 2,
    Educational = 3,
    FactoryAndIndustrial = 4,
    Institutional = 5,
    Mercantile = 6,
    Residential = 7,
    Storage = 8,
    UtilityAndMiscellaneous = 9,
    Vehicular = 10,
    Outdoor = 11,
    ...
};

pattern VenueType0 = enum byte
{
    $"Unspecified" = 0,
    ...
};

pattern VenueType1 = enum byte
{
    $"Unspecified Assembly" = 0,
    $"Arena" = 1,
    $"Stadium" = 2,
    $"Passenger Terminal (e.g., airport, bus, ferry, train station)" = 3,
    $"Amphitheater" = 4,
    $"Amusement Park" = 5,
    $"Place of Worship" = 6,
    $"Convention Center" = 7,
    $"Library" = 8,
    $"Museum" = 9,
    $"Restaurant" = 10,
    $"Theater" = 11,
    $"Bar" = 12,
    $"Coffee Shop" = 13,
    $"Zoo or Aquarium" = 14,
    $"Emergency Coordination Center" = 15,
    ...
};

pattern VenueType2 = enum byte
{
    $"Unspecified Business" = 0,
    $"Doctor or Dentist office" = 1,
    $"Bank" = 2,
    $"Fire Station" = 3,
    $"Police Station" = 4,
    $"Post Office" = 6,
    $"Professional Office" = 7,
    $"Research and Development Facility" = 8,
    $"Attorney Office" = 9,
    ...
};

pattern VenueType3 = enum byte
{
    $"Unspecified Educational" = 0,
    $"School, Primary" = 1,
    $"School, Secondary" = 2,
    $"University or College" = 3,
    ...
};

pattern VenueType4 = enum byte
{
    $"Unspecified Factory and Industrial" = 0,
    $"Factory" = 1,
    ...
};

pattern VenueType5 = enum byte
{
    $"Unspecified Institutional" = 0,
    $"Hospital" = 1,
    $"Long-Term Care Facility (e.g., Nursing home, Hospice, etc.)" = 2,
    $"Alcohol and Drug Re-habilitation Center" = 3,
    $"Group Home" = 4,
    $"Prison or Jail" = 5,
    ...
};

pattern VenueType6 = enum byte
{
    $"Unspecified Mercantile" = 0,
    $"Retail Store" = 1,
    $"Grocery Market" = 2,
    $"Automotive Service Station" = 3,
    $"Shopping Mall" = 4,
    $"Gas Station" = 5,
    ...
};

pattern VenueType7 = enum byte
{
    $"Unspecified Residential" = 0,
    $"Private Residence" = 1,
    $"Hotel or Motel" = 2,
    $"Dormitory" = 3,
    $"Boarding House" = 4,
    ...
};

pattern VenueType8 = enum byte
{
    $"Unspecified Storage" = 0,
    ...
};

pattern VenueType9 = enum byte
{
    $"Unspecified Utility and Miscellaneous" = 0,
    ...
};

pattern VenueType10 = enum byte
{
    $"Unspecified Vehicular" = 0,
    $"Automobile or Truck" = 1,
    $"Airplane" = 2,
    $"Bus" = 3,
    $"Ferry" = 4,
    $"Ship or Boat" = 5,
    $"Train" = 6,
    $"Motor Bike" = 7,
    ...
};

pattern VenueType11 = enum byte
{
    $"Unspecified Outdoor" = 0,
    $"Muni-mesh Network" = 1,
    $"City Park" = 2,
    $"Rest Area" = 3,
    $"Traffic Control" = 4,
    $"Bus Stop" = 5,
    $"Kiosk" = 6,
    ...
};

// 802.11ac - 2013 section 8.4.1.47 VHT MIMO Control field
type VHTMIMOControlField
{
    byte ChannelWidth with BinaryEncoding{Width = 2}, DisplayInfo{ToText = ChannelWidthToString};
    byte NrIndex with BinaryEncoding{Width = 3};
    byte NcIndex with BinaryEncoding{Width = 3};

    byte FirstFeedbackSegment with BinaryEncoding{Width = 1};
    byte RemainingFeedbackSegments with BinaryEncoding{Width = 3};
    FeedbackTypePattern FeedbackType with BinaryEncoding{Width = 1};
    byte CodebookInformation with BinaryEncoding{Width = 1};
    byte Grouping with BinaryEncoding{Width = 2};

    byte SoundingDialogTokenNumber with BinaryEncoding{Width = 6};
    byte Reserved with BinaryEncoding{Width = 2};

    string ChannelWidthToString(any input)
    {
        switch (input as byte)
        {
            case 0 => return "20 MHz";
            case 1 => return "40 MHz";
            case 2 => return "80 MHz";
            case 3 => return "160 MHz or 80+80 MHz";
            default => return "Reserved";
        }
    }
}

pattern FeedbackTypePattern = enum byte
{
    SU = 0,
    MU = 1,
};

const array<array<uint>> NumberOfAnglesArray =
[
    [  0 ],
    [  2,  2 ],
    [  4,  6,  6 ],
    [  6, 10, 12, 12 ],
    [  8, 14, 18, 20, 20 ],
    [ 10, 18, 24, 28, 30, 30 ],
    [ 12, 22, 30, 36, 40, 42, 42 ],
    [ 14, 26, 36, 44, 50, 54, 56, 56 ]
];
// 802.11ac - 2013 section 8.4.1.48 VHT Compressed Beamforming Report field
type VHTCompressedBeamformingReportField[VHTMIMOControlField VHTMIMOControlField]
{
    binary Matrix with BinaryEncoding{Length = CalculateMatrixLength(VHTMIMOControlField)};
}

uint CalculateMatrixLength(VHTMIMOControlField vhtMIMOControlField)
{
    uint b1;
    uint b2;
    if (vhtMIMOControlField.FeedbackType == FeedbackTypePattern.SU)
    {
        if (vhtMIMOControlField.CodebookInformation == 0)
        {
            b1 = 2;
            b2 = 4;
        }
        else
        {
            b1 = 4;
            b2 = 6;
        }
    }
    else
    {
        if (vhtMIMOControlField.CodebookInformation == 0)
        {
            b1 = 5;
            b2 = 7;
        }
        else
        {
            b1 = 7;
            b2 = 9;
        }
    }

    if (vhtMIMOControlField.NrIndex >= NumberOfAnglesArray.Count)
    {
        return 0;
    }
    else if (vhtMIMOControlField.NcIndex >= NumberOfAnglesArray[vhtMIMOControlField.NrIndex].Count)
    {
        return 0;
    }
    else
    {
        uint na = NumberOfAnglesArray[vhtMIMOControlField.NrIndex][vhtMIMOControlField.NcIndex];
        uint sizeInBit = na * (b1 + b2) / 2;

        // roundup 8
        return (sizeInBit & 0x00000007) > 0 ? (sizeInBit >> 3 + 1) : (sizeInBit >> 3);
    }
}

// 802.11ac - 2013 section 8.4.1.50 Operating Mode field
type OperationModeField
{
    byte ChannelWidth with BinaryEncoding{Width = 2}, DisplayInfo{ToText = ChannelWidthToString};
    byte Reserved with BinaryEncoding{Width = 2};
    byte RxNSS with BinaryEncoding{Width = 3};
    byte RxNNSType with BinaryEncoding{Width = 1};

    string ChannelWidthToString(any input)
    {
        switch (input as byte)
        {
            case 0 => return "20 MHz";
            case 1 => return "40 MHz";
            case 2 => return "80 MHz";
            case 3 => return "160 MHz";
            default => return "Reserved";
        }
    }
}

// 802.11ac - 2013 section 8.4.1.51 Membership Status Array field
type MembershipStatusArrayField
{
    array<MembershipStatus> MembershipStatusInGroup with BinaryEncoding{Width = 1, Length = 64};
}

pattern MembershipStatus = enum byte
{
    $"STA is not a member of the group" = 0,
    $"STA is a member of the group" = 1,
};

// 802.11ac - 2013 section 8.4.1.52 User Position Array field
type UserPositionArrayField
{
    array<byte> UserPosition with BinaryEncoding{Width = 2, Length = 64};
}

// =================== 8.4.2 Information elements ==================
// 802.11 - 2012 section 8.4.2.1 General
type GeneralElement
{
    byte ElementId;
    byte Length;
    binary Information with BinaryEncoding{Length = Length};
}

// 802.11 - 2012 section 8.4.2.2 SSID element
type SSID
{
    (byte where value == 0) ElementID;
    (byte where value >= 0 && value <= 32) Length;
    optional [|Length > 0|] string SSID with BinaryEncoding{Length = Length};

    override string ToString()
    {
        if (this.SSID is str:string)
            return "SSID: " + str;
        else
            return "SSID";
    }
}

// 802.11 - 2012 section 8.4.2.3 Supported Rates element
type SupportedRates
{
    byte ElementID;
    (byte where value >= 1 && value <= 8) Length;
    array<SupportedRate> SupportedRates with BinaryEncoding{Length = Length};

    override string ToString()
    {
        string summaryLine = "SupportedRates: " + SupportedRatesToString(SupportedRates[0].SupportedRate);

        for (int i = 1; i < SupportedRates.Count; i++)
        {
            summaryLine += ", " + SupportedRatesToString(SupportedRates[i].SupportedRate);
        }
        return summaryLine;
    }
}

type SupportedRate
{
    bool ContainedInBSSBasicRateSet with BinaryEncoding{Width = 1};
    byte SupportedRate with BinaryEncoding{Width = 7},
        DisplayInfo{ToText = (any x) => SupportedRatesToString(x as byte) + " Mbps"};

    override string ToString()
    {
        return SupportedRatesToString(SupportedRate) + " Mbps";
    }
}

string SupportedRatesToString(byte supportedRate)
{
    return (supportedRate / 2).ToString() + ((supportedRate & 0x01) > 0 ? ".5" : ".0");
}

// 802.11 - 2012 section 8.4.2.4 FH Parameter Set element
type FHParameterSet
{
    byte ElementID;
    (byte where value == 5) Length;
    ushort DwellTime;
    byte HopSet;
    byte HopPattern;
    byte HopIndex;
}

// 802.11 - 2012 section 8.4.2.5 DSSS Parameter Set element
type DSParameterSet
{
    byte ElementID;
    (byte where value == 1) Length;
    byte CurrentChannel;
}

// 802.11 - 2012 section 8.4.2.6 CF Parameter Set element
type CFParameterSet
{
    byte ElementID;
    (byte where value == 6) Length;
    byte CFPCount;
    byte CFPPeriod;
    ushort CFPMaxDuration;
    ushort CFPDurRemaining;
}

// 802.11 - 2012 section 8.4.2.7 TIM element
type TIM
{
    byte ElementID;
    (byte where value >= 3) Length;
    byte DTIMCount;
    byte DTIMPeriod;
    BitmapControl BitmapControl;
    optional [|Length > 3|] binary VirtualBitmap with BinaryEncoding{Length = (Length - 3)};
}

type BitmapControl
{
    byte BitmapOffset     with BinaryEncoding{Width = 7};
    bool TrafficIndicator with BinaryEncoding{Width = 1};
}

// 802.11 - 2012 section 8.4.2.8 IBSS Parameter Set element
type IBSSParameterSet
{
    byte ElementID;
    (byte where value == 2) Length;
    ushort ATIMWindow;
}

// 802.11 - 2012 section 8.4.2.9 Challenge Text element
type ChallengeText
{
    byte ElementID;
    byte Length;
    binary ChallengeText with BinaryEncoding{Length = Length};
}

// 802.11 - 2012 section 8.4.2.10 Country element
type Country
{
    byte ElementID;
    (byte where value >= 6) Length;
    string CountryString with BinaryEncoding{Length = 3};
    array<Channel> Channel with BinaryEncoding{Length = ((Length - 3) / 3)};
    optional [|Length % 2 == 1|] byte Padding;

    override string ToString()
    {
        return "Country: " + CountryString;
    }
}

type Channel
{
    byte FirstChannelNumber;
    byte NumChannels;
    byte MaxTransmitPowerLevel;
}

// 802.11 - 2012 section 8.4.2.11 Hopping Pattern Parameters element
type HoppingPatternParameters
{
    byte ElementID;
    (byte where value == 2) Length;
    byte PrimeRadix;
    byte NumChannels;
}

// 802.11 - 2012 section 8.4.2.12 Hopping Pattern Table element
type HoppingPatternTable
{
    byte ElementID;
    byte Length;
    byte Flag;
    byte NumSets;
    byte Modulus;
    byte Offset;
    optional [|Flag == 1|] binary RandomTable with BinaryEncoding{Length = (Length - 4)};
}

// 802.11 - 2012 section 8.4.2.13 Request element
type Request
{
    (byte where value == 10) ElementID;
    byte Length;
    array<byte> RequestedElementID with BinaryEncoding{Length = Length};
}

// 802.11 - 2012 section 8.4.2.14 ERP element
type ERPInformation
{
    byte ElementID; // 42
    (byte where value == 1) Length;
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "ERPInformation", value) with BinaryEncoding{Width = 5};
    bool BarkerPreambleMode with BinaryEncoding{Width = 1};
    bool UseProtection      with BinaryEncoding{Width = 1};
    bool NonERPPresent      with BinaryEncoding{Width = 1};
}

// 802.11 - 2012 section 8.4.2.15 Extended Supported Rates element
type ExtendedSupportedRates
{
    (byte where value == 50) ElementID;
    byte Length;
    binary ExtendedSupportedRates with BinaryEncoding{Length = Length};
}

// 802.11 - 2012 section 8.4.2.16 Power Constraint element
type PowerConstraint
{
    byte ElementID;
    (byte where value == 1) Length;
    byte PowerConstraint;
}

// 802.11 - 2012 section 8.4.2.17 Power Capability element
type PowerCapability
{
    byte ElementID;
    (byte where value == 2) Length;
    byte MinimumTransmitPowerCapability;
    byte MaximumTransmitPowerCapability;
}

// 802.11 - 2012 section 8.4.2.18 TPC Request element
type TPCRequest
{
    (byte where value == 34) ElementID;
    (byte where value == 0) Length;
}

// 802.11 - 2012 section 8.4.2.19 TPC Report element
type TPCReport
{
    (byte where value == 35) ElementID;
    (byte where value == 2) Length;
    byte TransmitPower;
    byte LinkMargin;
}

// 802.11 - 2012 section 8.4.2.20 Supported Channels element
type SupportedChannels
{
    (byte where value == 36) ElementID;
    byte Length;
    array<SupportedChannel> SupportedChannel with BinaryEncoding{Length = Length / 2};
}

type SupportedChannel
{
    byte FirstChannelNumber;
    byte NumChannels;
}

// 802.11 - 2012 section 8.4.2.21 Channel Switch Announcement element
type ChannelSwitchAnnouncement
{
    (byte where value == 37) ElementID;
    (byte where value == 3) Length;
    byte ChannelSwitchMode;
    byte NewChannelNumber;
    byte ChannelSwitchCount;
}

// 802.11n section 8.4.2.22 Secondary Channel Offset element
type SecondaryChannelOffset
{
    (byte where value == 62) ElementID;
    (byte where value == 1) Length;
    byte SecondaryChannelOffset;
}

// 802.11 - 2012 section 8.4.2.23 Measurement Request element
type MeasurementRequest
{
    (byte where value == 38) ElementID;
    byte Length;
    byte MeasurementToken;
    MeasurementRequestMode MeasurementRequestMode;
    MeasurementRequestPattern MeasurementRequest;
}

pattern MeasurementRequestPattern = [|RemainingBitLength(stream) >= 8|]
    ([|CurrentByte(stream) in {0, 1, 2}|] SpectrumManagement |
    [|CurrentByte(stream) == 3|] ChannelLoadRequest |
    [|CurrentByte(stream) == 4|] NoiseHistogramRequest |
    [|CurrentByte(stream) == 5|] BeaconRequest |
    [|CurrentByte(stream) == 6|] FrameRequest |
    [|CurrentByte(stream) == 7|] StaStatisticsRequest |
    [|CurrentByte(stream) == 8|] LocationConfigurationInformationRequest |
    [|CurrentByte(stream) == 9|] TransmitStreamCategoryMeasurementRequest |
    [|CurrentByte(stream) == 255|] MeasurementPauseRequest);

// 802.11 - 2012  Figure 8-105Measurement Request Mode field
type MeasurementRequestMode
{
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "MeasurementRequestMode", value) with BinaryEncoding{Width = 3};
    bool DurationMandatory with BinaryEncoding{Width = 1};
    bool Report            with BinaryEncoding{Width = 1};
    bool Request           with BinaryEncoding{Width = 1};
    bool Enable            with BinaryEncoding{Width = 1};
    bool Parallel          with BinaryEncoding{Width = 1};
}

// 802.11 - 2012 section 8.4.2.23.2 Basic request
type SpectrumManagement
{
    byte MeasurementType;
    byte ChannelNumber;
    ulong MeasurementStartTime;
    ushort MeasurementDuration;
}

// 802.11 - 2012 section 8.4.2.23.4 RPI histogram request
// Not covered

// 802.11 - 2012 section 8.4.2.23.5 Channel Load Request
type ChannelLoadRequest
{
    byte MeasurementType;
    byte RegulatoryClass;
    byte ChannelNumber;
    ushort RandomizationInterval;
    ushort MeasurementDuration;
    array<SubElementForChannelLoadRequestPattern> SubElements;
}

pattern SubElementForChannelLoadRequestPattern = 
    [|stream.RemainingByteLength() > 1|]
    (
        [|stream.CurrentByte == 1|] ChannelLoadReportingInformation |
        [|stream.CurrentByte == 163|] WideBandwidthChannelSwitchElement |
        [|stream.CurrentByte == 221|] VendorSpecificInformation
    );

type ChannelLoadReportingInformation
{
    byte SubElementID;
    byte Length;
    byte ReportingCondition;
    byte ChannelLoadReferenceValue;
}

// 802.11 - 2012 section 8.4.2.23.6 Noise Histogram Request
type NoiseHistogramRequest
{
    byte MeasurementType;
    byte RegulatoryClass;
    byte ChannelNumber;
    ushort RandomizationInterval;
    ushort MeasurementDuration;
    array<SubElementForNoiseHistogramRequestPattern> SubElements;
}

pattern SubElementForNoiseHistogramRequestPattern = [|stream.RemainingByteLength() > 1|]
(
    [|stream.CurrentByte == 1|] NoiseHistogramReportingInformation |
    [|stream.CurrentByte == 163|] WideBandwidthChannelSwitchElement |
    [|stream.CurrentByte == 221|] VendorSpecificInformation
);

type NoiseHistogramReportingInformation
{
    (byte where value == 1) SubElementID;
    (byte where value == 2) Length;
    byte ReportingCondition;
    byte ANPIReferenceValue;
}

// 802.11 - 2012 section 8.4.2.23.7 Beacon Request
type BeaconRequest
{
    byte MeasurementType;
    byte RegulatoryClass;
    byte ChannelNumber;
    ushort RandomizationInterval;
    ushort MeasurementDuration;
    byte MeasurementMode;
    MacAddress BSSID;
    array<SubElementForBeaconRequestElementPattern> SubElements;
}

pattern SubElementForBeaconRequestElementPattern = [|RemainingBitLength(stream) >= 8|]
    ([|CurrentByte(stream) == 0|] SSID |
    [|CurrentByte(stream) == 1|] BeaconReportingInformation |
    [|CurrentByte(stream) == 2|] ReportingDetail |
    [|CurrentByte(stream) == 10|] Request |
    [|CurrentByte(stream) == 51|] APChannelReport |
    [|CurrentByte(stream) == 163|] WideBandwidthChannelSwitchElement |
    [|CurrentByte(stream) == 221|] VendorSpecificInformation);

type BeaconReportingInformation
{
    (byte where value == 1) SubElementID;
    (byte where value == 2) Length;
    byte ReportingCondition;
    byte ThresholdOffsetReferenceValue;
}

type ReportingDetail
{
    (byte where value == 2) SubElementID;
    (byte where value == 1) Length;
    byte DetailValue;
}

// 802.11 - 2012 section 8.4.2.23.8 Frame request
type FrameRequest
{
    byte MeasurementType;
    byte RegulatoryClass;
    byte ChannelNumber;
    ushort RandomizationInterval;
    ushort MeasurementDuration;
    byte FrameRequestType;
    MacAddress Address;
    array<SubElementForFrameRequestPattern> SubElements;
}

pattern SubElementForFrameRequestPattern = [|RemainingBitLength(stream) >= 8|]
    ([|CurrentByte(stream) == 163|] WideBandwidthChannelSwitchElement |
    [|CurrentByte(stream) == 221|] VendorSpecificInformation);

// 802.11 - 2012 section 8.4.2.23.9 STA Statistics Request
type StaStatisticsRequest
{
    byte MeasurementType;
    MacAddress PeerAddress;
    ushort RandomizationInterval;
    ushort MeasurementDuration;
    byte GroupIdentity;
    array<VendorSpecificInformation> SubElements;
}

// 802.11 - 2012 section 8.4.2.23.10 Location Configuration Information Request
type LocationConfigurationInformationRequest
{
    byte MeasurementType;
    byte LocationSubject;
    byte LatitudeRequestedResolution;
    byte LongitudeRequestedResolution;
    byte AltitudeRequestedResolution;
    array<SubElementForLCIRequest> SubElements;
}

pattern SubElementForLCIRequest = [|stream.RemainingByteLength > 1|]
(
    [|stream.CurrentByte == 1|] AzimuthRequest |
    [|stream.CurrentByte == 221|] VendorSpecificInformation
);

type AzimuthRequest
{
    (byte where value == 1) SubElementID;
    (byte where value == 1) Length;
    byte AzimuthRequest;
}

// 802.11 - 2012 section 8.4.2.23.11 Transmit Stream/Category Measurement Request
type TransmitStreamCategoryMeasurementRequest
{
    byte MeasurementType;
    ushort RandomizationInterval;
    ushort MeasurementDuration;
    MacAddress PeerAddress;
    byte TrafficIdentifier;
    byte Range;
    array<SubElementForTSCMRequestPattern> SubElements;
}

pattern SubElementForTSCMRequestPattern = [|RemainingBitLength(stream) >= 8|]
    ([|CurrentByte(stream) == 1|] TriggeredReporting |
    [|CurrentByte(stream) == 221|] VendorSpecificInformation);

type TriggeredReporting
{
    byte SubElementID;
    byte Length;
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "TriggeredReporting", value) with BinaryEncoding{Width = 5};
    byte Delay            with BinaryEncoding{Width = 1};
    byte Consecutive      with BinaryEncoding{Width = 1};
    byte Average          with BinaryEncoding{Width = 1};
    byte AverageErrorThreshold;
    byte ConsecutiveErrorThreshold;
    byte DelayedMSDUCount with BinaryEncoding{Width = 6};
    byte DelayedMSDURange with BinaryEncoding{Width = 2};
    byte MeasurementCount;
    byte TriggerTimeout;
}

// 802.11 - 2012 section 8.4.2.23.12 Measurement pause request
type MeasurementPauseRequest
{
    byte MeasurementType;
    ushort PauseTime;
    array<VendorSpecificInformation> SubElements;
}

// 802.11 - 2012 section 8.4.2.23.13 Multicast Diagnostics Request
// Not Covered

// 802.11 - 2012 section 8.4.2.23.14 Location Civic Request
// Not Covered

// 802.11 - 2012 section 8.4.2.23.15 Location Identifier Request
// Not Covered

// 802.11 - 2012 section 8.4.2.24 Measurement Report element
type MeasurementReport
{
    (byte where value == 39) ElementID;
    byte Length;
    byte MeasurementToken;
    MeasurementReportMode MeasurementReportMode;
    optional [|MeasurementReportMode.Refused && MeasurementReportMode.Incapable && MeasurementReportMode.Late|] MeasurementReportPattern MeasurementReport;
}

type MeasurementReportForAction
{
    byte Category;
    byte Action;
    byte DialogToken;
    array<MeasurementReport> MeasurementReport;
}

pattern MeasurementReportPattern = [|RemainingBitLength(stream) >= 8|]
    ([|CurrentByte(stream) == 0|] BasicReport |
    [|CurrentByte(stream) == 1|] CCAReport |
    [|CurrentByte(stream) == 2|] RPIHistogramReport |
    [|CurrentByte(stream) == 3|] ChannelLoadReport |
    [|CurrentByte(stream) == 4|] NoiseHistogramReport |
    [|CurrentByte(stream) == 5|] BeaconReport |
    [|CurrentByte(stream) == 6|] FrameReport |
    [|CurrentByte(stream) == 7|] STAStatisticsReport |
    [|CurrentByte(stream) == 8|] LCIReport |
    [|CurrentByte(stream) == 9|] TransmitStreamCategoryMeasurementReport);
    
type MeasurementReportMode
{
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "MeasurementReportMode", value) with BinaryEncoding{Width = 5};
    bool Refused   with BinaryEncoding{Width = 1};
    bool Incapable with BinaryEncoding{Width = 1};
    bool Late      with BinaryEncoding{Width = 1};
}

// 802.11 - 2012 section 8.4.2.24.2 Basic report
type BasicReport
{
    (byte where value == 0) MeasurementType;
    byte ChannelNumber;
    ulong MeasurementStartTime;
    ushort MeasurementDuration;
    BasicReportMap Map;
}

type BasicReportMap
{
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "BasicReportMap", value) with BinaryEncoding{Width = 3};
    byte Unmeasured         with BinaryEncoding{Width = 1};
    byte Radar              with BinaryEncoding{Width = 1};
    byte UnidentifiedSignal with BinaryEncoding{Width = 1};
    byte OFDMPreamble       with BinaryEncoding{Width = 1};
    byte BSS                with BinaryEncoding{Width = 1};
}

// 802.11 - 2012 section 8.4.2.24.3 CCA report
type CCAReport
{
    (byte where value == 1) MeasurementType;
    byte ChannelNumber;
    ulong MeasurementStartTime;
    ushort MeasurementDuration;
    byte CCABusyFraction;
}

// 802.11 - 2012 section 8.4.2.24.4 RPI histogram report
type RPIHistogramReport
{
    (byte where value == 2) MeasurementType;
    byte ChannelNumber;
    ulong MeasurementStartTime;
    ushort MeasurementDuration;
    byte RPI0Density;
    byte RPI1Density;
    byte RPI2Density;
    byte RPI3Density;
    byte RPI4Density;
    byte RPI5Density;
    byte RPI6Density;
    byte RPI7Density;
}

// 802.11 - 2012 section 8.4.2.24.5 Channel Load Report
type ChannelLoadReport
{
    (byte where value == 3) MeasurementType;
    byte RegulatoryClass;
    byte ChannelNumber;
    ulong ActualMeasurementStartTime;
    ushort MeasurementDuration;
    byte ChannelLoad;
    array<SubElementForChannelLoadReportPattern> SubElements;
}

pattern SubElementForChannelLoadReportPattern = [|RemainingBitLength(stream) >= 8|]
    ([|CurrentByte(stream) == 163|] WideBandwidthChannelSwitchElement |
    [|CurrentByte(stream) == 221|] VendorSpecificInformation);

// 802.11 - 2012 section 8.4.2.24.6 Noise Histogram Report
type NoiseHistogramReport
{
    (byte where value == 4) MeasurementType;
    byte RegulatoryClass;
    byte ChannelNumber;
    ulong ActualMeasurementStartTime;
    ushort MeasurementDuration;
    byte AntennaID;
    byte ANPI;
    byte IPI0Density;
    byte IPI1Density;
    byte IPI2Density;
    byte IPI3Density;
    byte IPI4Density;
    byte IPI5Density;
    byte IPI6Density;
    byte IPI7Density;
    byte IPI8Density;
    byte IPI9Density;
    byte IPI10Density;
    array<SubElementForNoiseHistogramReportPattern> SubElements;
}

pattern SubElementForNoiseHistogramReportPattern = [|RemainingBitLength(stream) >= 8|]
    ([|CurrentByte(stream) == 163|] WideBandwidthChannelSwitchElement |
    [|CurrentByte(stream) == 221|] VendorSpecificInformation);

// 802.11 - 2012 section 8.4.2.24.7 Beacon Report
type BeaconReport
{
    (byte where value == 5) MeasurementType;
    byte RegulatoryClass;
    byte ChannelNumber;
    ulong ActualMeasurementStartTime;
    ushort MeasurementDuration;
    byte ReportedFrameType with BinaryEncoding{Width = 1};
    byte CondensedPHYType with BinaryEncoding{Width = 7};
    byte RCPI;
    byte RSNI;
    MacAddress BSSID;
    byte AntennaID;
    uint ParentTSF;
    array<SubElementForBeaconReportPattern> SubElements;
}

pattern SubElementForBeaconReportPattern = [|RemainingBitLength(stream) >= 8|]
    ([|CurrentByte(stream) == 1|] ReportedFrameBody |
    [|CurrentByte(stream) == 221|] VendorSpecificInformation);

type ReportedFrameBody
{
    (byte where value == 1) SubElementID;
    byte Length;
    binary Body with BinaryEncoding{Length = Length};
}

// 802.11 - 2012 section 8.4.2.24.8 Frame Report
type FrameReport
{
    (byte where value == 6) MeasurementType;
    byte RegulatoryClass;
    byte ChannelNumber;
    ulong ActualMeasurementStartTime;
    ushort MeasurementDuration;
    array<SubElementForFrameReportPattern> SubElements;
}

pattern SubElementForFrameReportPattern = [|RemainingBitLength(stream) >= 8|]
    ([|CurrentByte(stream) == 1|] FrameCountReport |
    [|CurrentByte(stream) == 163|] WideBandwidthChannelSwitchElement |
    [|CurrentByte(stream) == 221|] VendorSpecificInformation);

type FrameCountReport
{
    (byte where value == 1) SubElementID;
    (byte where value % 19 == 0) Length;
    array<FrameReportEntry> FrameReportEntries with BinaryEncoding{Length = (Length / 19)};
}

type FrameReportEntry
{
    MacAddress TransmitAddress;
    MacAddress BSSID;
    byte PHYType;
    byte AverageRCPI;
    byte LastRSNI;
    byte LastRCPI;
    byte AntennaID;
    ushort FrameCount;
}

// 802.11 - 2012 section 8.4.2.24.9 STA Statistics Report
type STAStatisticsReport
{
    (byte where value == 7) MeasurementType;
    ushort MeasurementDuration;
    byte GroupIdentity;
    ([|GroupIdentity == 0|] Dot11Counters | [|GroupIdentity == 1|] Dot11MACStatistics | [|GroupIdentity == 10|] Dot11BSSAverageAccessDelay
    | [|GroupIdentity in {2, 3, 4, 5, 6, 7, 8, 9}|] Dot11QosCounters) StatisticsGroupData;
    array<VendorSpecificInformation> SubElements;
}

type Dot11Counters
{
    uint Dot11TransmittedFragmentCount;
    uint Dot11MulticastTransmittedFrameCount;
    uint Dot11FailedCount;
    uint Dot11ReceivedFragmentCount;
    uint Dot11MulticastReceivedFrameCount;
    uint Dot11FCSErrorCount;
    uint Dot11TransmittedFrameCount;
}

type Dot11MACStatistics
{
    uint Dot11RetryCount;
    uint Dot11MultipleRetryCount;
    uint Dot11FrameDuplicateCount;
    uint Dot11RTSSuccessCount;
    uint Dot11RTSFailureCount;
    uint Dot11ACKFailureCount;
}

type Dot11QosCounters
{
    uint Dot11QosTransmittedFragmentCount;
    uint Dot11QosFailedCount;
    uint Dot11QosRetryCount;
    uint Dot11QosMultipleRetryCount;
    uint Dot11QosFrameDuplicateCount;
    uint Dot11QosRTSSuccessCount;
    uint Dot11QosRTSFailureCount;
    uint Dot11QosACKFailureCount;
    uint Dot11QosReceivedFragmentCount;
    uint Dot11QosTransmittedFrameCount;
    uint Dot11QosDiscardedFrameCount;
    uint Dot11QosMPDUsReceivedCount;
    uint Dot11QosRetriesReceivedCount;
}

type Dot11BSSAverageAccessDelay
{
    uint Dot11STAStatisticsAPAverageAccessDelay;
    uint Dot11STAStatisticsAverageAccessDelayBestEffort;
    uint Dot11STAStatisticsAverageAccessDelayBackGround;
    uint Dot11STAStatisticsAverageAccessDelayVideo;
    uint Dot11STAStatisticsAverageAccessDelayVoice;
    uint Dot11STAStatisticsStationCount;
    uint Dot11STAStatisticsChannelUtilization;
}

// 802.11 - 2012 section 8.4.2.24.10 Location Configuration Information Report
type LCIReport
{
    byte ElementID;
    byte Length;
    byte LatitudeFractionL     with BinaryEncoding{Width = 2};
    byte LatitudeResolution    with BinaryEncoding{Width = 6};
    ushort LatitudeFractionM;
    byte LatitudeIntegerL      with BinaryEncoding{Width = 1};
    byte LatitudeFractionH     with BinaryEncoding{Width = 7};
    byte LatitudeIntegerH;
    byte LongitudeFractionL    with BinaryEncoding{Width = 2};
    byte LongitudeResolution   with BinaryEncoding{Width = 6};
    ushort LongitudeFractionM;
    byte LongitudeIntegerL     with BinaryEncoding{Width = 1};
    byte LongitudeFractionH    with BinaryEncoding{Width = 7};
    byte LongitudeIntegerH;
    byte AltitudeResolutionL   with BinaryEncoding{Width = 4};
    byte AltitudeType          with BinaryEncoding{Width = 4};
    byte AltitudeFractionL     with BinaryEncoding{Width = 6};
    byte AltitudeResolutionH   with BinaryEncoding{Width = 2};
    byte AltitudeIntegerL      with BinaryEncoding{Width = 6};
    byte AltitudeFractionH     with BinaryEncoding{Width = 2};
    ushort AltitudeIntegerH;
    byte Datum;
    array<SubElementForLCIReport> SubElements;
}

pattern SubElementForLCIReport = [|stream.RemainingByteLength > 1|]
(
    [|stream.CurrentByte == 1|] AzimuthReport |
    [|stream.CurrentByte == 221|] VendorSpecificInformation
);

type AzimuthReport
{
    (byte where value == 1) SubElementID;
    (byte where value == 2) Length;
    byte AzimuthL          with BinaryEncoding{Width = 1};
    byte AzimuthResolution with BinaryEncoding{Width = 4};
    byte AzimuthType       with BinaryEncoding{Width = 1};
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "AzimuthReport", value) with BinaryEncoding{Width = 2};
    byte AzimuthH;
}

// 802.11 - 2012 section 8.4.2.24.11 Transmit Stream/Category Measurement Report
type TransmitStreamCategoryMeasurementReport
{
    (byte where value == 9) MeasurementType;
    ulong ActualMeasurementStartTime;
    ushort MeasurementDuration;
    MacAddress PeerAddress;
    byte Trafficidentifier;
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "TransmitStreamCategoryMeasurementReport", value) with BinaryEncoding{Width = 5};
    byte DelayTrigger       with BinaryEncoding{Width = 1};
    byte ConsecutiveTrigger with BinaryEncoding{Width = 1};
    byte AverageTrigger     with BinaryEncoding{Width = 1};
    uint TransmittedMSDUCount;
    uint MSDUDiscardedCount;
    uint MSDUFailedCount;
    uint MSDUMultipleRetryCount;
    uint QoSCFPollsLostCount;
    uint AverageQueueDelay;
    uint AverageTransmitDelay;
    byte Bin0Range;
    uint Bin0;
    uint Bin1;
    uint Bin2;
    uint Bin3;
    uint Bin4;
    uint Bin5;
    array<VendorSpecificInformation> SubElements;
}

// 802.11 - 2012 section 8.4.2.24.12 Multicast Diagnostics Report
// Not Covered

// 802.11 - 2012 section 8.4.2.25 Quiet element
type Quiet
{
    byte ElementID; // 40
    (byte where value == 6) Length;
    byte QuietCount;
    byte QuietPeriod;
    ushort QuietDuration;
    ushort QuietOffset;
}

// 802.11 - 2012 section 8.4.2.26 IBSS DFS element
type IBSSDFS
{
    byte ElementID; // 41
    byte Length;
    MacAddress DFSOwner;
    byte DfsRecoveryInterval;
    array<IBSSDFSChannelMap> ChannelMap with BinaryEncoding{Length = ((Length - 7) / 2)};
}

type IBSSDFSChannelMap
{
    byte ChannelNumber;
    byte Map;
}

// 802.11 - 2012 section 8.4.2.27 RSNE
type RSN
{
    (byte where value == 48) ElementID;
    byte Length;
    ushort Version;
    CipherSuite GroupCipherSuite;
    ushort PairwiseCipherSuiteCount;
    array<CipherSuite> PairwiseCipherSuiteList with BinaryEncoding{Length = PairwiseCipherSuiteCount};
    ushort AKMSuiteCount;
    array<AKMCipherSuite> AKMSuiteList with BinaryEncoding{Length = AKMSuiteCount};
    RSNCapabilities RSNCapabilities;
    optional [|(Length - 12 - (PairwiseCipherSuiteCount + AKMSuiteCount) * 4) > 0|] PMKIDs PMKIDs;
}

type PMKID
{
    array<byte> PMKID with BinaryEncoding{Length = 16};
}

type PMKIDs
{
    ushort PMKIDCount;
    array<PMKID> PMKID with BinaryEncoding{Length = PMKIDCount};
}

// 802.11 - 2012 section 8.4.2.27.2 Cipher suites
type CipherSuite
{
    binary OUI with BinaryEncoding{Length = 3};
    byte SuiteType;

    override string ToString()
    {
        if (OUI == CipherSuiteOUI)
        {
            return EnumToStringInSummary<CipherSuiteSuiteType>(SuiteType);
        }
        else
        {
            return "Other";
        }
    }
}

const binary CipherSuiteOUI = $[000FAC];
pattern CipherSuiteSuiteType = enum byte
{
    $"User group cipher suite" = 0,
    $"WEP-40" = 1,
    $"TKIP" = 2,
    $"CCMP-128" = 4,
    $"WEP-104" = 5,
    $"BIP-CMAC-128" = 6,
    $"Grouped addressed traffic not allowed" = 7,
    $"GCMP-128" = 8,
    $"GCMP-256" = 9,
    $"CCMP-256" = 10,
    $"BIP-GMAC-128" = 11,
    $"BIP-GMAC-256" = 12,
    $"BIP-CMAC-256" = 13,
    ...
};

// 802.11 - 2012 section 8.4.2.27.3 AKM suites
type AKMCipherSuite
{
    binary OUI with BinaryEncoding{Length = 3};
    byte SuiteType;
}

// 802.11 - 2012 section 8.4.2.27.4 RSN Capability
type RSNCapabilities
{
    bool MFPC               with BinaryEncoding{Width = 1};
    bool MFPR               with BinaryEncoding{Width = 1};
    byte GTKSAReplayCounter with BinaryEncoding{Width = 2};
    byte PTKSAReplayCounter with BinaryEncoding{Width = 2};
    bool NoParawise         with BinaryEncoding{Width = 1};
    bool PreAuth            with BinaryEncoding{Width = 1};
    byte Reserved2 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved2", "RSNCapabilities", value) with BinaryEncoding{Width = 3};
    bool PBAC               with BinaryEncoding{Width = 1};
    bool SPPAMSDURequired   with BinaryEncoding{Width = 1};
    bool SPPAMSDUEnabled    with BinaryEncoding{Width = 1};
    bool PeerKeyEnabled     with BinaryEncoding{Width = 1};
    byte Reserved1 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved1", "RSNCapabilities", value) with BinaryEncoding{Width = 1};
}

// 802.11 - 2012 section 8.4.2.28 Vendor Specific element
type VendorSpecificInformation
{
    (byte where value == 221) ElementID;
    byte Length;
    binary OUI with BinaryEncoding{Length = 3};
    (binary | any) VendorSpecificContent with BinaryEncoding{Length = (Length - 3)};
}

// 802.11 - 2012 section 8.4.2.29 Extended Capabilities element
type ExtendedCapabilities
{
    (byte where value == 127) ElementID;
    byte Length;
    array<ExtendedCapabilitiyPattern> ExtendedCapabilities with BinaryEncoding{Length = Length};
}

pattern ExtendedCapabilitiyPattern = enum byte
{
    BSSCoexistenceManagementSupport = 0,
    ExtendedChannelSwitching = 2,
    PSMPCapability = 4,
    S_PSMPSupport = 6,
    Event = 7,
    Diagnostic = 8,
    MulticastDiagnostics = 9,
    LocationTracking = 10,
    FMS = 11,
    ProxyARPService = 12,
    CollocatedInterferenceReporting = 13,
    CivicLocation = 14,
    GeospatialLocation = 15,
    TFS = 16,
    WNM_SleepMode = 17,
    TIMBroadcast = 18,
    BSSTransition = 19,
    QoSTrafficCapability = 20,
    ACStationCount = 21,
    MultipleBSSID = 22,
    TimingMeasurement = 23,
    ChannelUsage = 24,
    SSIDList = 25,
    DMS = 26,
    UTCTSFOffset = 27,
    TDLSPeerUAPSDBufferSTASupport = 28,
    TDLSPeerPSMSupport = 29,
    TDLSChannelSwitching = 30,
    Interworking = 31,
    QoSMap = 32,
    EBR = 33,
    SSPNInterface = 34,
    MSGCFCapability = 36,
    TDLSSupport = 37,
    TDLSProhibited = 38,
    TDLSChannelSwitchingProhibited = 39,
    RejectUnadmittedFrame = 40,
    // defined in 802.11ac-2013
    TDLSWiderBandwidth = 61,
    OperatingModeNotification = 62,
    MaxNumberOfMSDUsInAMSDU1 = 63,
    MaxNumberOfMSDUsInAMSDU2 = 64,
    ...
};

// 802.11 - 2012 section 8.4.2.30 BSS Load element
type BSSLoad
{
    byte ElementID;
    (byte where value == 5) Length;
    ushort STACount;
    byte ChannelUtilization;
    ushort AvailableAdmissionCapacit;
}

// 802.11 - 2012 section 8.4.2.31 EDCA Parameter Set element
type EDCAParameterSet
{
    (byte where value == 12) ElementID;
    (byte where value == 18) Length;
    (QoSInfoAP | QoSInfoNonAP) QoSInfo;
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "EDCAParameterSet", value);
    EDCAParameterRecord ACBEParameterRecord;
    EDCAParameterRecord ACBKParameterRecord;
    EDCAParameterRecord ACVIParameterRecord;
    EDCAParameterRecord ACVOParameterRecord;
}

type EDCAParameterRecord
{
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "EDCAParameterRecord", value) with BinaryEncoding{Width = 1};
    byte ACI       with BinaryEncoding{Width = 2};
    byte ACM       with BinaryEncoding{Width = 1};
    byte AIFSN     with BinaryEncoding{Width = 4};
    byte ECWmax    with BinaryEncoding{Width = 4};
    byte ECWMin    with BinaryEncoding{Width = 4};
    ushort TXOPLimit;
}

// 802.11 - 2012 section 8.4.2.32 TSPEC element
type TSPEC
{
    (byte where value == 13) ElementID;
    (byte where value == 55) Length;
    TSInfo TSInfo;
    ushort NominalMSDUSize;
    ushort MaximumMSDUSize;
    uint MinimumServiceInterval;
    uint MaximumServiceInterval;
    uint InactivityInterval;
    uint SuspensionInterval;
    uint ServiceStartTime;
    uint MinimumDataRate;
    uint MeanDataRate;
    uint PeakDataRate;
    uint BurstSize;
    uint DelayBound;
    uint MinimumPHYRate;
    ushort SurplusBandwidthAllowance;
    ushort MediumTime;
}

type TSInfo
{
    byte AccessPolicyL   with BinaryEncoding{Width = 1};
    byte Direction       with BinaryEncoding{Width = 2};
    byte TSID            with BinaryEncoding{Width = 4};
    byte TrafficType     with BinaryEncoding{Width = 1};
    byte TSInfoAckPolicy with BinaryEncoding{Width = 2};
    byte UserPriority    with BinaryEncoding{Width = 3};
    byte APSD            with BinaryEncoding{Width = 1};
    byte Aggregation     with BinaryEncoding{Width = 1};
    byte AccessPolicyH   with BinaryEncoding{Width = 1};
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "TSInfo", value) with BinaryEncoding{Width = 7};
    byte Schedule        with BinaryEncoding{Width = 1};
}

// 802.11 - 2012 section 8.4.2.33 TCLAS element
type TCLAS
{
    (byte where value == 14) ElementID;
    byte Length;
    byte UserPriority;
    (EthernetParameters | TCPUDPIPParametersIPv4 | TCPUDPIPParametersIPv6 | IEEE8021DQParameters) FrameClassifier;
}

type EthernetParameters
{
    (byte where value == 0) ClassifierType;
    byte ClassifierMask;
    MacAddress sourceaddress;
    MacAddress destinationaddress;
    ushort Type;
}

type TCPUDPIPParametersIPv4
{
    (byte where value == 1) ClassifierType;
    byte ClassifierMask;
    (byte where value == 4) Version;
    IPv4Address SourceIPAddress;
    IPv4Address DestinationIPAddress;
    ushort SourcePort;
    ushort DestinationPort;
    byte DSCP;
    byte Protocol;
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "TCPUDPIPParametersIPv4", value);
}

type TCPUDPIPParametersIPv6
{
    (byte where value == 1) ClassifierType;
    byte ClassifierMask;
    (byte where value == 6) Version;
    IPv6Address SourceIPAddress;
    IPv6Address DestinationIPAddress;
    ushort SourcePort;
    ushort DestinationPort;
    binary FlowLabel with BinaryEncoding{Length = 3};
}

type IEEE8021DQParameters
{
    (byte where value == 2) ClassifierType;
    byte ClassifierMask;
    ushort WiFi8021QTagType;
}

// 802.11 - 2012 section 8.4.2.34 TS Delay element
type TSDelay
{
    byte ElementID; // 43
    (byte where value == 4) Length;
    uint Delay;
}

// 802.11 - 2012 section 8.4.2.35 TCLAS Processing element
type TCLASProcessing
{
    (byte where value == 44) ElementID;
    (byte where value == 1) Length;
    byte Processing;
}

// 802.11 - 2012 section 8.4.2.36 Schedule element
type Schedule
{
    (byte where value == 15) ElementID;
    (byte where value == 12) Length;
    ScheduleInfo ScheduleInfo;
    uint ServiceStartTime;
    uint ServiceInterval;
    ushort SpecificationInterval;
}

type ScheduleInfo
{
    byte Reserved1 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved1", "ScheduleInfo", value) with BinaryEncoding{Width = 1};
    byte Direction   with BinaryEncoding{Width = 2};
    byte TSID        with BinaryEncoding{Width = 4};
    bool Aggregation with BinaryEncoding{Width = 1};
    byte Reserved2 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved2", "ScheduleInfo", value);
}

// 802.11 - 2012 section 8.4.2.37 QoS Capability element
type QoSCapability
{
    byte ElementID; // 46
    (byte where value == 1) Length;
    (QoSInfoAP | QoSInfoNonAP) QoSInfo;
}

type QoSInfoAP
{
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "QoSInfoAP", value) with BinaryEncoding{Width = 1};
    byte TXOPRequest                 with BinaryEncoding{Width = 1};
    byte QueueRequest                with BinaryEncoding{Width = 1};
    byte QAck                        with BinaryEncoding{Width = 1};
    byte EDCAParameterSetUpdateCount with BinaryEncoding{Width = 4};
}

type QoSInfoNonAP
{
    byte MoreDataAck    with BinaryEncoding{Width = 1};
    byte MaxSPLength    with BinaryEncoding{Width = 2};
    byte QAck           with BinaryEncoding{Width = 1};
    byte ACBEUAPSD      with BinaryEncoding{Width = 1};
    byte ACBKUAPSD      with BinaryEncoding{Width = 1};
    byte ACVIUAPSD      with BinaryEncoding{Width = 1};
    byte ACVOUAPSD      with BinaryEncoding{Width = 1};
}

// 802.11 - 2012 section 8.4.2.38 AP Channel Report element
type APChannelReport
{
    (byte where value == 51) ElementID;
    byte Length;
    byte RegulatoryClass;
    array<byte> ChannelNumber with BinaryEncoding{Length = (Length - 1)};
}

// 802.11 - 2012 section 8.4.2.39 Neighbor Report element
type NeighborReport
{
    (byte where value == 52) ElementID;
    byte Length;
    MacAddress BSSID;
    BSSIDInformation BSSIDInformation;
    byte RegulatoryClass;
    byte ChannelNumber;
    byte PHYType;
    array<SubElementForNeighborReportElementPattern> SubElements;
}

type BSSIDInformation
{
    byte RadioMeasurement   with BinaryEncoding{Width = 1};
    byte APSD               with BinaryEncoding{Width = 1};
    byte QoS                with BinaryEncoding{Width = 1};
    byte SpectrumManagement with BinaryEncoding{Width = 1};
    byte KeyScope           with BinaryEncoding{Width = 1};
    byte Security           with BinaryEncoding{Width = 1};
    byte APReachability     with BinaryEncoding{Width = 2};
    byte Reserved1 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved1", "BSSIDInformation", value) with BinaryEncoding{Width = 3};
    byte VeryHighThroughput with BinaryEncoding{Width = 1}; // very high throughput defined in 802.11ac
    byte HighThroughput     with BinaryEncoding{Width = 1};
    byte MobilityDomain     with BinaryEncoding{Width = 1};
    byte ImmediateBlockAck  with BinaryEncoding{Width = 1};
    byte DelayedBlockAck    with BinaryEncoding{Width = 1};
    ushort Reserved2 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved2", "BSSIDInformation", value);
}

pattern SubElementForNeighborReportElementPattern = [|RemainingBitLength(stream) >= 8|]
    ([|CurrentByte(stream) == 1|] TSFInformation |
    [|CurrentByte(stream) == 2|] CondensedCountryString |
    [|CurrentByte(stream) == 66|] MeasurementPilotTransmissionInformation |
    [|CurrentByte(stream) == 70|] RRMEnabledCapabilities |
    [|CurrentByte(stream) == 71|] MultipleBSSID |
    [|CurrentByte(stream) == 191|] VHTCapabilities |
    [|CurrentByte(stream) == 192|] VHTOperation |
    [|CurrentByte(stream) == 221|] VendorSpecificInformation);

type TSFInformation
{
    (byte where value == 1) SubElementID;
    (byte where value == 4) Length;
    ushort TFSOffset;
    ushort BeaconInterval;
}

type CondensedCountryString
{
    (byte where value == 2) SubElementID;
    (byte where value == 2) Length;
    ushort Dot11CountryString;
}

// 802.11 - 2012 section 8.4.2.40 RCPI element
type RCPI
{
    (byte where value == 53) ElementID;
    (byte where value == 1) Length;
    byte RCPI;
}

// 802.11 - 2012 section 8.4.2.41 BSS Average Access Delay element
type BSSAverageAccessDelay
{
    (byte where value == 63) ElementID;
    (byte where value == 1) Length;
    byte APAverageAccessDelay;
}

// 802.11 - 2012 section 8.4.2.42 Antenna element
type AntennaInformation
{
    (byte where value == 64) ElementID;
    (byte where value == 1) Length;
    byte AntennaID;
}

// 802.11 - 2012 section 8.4.2.43 RSNI element
type RSNI
{
    (byte where value == 65) ElementID;
    (byte where value == 1) Length;
    byte RSNI;
}

// 802.11 - 2012 section 8.4.2.44 Measurement Pilot Transmission element
type MeasurementPilotTransmissionInformation
{
    (byte where value == 66) ElementID;
    byte Length;
    byte MeasurementPilotTransmission;
    array<VendorSpecificInformation> SubElements;
}

// 802.11 - 2012 section 8.4.2.45 BSS Available Admission Capacity element
type BSSAvailableAdmissionCapacity
{
    (byte where value == 67) ElementID;
    byte Length;
    AvailableAdmissionCapacityBitmask AvailableAdmissionCapacityBitmask;
    binary AvailableAdmissionCapacityList with BinaryEncoding{Length = (Length - 2)};
}

type AvailableAdmissionCapacityBitmask
{
    byte UP;
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "AvailableAdmissionCapacityBitmask", value) with BinaryEncoding{Width = 4};
    byte AC       with BinaryEncoding{Width = 4};
}

// 802.11 - 2012 section 8.4.2.46 BSS AC Access Delay element
type BSSACAccessDelay
{
    (byte where value == 68) ElementID;
    (byte where value == 4) Length;
    byte ACBE;
    byte ACBK;
    byte ACVI;
    byte ACVO;
}

// 802.11 - 2012 section 8.4.2.47 RM Enabled Capabilities element
type RRMEnabledCapabilities
{
    (byte where value == 70) ElementID;
    (byte where value == 5) Length;
    RRMEnabledCapabilitiesField  RRMEnabledCapabilities;
}

type RRMEnabledCapabilitiesField
{
    byte BeaconMeasurementReportingConditions         with BinaryEncoding{Width = 1};
    byte BeaconTableMeasurement                       with BinaryEncoding{Width = 1};
    byte BeaconActiveMeasurement                      with BinaryEncoding{Width = 1};
    byte BeaconPassiveMeasurement                     with BinaryEncoding{Width = 1};
    byte RepeatedMeasurements                         with BinaryEncoding{Width = 1};
    byte ParallelMeasurements                         with BinaryEncoding{Width = 1};
    byte NeighborReport                               with BinaryEncoding{Width = 1};
    byte LinkMeasurement                              with BinaryEncoding{Width = 1};
    byte TriggeredTransmitStreamCategoryMeasurement   with BinaryEncoding{Width = 1};
    byte TransmitStreamCategoryMeasurement            with BinaryEncoding{Width = 1};
    byte LCIAzimuth                                   with BinaryEncoding{Width = 1};
    byte LCIMeasurement                               with BinaryEncoding{Width = 1};
    byte StatisticsMeasurement                        with BinaryEncoding{Width = 1};
    byte NoiseHistogramMeasurement                    with BinaryEncoding{Width = 1};
    byte ChannelLoadMeasurement                       with BinaryEncoding{Width = 1};
    byte FrameMeasurement                             with BinaryEncoding{Width = 1};
    byte NonOperatingChannelMaxMeasurementDuration    with BinaryEncoding{Width = 3};
    byte OperatingChannelMaxMeasurementDuration       with BinaryEncoding{Width = 3};
    byte RRMMIB                                       with BinaryEncoding{Width = 1};
    byte APChannelReport                              with BinaryEncoding{Width = 1};
    byte BSSAverageAccessDelay                        with BinaryEncoding{Width = 1};
    byte RSNIMeasurement                              with BinaryEncoding{Width = 1};
    byte RCPIMeasurement                              with BinaryEncoding{Width = 1};
    byte NeighborReportTSFOffset                      with BinaryEncoding{Width = 1};
    byte MeasurementPilotTransmissionInformation      with BinaryEncoding{Width = 1};
    byte MeasurementPilot                             with BinaryEncoding{Width = 3};
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "RRMEnabledCapabilitiesField", value) with BinaryEncoding{Width = 6};
    byte AntennaInformation                           with BinaryEncoding{Width = 1};
    byte BSSAvailableAdmissionCapacity                with BinaryEncoding{Width = 1};
}

// 802.11 - 2012 section 8.4.2.48 Multiple BSSID element
type MultipleBSSID
{
    (byte where value == 71) ElementID;
    byte Length;
    byte MaxBSSIDIndicator;
    optional array<VendorSpecificInformation> SubElements;
}

// 802.11 - 2012 section 8.4.2.49 Mobility Domain element (MDE)
type MobilityDomain
{
    (byte where value == 54) ElementID;
    (byte where value == 3) Length;
    ushort MDID;
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "MobilityDomain", value) with BinaryEncoding{Width = 6};
    byte ResourceRequestProtocolCapability with BinaryEncoding{Width = 1};
    byte FastBSSTransitionOverDS           with BinaryEncoding{Width = 1};
}

// 802.11 - 2012 section 8.4.2.50 Fast BSS Transition element (FTE)
type FastBSSTransition
{
    (byte where value == 55) ElementID;
    byte Length;
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "FastBSSTransition", value);
    byte InformationElementCount;
    binary MIC with BinaryEncoding{Length = 16};
    binary ANonce with BinaryEncoding{Length = 32};
    binary SNonce with BinaryEncoding{Length = 32};
    array<SubElementForFastBSSTransition> SubElements;
}

type SubElementForFastBSSTransition
{
    SubElementForFastBSSTransitionElementPattern Element;
}

pattern SubElementForFastBSSTransitionElementPattern = [|RemainingBitLength(stream) >= 8|]
    ([|CurrentByte(stream) == 1|] R1KHID |
    [|CurrentByte(stream) == 2|] GTK |
    [|CurrentByte(stream) == 3|] R0KHID |
    [|CurrentByte(stream) == 4|] IGTK);
    
type R1KHID
{
    (byte where value == 1) SubElementID;
    (byte where value == 6) Length;
    binary Data with BinaryEncoding{Length = Length};
}

type GTK
{
    (byte where value == 2) SubElementID;
    (byte where value >= 15 && value <= 42) Length;
    byte Reserved1 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved1", "GTK", value) with BinaryEncoding{Width = 6};
    byte KeyID     with BinaryEncoding{Width = 2};
    byte Reserved2 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved2", "GTK", value);
    byte keyLength;
    binary RSC with BinaryEncoding{Length = 8};
    binary Key with BinaryEncoding{Length = keyLength};
}

type R0KHID
{
    (byte where value == 3) SubElementID;
    (byte where value >= 1 && value <= 48) Length;
    binary Data with BinaryEncoding{Length = Length};
}

type IGTK
{
    (byte where value == 4) SubElementID;
    (byte where value == 35) Length;
    ushort KeyID;
    binary RSC with BinaryEncoding{Length = 6};
    byte keyLength;
    binary Key with BinaryEncoding{Length = keyLength};
}

// 802.11 - 2012 section 8.4.2.51 Timeout Interval element (TIE)
type TimeoutInterval
{
    (byte where value == 56) ElementID;
    (byte where value == 5) Length;
    byte TimeoutIntervalType;
    uint TimeoutIntervalValue;
}

// 802.11 - 2012 section 8.4.2.52 RIC Data element (RDE)
type RICData
{
    (byte where value == 57) ElementID;
    (byte where value == 4) Length;
    byte RDIEIdentifier;
    byte ResourceDescriptorCount;
    ushort Status;
}

// 802.11 - 2012 section 8.4.2.53 RIC Descriptor element
type RICDescriptor
{
    (byte where value == 75) ElementID;
    byte Length;
    byte ResourceType;
    binary Parameters with BinaryEncoding{Length = (Length - 1)};
}

// 802.11 - 2012 section 8.4.2.54 DSE Registered Location element
type DSERegisteredLocation
{
    (byte where value == 58) ElementID;
    (byte where value == 20) Length;
    DSERLBody Body;
}

type DSERLBody
{
    byte LatitudeFractionL     with BinaryEncoding{Width = 2};
    byte LatitudeResolution    with BinaryEncoding{Width = 6};
    ushort LatitudeFractionM;
    byte LatitudeIntegerL      with BinaryEncoding{Width = 1};
    byte LatitudeFractionH     with BinaryEncoding{Width = 7};
    byte LatitudeIntegerH;
    byte LongitudeFractionL    with BinaryEncoding{Width = 2};
    byte LongitudeResolution   with BinaryEncoding{Width = 6};
    ushort LongitudeFractionM;
    byte LongitudeIntegerL     with BinaryEncoding{Width = 1};
    byte LongitudeFractionH    with BinaryEncoding{Width = 7};
    byte LongitudeIntegerH;
    byte AltitudeResolutionL   with BinaryEncoding{Width = 4};
    byte AltitudeType          with BinaryEncoding{Width = 4};
    byte AltitudeFractionL     with BinaryEncoding{Width = 6};
    byte AltitudeResolutionH   with BinaryEncoding{Width = 2};
    byte AltitudeIntegerL      with BinaryEncoding{Width = 6};
    byte AltitudeFractionH     with BinaryEncoding{Width = 2};
    ushort AltitudeIntegerH;
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "DSERLBody", value) with BinaryEncoding{Width = 2};
    byte DependentSTA          with BinaryEncoding{Width = 1};
    byte RegLocDSE             with BinaryEncoding{Width = 1};
    byte RegLocAgreement       with BinaryEncoding{Width = 1};
    byte Datum                 with BinaryEncoding{Width = 3};
    ushort DependentEnablementIdentifier;
    byte RegulatoryClass;
    byte ChannelNumber;
}

// 802.11 - 2012 section 8.4.2.55 Extended Channel Switch Announcement element
type ExtendedChannelSwitchAnnouncement
{
    (byte where value == 60) ElementID;
    (byte where value == 4) Length;
    byte ChannelSwitchMode;
    byte NewRegulatoryClass;
    byte NewChannelNumber;
    byte ChannelSwitchCount;
}

// 802.11 - 2012 section 8.4.2.56 Supported Operating Classes element
type SupportedOperatingClasses
{
    (byte where value == 59) ElementID;
    byte Length;
    byte CurrentOperatingClass;
    // According to 802.11ac, Operating Classes is terminated by 130 Delimiter or 0 Delimiter or end of element
    array<ByteInOperatingClasses> OperatingClasses with BinaryEncoding{MaxLength = (Length - 1)};
    optional [|Length - 1 > OperatingClasses.Count|] byte Delimiter;
    optional [|Delimiter is 130|] binary CurrentOperatingClassExtensionSequence with BinaryEncoding{Length = (Length - 2 - OperatingClasses.Count)};
    optional [|Delimiter is 0|] binary OperatingClassDupleSequence  with BinaryEncoding{Length = (Length - 2 - OperatingClasses.Count)};
}

pattern ByteInOperatingClasses = byte where value != 130 && value != 0;

// 802.11 - 2012 section 8.4.2.57 Management MIC element
type ManagementMicInformation
{
    (byte where value == 76) ElementID;
    (byte where value == 16 || value == 24) Length;
    ushort KeyID;
    binary IPN with BinaryEncoding{Length = 6};
    binary MIC with BinaryEncoding{Length = (Length - 8)}; // 802.11ac-2013 defines the length can be 8 or 16
}

// 802.11 - 2012 section 8.4.2.58 HT Capabilities element
type HTCapabilities
{
    (byte where value == 45) ElementID;
    (byte where value == 26) Length;
    HTCapabilitiesInfo HTCapabilitiesInfo;
    AMPDUParameters AMPDUParameters;
    MCSSet SupportedMCSSet;
    HTExtendedCapabilities HTExtendedCapabilities;
    TransmitBeamformingCapabilities TransmitBeamformingCapabilities;
    ASELCapabilities ASELCapabilities;
}

type HTCapabilitiesInfo
{
    bool TxSTBC                     with BinaryEncoding{Width = 1};
    bool ShortGIfor40MHz            with BinaryEncoding{Width = 1};
    bool ShortGIfor20MHz            with BinaryEncoding{Width = 1};
    bool HTGreenfield               with BinaryEncoding{Width = 1};
    byte SMPowerSave                with BinaryEncoding{Width = 2};
    byte SupportedChannelWidthSet   with BinaryEncoding{Width = 1};
    byte LDPCCodingCapability       with BinaryEncoding{Width = 1};
    byte LSIGTXOPProtectionSupport  with BinaryEncoding{Width = 1};
    byte FortyMHzIntolerant         with BinaryEncoding{Width = 1};
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "HTCapabilitiesInfo", value) with BinaryEncoding{Width = 1};
    byte DSSSCCKModein40MHz         with BinaryEncoding{Width = 1};
    byte MaximumAMSDULength         with BinaryEncoding{Width = 1};
    byte HTDelayedBlockAck          with BinaryEncoding{Width = 1};
    byte RxSTBC                     with BinaryEncoding{Width = 2};
}

type AMPDUParameters
{
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "AMPDUParameters", value) with BinaryEncoding{Width = 3};
    byte MinimumMPDUStartSpacing    with BinaryEncoding{Width = 3};
    byte MaximumAMPDULengthExponet  with BinaryEncoding{Width = 2};
}

type HTExtendedCapabilities
{
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "HTExtendedCapabilities", value) with BinaryEncoding{Width = 5};
    byte PCOTransitionTime  with BinaryEncoding{Width = 2};
    byte PCO                with BinaryEncoding{Width = 1};
    byte Reserved1 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved1", "HTExtendedCapabilities", value) with BinaryEncoding{Width = 4};
    byte RDResponder        with BinaryEncoding{Width = 1};
    byte HTCSupport         with BinaryEncoding{Width = 1};
    byte MCSFeedback        with BinaryEncoding{Width = 2};
}

type TransmitBeamformingCapabilities
{
    byte Calibration                                                with BinaryEncoding{Width = 2};
    byte ImplicitTransmitBeamformingCapable                         with BinaryEncoding{Width = 1};
    byte TransmitNDPCapable                                         with BinaryEncoding{Width = 1};
    byte ReceiveNDPCapable                                          with BinaryEncoding{Width = 1};
    byte TransmitStaggeredSoundingCapable                           with BinaryEncoding{Width = 1};
    byte ReceiveStaggeredSoundingCapable                            with BinaryEncoding{Width = 1};
    byte ImplicitTransmitBeamformingReceivingCapable                with BinaryEncoding{Width = 1};
    byte ExplicitCompressedBeamformingFeedbackCapableL              with BinaryEncoding{Width = 1};
    byte ExplicitNoncompressedBeamformingFeedbackCapable            with BinaryEncoding{Width = 2};
    byte ExplicitTransmitBeamformingCSIFeedback                     with BinaryEncoding{Width = 2};
    byte ExplicitCompressedSteeringCapable                          with BinaryEncoding{Width = 1};
    byte ExplicitNoncompressedSteeringCapable                       with BinaryEncoding{Width = 1};
    byte ExplicitCSITransmitBeamformingCapable                      with BinaryEncoding{Width = 1};
    byte CompressedSteeringNumberofBeamformerAntennasSupportedL     with BinaryEncoding{Width = 1};
    byte NoncompressedSteeringNumberofBeamformerAntennasSupported   with BinaryEncoding{Width = 2};
    byte CSINumberofBeamformerAntennasSupported                     with BinaryEncoding{Width = 2};
    byte MinimalGrouping                                            with BinaryEncoding{Width = 2};
    byte ExplicitCompressedBeamformingFeedbackCapableH              with BinaryEncoding{Width = 1};
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "TransmitBeamformingCapabilities", value) with BinaryEncoding{Width = 3};
    byte ChannelEstimationCapability                                with BinaryEncoding{Width = 2};
    byte CSIMaxNumberofRowsBeamformerSupported                      with BinaryEncoding{Width = 2};
    byte CompressedSteeringNumberofBeamformerAntennasSupportedH     with BinaryEncoding{Width = 1};
}

pattern ASELCapabilities = flags byte
{
    AntennaSelectionCapable                        = 0x01,
    ExplicitCSIFeedbackBasedTransmitASELCapable    = 0x02,
    AntennaIndicesFeedbackBasedTransmitASELCapable = 0x04,
    ExplicitCSIFeedbackCapable                     = 0x08,
    AntennaIndicesFeedbackCapable                  = 0x10,
    ReceiveASELCapable                             = 0x20,
    TransmitSoundingPPDUsCapable                   = 0x40,
    ...
};

type MCSSet
{
    binary RxMCSBitmask with BinaryEncoding{Length = 10};
    byte RxHighestSupportedDataRateL;
    byte Reserved1 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved1", "MCSSet", value) with BinaryEncoding{Width = 6};
    byte RxHighestSupportedDataRateH           with BinaryEncoding{Width = 2};
    byte Reserved2 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved2", "MCSSet", value) with BinaryEncoding{Width = 3};
    byte TxUnequalModulationSupported           with BinaryEncoding{Width = 1};
    byte TxMaximumNumberSpatialStreamsSupported with BinaryEncoding{Width = 2};
    byte TxRxMCSSetNotEqual                     with BinaryEncoding{Width = 1};
    byte TxMCSSetDefined                        with BinaryEncoding{Width = 1};
    uint Reserved3 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved3", "MCSSet", value) with BinaryEncoding{Width = 24};
}

type Reserved
{
    (byte where value == 47) ElementID;
    byte Length;
    binary Data with BinaryEncoding{Length = Length};
}

// 802.11 - 2012 section 8.4.2.59 HT Operation element
type HTOperation
{
    (byte where value == 61) ElementID;
    (byte where value == 22) Length;
    byte PrimaryChannel;
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "HTOperation", value) with BinaryEncoding{Width = 4};
    byte RIFSMode                       with BinaryEncoding{Width = 1};
    byte STAChannelWidth                with BinaryEncoding{Width = 1};
    byte SecondaryChannelOffset         with BinaryEncoding{Width = 2};
    
    byte Reserved1 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved1", "HTOperation", value) with BinaryEncoding{Width = 3};
    byte OBSSNonHTSTAsPresent           with BinaryEncoding{Width = 1};
    byte Reserved2 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved2", "HTOperation", value) with BinaryEncoding{Width = 1};
    byte NongreenfieldHTSTAsPresent     with BinaryEncoding{Width = 1};
    byte HTProtection                   with BinaryEncoding{Width = 2};
    byte Reserved3 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved3", "HTOperation", value);
    
    byte DualCTSProtection              with BinaryEncoding{Width = 1};
    byte DualBeacon                     with BinaryEncoding{Width = 1};
    byte Reserved4 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved4", "HTOperation", value) with BinaryEncoding{Width = 6};
    
    byte Reserved5 where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved5", "HTOperation", value) with BinaryEncoding{Width = 4};
    byte PCOPhase                       with BinaryEncoding{Width = 1};
    byte PCOActive                      with BinaryEncoding{Width = 1};
    byte LSIGTXOPProtectionFullSupport  with BinaryEncoding{Width = 1};
    byte STBCBeacon                     with BinaryEncoding{Width = 1};
    MCSSet BasicMCSSet;
}

// 802.11 - 2012 section 8.4.2.60 20/40 BSS Intolerant Channel Report element
type WiFi20and40BSSIntolerantChannelReport
{
    (byte where value == 73) ElementID;
    byte Length;
    byte RegulatoryClass;
    array<byte> ChannelList with BinaryEncoding{Length = (Length - 1)};
}

// 802.11 - 2012 section 8.4.2.61 Overlapping BSS Scan Parameters element
type OverlappingBSSScanParameters
{
    byte ElementID; // 74
    (byte where value == 14) Length;
    ushort OBSSScanPassiveDwell;
    ushort OBSSScanActiveDwell;
    ushort BSSChannelWidthTriggerScanInterval;
    ushort OBSSScanPassiveTotalPerChannel;
    ushort OBSSScanActiveTotalPerChannel;
    ushort BSSWidthChannelTransitionDelayFactor;
    ushort OBSSScanActivityThreshold;
}

// 802.11 - 2012 section 8.4.2.62 20/40 BSS Coexistence element
type WiFi20or40BSSCoexistence
{
    (byte where value == 72) ElementID;
    (byte where value == 1) Length;
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "WiFi20or40BSSCoexistence", value) with BinaryEncoding{Width = 3};
    bool OBSSScanningExemptionGrant     with BinaryEncoding{Width = 1};
    bool OBSSScanningExemptionRequest   with BinaryEncoding{Width = 1};
    bool TwentyMHzBSSWidthRequest       with BinaryEncoding{Width = 1};
    bool FortyMHzIntolerant             with BinaryEncoding{Width = 1};
    bool InformationRequest             with BinaryEncoding{Width = 1};
}

// 802.11 - 2012 section 8.4.2.63 Time Advertisement element
// Not Covered

// 802.11 - 2012 section 8.4.2.64 Link Identifier element
// Not Covered

// 802.11 - 2012 section 8.4.2.65 Wakeup Schedule element
// Not Covered

// 802.11 - 2012 section 8.4.2.66 Channel Switch Timing element
// Not Covered

// 802.11 - 2012 section 8.4.2.67 PTI Control element
// Not Covered

// 802.11 - 2012 section 8.4.2.68 TPU Buffer Status element
// Not Covered

// 802.11 - 2012 section 8.4.2.69 Event Request element
// Not Covered

// 802.11 - 2012 section 8.4.2.70 Event Report element
// Not Covered

// 802.11 - 2012 section 8.4.2.71 Diagnostic Request element
// Not Covered

// 802.11 - 2012 section 8.4.2.72 Diagnostic Report element
// Not Covered

// 802.11 - 2012 section 8.4.2.73 Location Parameters element
// Not Covered

// 802.11 - 2012 section 8.4.2.74 Nontransmitted BSSID Capability element
// Not Covered

// 802.11 - 2012 section 8.4.2.75 SSID List element
// Not Covered

// 802.11 - 2012 section 8.4.2.76 Multiple BSSID-Index element
// Not Covered

// 802.11 - 2012 section 8.4.2.77 FMS Descriptor element
// Not Covered

// 802.11 - 2012 section 8.4.2.78 FMS Request element
// Not Covered

// 802.11 - 2012 section 8.4.2.79 FMS Response element
// Not Covered

// 802.11 - 2012 section 8.4.2.80 QoS Traffic Capability element
// Not Covered

// 802.11 - 2012 section 8.4.2.81 BSS Max Idle Period element
// Not Covered

// 802.11 - 2012 section 8.4.2.82 TFS Request element
// Not Covered

// 802.11 - 2012 section 8.4.2.83 TFS Response element
// Not Covered

// 802.11 - 2012 section 8.4.2.84 WNM-Sleep Mode element
// Not Covered

// 802.11 - 2012 section 8.4.2.85 TIM Broadcast Request element
// Not Covered

// 802.11 - 2012 section 8.4.2.86 TIM Broadcast Response element
// Not Covered

// 802.11 - 2012 section 8.4.2.87 Collocated Interference Report element
// Not Covered

// 802.11 - 2012 section 8.4.2.88 Channel Usage element
// Not Covered

// 802.11 - 2012 section 8.4.2.89 Time Zone element
// Not Covered

// 802.11 - 2012 section 8.4.2.90 DMS Request element
// Not Covered

// 802.11 - 2012 section 8.4.2.91 DMS Response element
// Not Covered

// 802.11 - 2012 section 8.4.2.92 Destination URI element
// Not Covered

// 802.11 - 2012 section 8.4.2.93 U-APSD Coexistence element
// Not Covered

// 802.11 - 2012 section 8.4.2.94 Interworking element
type InterworkingInformation
{
    (byte where value == 107) ElementId;
    byte Length;
    AccessNetworkOptions AccessNetworkOptions;
    optional [|(Length == 3 || Length == 9)|] VenueInfo VenueInfo;
    optional [|(Length == 7 || Length == 9)|] MacAddress HESSID;
}

type AccessNetworkOptions
{
    bool UESA with BinaryEncoding{Width = 1};
    bool ESR with BinaryEncoding{Width = 1};
    bool ASRA with BinaryEncoding{Width = 1};
    bool Internet with BinaryEncoding{Width = 1};
    AccessNetworkType AccessNetworkType with BinaryEncoding{Width = 4};
}

pattern AccessNetworkType = enum byte
{
    PrivateNetwork = 0,
    PrivateNetworkWithGuestAccess = 1,
    ChargeablePublicNetwork = 2,
    FreePublicNetwork = 3,
    PersonalDevice = 4,
    EmergencyServicesOnlyNetwork = 5,
    TestOrExperimental = 14,
    Wildcard = 15,
    ...
} with BinaryEncoding{Width = 4};

// 802.11 - 2012 section 8.4.2.95 Advertisement Protocol element
type AdvertisementProtocol
{
    (byte where value == 108) ElementId;
    byte Length;
    array<AdvertisementProtocolTuple> AdvertisementProtocolTuple with BinaryEncoding{WidthForComposedType = Length * 8};
}

type AdvertisementProtocolTuple
{
    QueryResponseInfo QueryResponseInfo;
    AdvertisementProtocolIdPattern AdvertisementProtocolId  with DisplayInfo{ToText = IdToText};
    
    static string IdToText(any data)
    {
        if (data is id:AdvertisementProtocolId)
        {
            return EnumToString(id, "WiFi.AdvertisementProtocolId");
        }
        else
        {
            return "Vendor Specific";
        }
    }
}

pattern AdvertisementProtocolIdPattern = [|RemainingBitLength(stream) >= 8|]
    ([|CurrentByte(stream) != 221|] AdvertisementProtocolId |
    [|CurrentByte(stream) == 221|] VendorSpecificInformation);
    
pattern AdvertisementProtocolId = enum byte
{
    $"Access Network Query Protocol (ANQP)" = 0,
    $"MIH Information Service" = 1,
    $"MIH Command and Event Services Capability Discovery" = 2,
    $"Emergency Alert System (EAS)" = 3,
    $"Vendor Specific" = 221,
    ...
};

type QueryResponseInfo
{
    bool PameBi with BinaryEncoding{Width = 1};
    byte QueryResponseLengthLimit with BinaryEncoding{Width = 7};
}

// 802.11 - 2012 section 8.4.2.96 Expedited Bandwidth Request element
type ExpeditedBandwidthRequestInformation
{
    (byte where value == 109) ElementId;
    byte Length;
    PrecedenceLevel PrecedenceLevel;
}

pattern PrecedenceLevel = enum byte
{
    $"Emergency call, defined in NENA 08-002 [B51]" = 16,
    $"First responder (public)" = 17,
    $"First responder (private)" = 18,
    $"MLPP Level A" = 19,
    $"MLPP Level B" = 20,
    $"MLPP Level 0" = 21,
    $"MLPP Level 1" = 22,
    $"MLPP Level 2" = 23,
    $"MLPP Level 3" = 24,
    $"MLPP Level 4" = 25,
    ...
};

// 802.11 - 2012 section 8.4.2.97 QoS Map Set element
type QosMapSetinformation
{
    (byte where value == 110) ElementId;
    byte Length;
    optional [|(Length - 16) / 2 > 0|] array<DscpException> DscpException with BinaryEncoding{Length = (Length - 16) / 2};
    array<DscpRange> DscpRange  with BinaryEncoding{Length = 8};
}

type DscpException
{
    byte DscpValue;
    byte UserPriority;
}

type DscpRange
{
    byte DscpLowValue;
    byte DscpHighValue;
}

// 802.11 - 2012 section 8.4.2.98 Roaming Consortium element
type RoamingConsortiumInformation
{
    (byte where value == 111) ElementId;
    byte Length;
    byte NumberOfAnqpOis;
    byte Oi2Length with BinaryEncoding{Width = 4};
    byte Oi1Length with BinaryEncoding{Width = 4};
    binary OI1 with BinaryEncoding{Length = Oi1Length};
    optional [|Oi2Length > 0|] binary OI2 with BinaryEncoding{Length = Oi2Length};
    optional [|Length - 2 - (Oi2Length + Oi1Length) > 0|] binary OI3 with BinaryEncoding{Length = Length - 2 - (Oi2Length + Oi1Length)};
}

// 802.11 - 2012 section 8.4.2.99 Emergency Alert Identifier element
type EmergencyAlertIdentifierInformation
{
    (byte where value == 112) ElementId;
    byte Length;
    binary AlertIdentifierHash with BinaryEncoding{Length = 8};
}

// 802.11 - 2012 section 8.4.2.100 Mesh Configuration element
// Not Covered

// 802.11 - 2012 section 8.4.2.101 Mesh ID element
// Not Covered

// 802.11 - 2012 section 8.4.2.102 Mesh Link Metric Report element
// Not Covered

// 802.11 - 2012 section 8.4.2.103 Congestion Notification element
// Not Covered

// 802.11 - 2012 section 8.4.2.104 Mesh Peering Management element
// Not Covered

// 802.11 - 2012 section 8.4.2.105 Mesh Channel Switch Parameters element
type MeshChannelSwitchParameters // 118
{
    byte ElementID;
    byte Length;
    byte TimeToLive;
    MeshChannelSwitchParametersFlags Flags;
    ushort ReasonCode;
    ushort PrecedenceValue;
}

pattern MeshChannelSwitchParametersFlags = flags byte
{
    TransmitRestrict = 0x80,
    Initiator = 0x40,
    Reason = 0x20,
    ...
};

// 802.11 - 2012 section 8.4.2.106 Mesh Awake Window element
// Not Covered

// 802.11 - 2012 section 8.4.2.107 Beacon Timing element
// Not Covered

// 802.11 - 2012 section 8.4.2.108 MCCAOP Setup Request element
// Not Covered

// 802.11 - 2012 section 8.4.2.109 MCCAOP Setup Reply element
// Not Covered

// 802.11 - 2012 section 8.4.2.110 MCCAOP Advertisement Overview element
// Not Covered

// 802.11 - 2012 section 8.4.2.111 MCCAOP Advertisement element
// Not Covered

// 802.11 - 2012 section 8.4.2.112 MCCAOP Teardown element
// Not Covered

// 802.11 - 2012 section 8.4.2.113 GANN element
// Not Covered

// 802.11 - 2012 section 8.4.2.114 RANN element
// Not Covered

// 802.11 - 2012 section 8.4.2.115 PREQ element
// Not Covered

// 802.11 - 2012 section 8.4.2.116 PREP element
// Not Covered

// 802.11 - 2012 section 8.4.2.117 PERR element
// Not Covered

// 802.11 - 2012 section 8.4.2.118 PXU element
// Not Covered

// 802.11 - 2012 section 8.4.2.119 PXUC element
// Not Covered

// 802.11 - 2012 section 8.4.2.120 Authenticated Mesh Peering Exchange element
// Not Covered

// 802.11 - 2012 section 8.4.2.121 MIC element
// Not Covered

// 802.11ac - 2013 section 8.4.2.160 VHT Capabilities element
type VHTCapabilities
{
    byte ElementID;
    byte Length;
    VHDCapabilityInfoField VHDCapabilityInfo;
    SupportedVHTMCSAndNSSSetField SupportedVHTMCSAndNSSSet;
}

// 802.11ac - 2013 section 8.4.2.160.2 VHT Capabilities Info field
type VHDCapabilityInfoField
{
    byte Reserved                       with BinaryEncoding{Width = 2};
    bool TxAntennaPatternConsistency    with BinaryEncoding{Width = 1};
    bool RxAntennaPatternConsistency    with BinaryEncoding{Width = 1};
    byte VHTLinkAdaptationCapable       with BinaryEncoding{Width = 2}, DisplayInfo{ToText = VHTLinkAdaptationCapableToString};
    byte MaximumAMPDULengthExponent     with BinaryEncoding{Width = 3}, DisplayInfo{ToText = MaximumAMPDULengthExponentToString};
    bool HTC_VHTCapable                 with BinaryEncoding{Width = 1};
    bool VHT_TXOP_PS                    with BinaryEncoding{Width = 1};
    bool MUBeamformeeCapable            with BinaryEncoding{Width = 1};
    bool MUBeamformerCapable            with BinaryEncoding{Width = 1};
    byte NumberOfSoudingDimensions      with BinaryEncoding{Width = 3}, DisplayInfo{ToText = NumberOfSoudingDimensionsToString};
    byte BeamformeeSTSCapability        with BinaryEncoding{Width = 3}, DisplayInfo{ToText = BeamformeeSTSCapabilityToString};
    bool SUBeamformeeCapable            with BinaryEncoding{Width = 1};
    bool SUBeamformerCapable            with BinaryEncoding{Width = 1};
    byte RxSTBC                         with BinaryEncoding{Width = 3}, DisplayInfo{ToText = RxSTBCToString};
    bool TxSTBC                         with BinaryEncoding{Width = 1};
    bool ShortGIFor160                  with BinaryEncoding{Width = 1};
    bool ShortGIFor80                   with BinaryEncoding{Width = 1};
    bool RxLDPC                         with BinaryEncoding{Width = 1};
    byte SupportedChannelWidthSet       with BinaryEncoding{Width = 2}, DisplayInfo{ToText = SupportedChannelWidthSetToString};
    byte MaximumMPDULength              with BinaryEncoding{Width = 2}, DisplayInfo{ToText = MaximumMPDULengthToString};

    string MaximumMPDULengthToString(any input)
    {
        switch (input as byte)
        {
            case 0 => return "3895 octets";
            case 1 => return "7991 octets";
            case 2 => return "11454 octets";
            default => return "Reserved";
        }
    }

    string SupportedChannelWidthSetToString(any input)
    {
        switch (input as byte)
        {
            case 0 => return "Not support either 160 or 80+80 MHz";
            case 1 => return "Support 160 MHz";
            case 2 => return "Support 160 MHz and 80+80 MHz";
            default => return "Reserved";
        }
    }

    string RxSTBCToString(any input)
    {
        switch (input as byte)
        {
            case 0 => return "Not support";
            case 1 => return "Support one spatial stream";
            case 2 => return "Support one and two spatial streams";
            case 3 => return "Support one, two and three spatial streams";
            case 4 => return "Support one, two, three and four spatial streams";
            default => return "Reserved";
        }
    }

    string BeamformeeSTSCapabilityToString(any input)
    {
        if (SUBeamformeeCapable)
        {
            return ((input as byte) + 1).ToString();
        }
        else
            return "Reserved";
    }

    string NumberOfSoudingDimensionsToString(any input)
    {
        if (SUBeamformeeCapable)
        {
            return ((input as byte) + 1).ToString();
        }
        else
            return "Reserved";
    }

    string MaximumAMPDULengthExponentToString(any input)
    {
        return (1 << (13 + (input as byte))).ToString();
    }

    string VHTLinkAdaptationCapableToString(any input)
    {
        if (HTC_VHTCapable)
        {
            switch (input as byte)
            {
                case 0 => return "Not provide VHT MFB";
                case 1 => return "Provide unsolicited VHT MFB";
                case 2 => return "Provide unsolicited and response VHT MFB";
                default => return "Reserved";
            }
        }
        else
        {
            return "Reserved";
        }
    }
} with BinaryEncoding{WidthForComposedType = 32, DecodeAsUnit = true};

// 802.11ac - 2013 section 8.4.2.160.3 Supported VHT-MCS and NSS Set field
type SupportedVHTMCSAndNSSSetField
{
    VHTMCSMap RxVHTMCSMap;
    ushort RxHighestSupportedLongGIDataRate;
    VHTMCSMap TxVHTMCSMap;
    ushort TxHighestSupportedLongGIDataRate;
}

type VHTMCSMap
{
    byte MaxVHTMCSFor8SS with BinaryEncoding{Width = 2}, DisplayInfo{ToText = MaxVHTMCSToString};
    byte MaxVHTMCSFor7SS with BinaryEncoding{Width = 2}, DisplayInfo{ToText = MaxVHTMCSToString};
    byte MaxVHTMCSFor6SS with BinaryEncoding{Width = 2}, DisplayInfo{ToText = MaxVHTMCSToString};
    byte MaxVHTMCSFor5SS with BinaryEncoding{Width = 2}, DisplayInfo{ToText = MaxVHTMCSToString};
    byte MaxVHTMCSFor4SS with BinaryEncoding{Width = 2}, DisplayInfo{ToText = MaxVHTMCSToString};
    byte MaxVHTMCSFor3SS with BinaryEncoding{Width = 2}, DisplayInfo{ToText = MaxVHTMCSToString};
    byte MaxVHTMCSFor2SS with BinaryEncoding{Width = 2}, DisplayInfo{ToText = MaxVHTMCSToString};
    byte MaxVHTMCSFor1SS with BinaryEncoding{Width = 2}, DisplayInfo{ToText = MaxVHTMCSToString};

    string MaxVHTMCSToString(any input)
    {
        switch (input as byte)
        {
            case 0 => return "VHT-MCS 0-7";
            case 1 => return "VHT-MCS 0-8";
            case 2 => return "VHT-MCS 0-9";
            default => return "Not Supported";
        }
    }
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 802.11ac - 2013 section 8.4.2.161 Wide Bandwidth Channel Switch element
type VHTOperation
{
    byte ElementID;
    byte Length;
    VHTOperationInformation VHTOperationInformation;
    VHTMCSMap BasicVHTMCSAndNSSSet;
}

type VHTOperationInformation
{
    byte ChannelWidth with DisplayInfo{ToText = ChannelWidthToString};
    byte ChannelCenterFrequencySegment0;
    byte ChannelCenterFrequencySegment1;

    string ChannelWidthToString(any input)
    {
        switch (input as byte)
        {
            case 0 => return "20 MHz or 40 MHz operating channel width";
            case 1 => return "Support 80 MHz";
            case 2 => return "Support 160 MHz";
            case 3 => return "Support 80+80 MHz";
            default => return "Reserved";
        }
    }
}

// 802.11ac - 2013 section 8.4.2.162 Extended BSS Load element
type ExtendedBSSLoad
{
    byte ElementID;
    byte Length;
    ushort MUMIMOCapcableSTACount;
    byte SpatialStreamUnderutilization;
    byte ObservableSecondary20MHzUtilization;
    byte ObservableSecondary40MHzUtilization;
    byte ObservableSecondary80MHzUtilization;
}

// 802.11ac - 2013 section 8.4.2.163 Wide Bandwidth Channel Switch element
type WideBandwidthChannelSwitchElement
{
    byte ElementID;
    byte Length;
    byte NewChannelWidth;
    byte NewChannelCenterFrequencySegment0;
    byte NewChannelCenterFrequencySegment1;
}

// 802.11ac - 2013 section 8.4.2.164 VHT Transmit Power Envelope element
type VHTTransmitPowerEnvelope
{
    byte ElementID;
    byte Length;
    TransmitPowerInformation TransmitPowerInformation;
    byte LocalMaximumTransmitPowerFor20MHz;
    optional [|TransmitPowerInformation.LocalMaximumTransmitPowerCount >= 1|] byte LocalMaximumTransmitPowerFor40MHz;
    optional [|TransmitPowerInformation.LocalMaximumTransmitPowerCount >= 2|] byte LocalMaximumTransmitPowerFor80MHz;
    optional [|TransmitPowerInformation.LocalMaximumTransmitPowerCount >= 3|] byte LocalMaximumTransmitPowerFor160MHz;
}

type TransmitPowerInformation
{
    byte Reserved with BinaryEncoding{Width = 2};
    byte LocalMaximumTransmitPowerUnitInterpretation with BinaryEncoding{Width = 3}, DisplayInfo{ToText = UnitInterpretationToString};
    byte LocalMaximumTransmitPowerCount with BinaryEncoding{Width = 3};

    string UnitInterpretationToString(any input)
    {
        if ((input as byte) == 0)
        {
            return "EIRP";
        }
        else
        {
            return "Reserved";
        }
    }
} with BinaryEncoding{WidthForComposedType = 8, DecodeAsUnit = true};

// 802.11ac - 2013 section 8.4.2.165 Channel Switch Wrapper element
type ChannelSwitchWrapper
{
    byte ElementID;
    byte Length;
    optional [|stream.RemainingByteLength() > 1 && stream.CurrentByte == 7|] Country NewCountrySubelement;
    optional [|stream.RemainingByteLength() > 1 && stream.CurrentByte == 194|] WideBandwidthChannelSwitchElement WideBandwidthChannelSwitchSubelement;
    optional [|stream.RemainingByteLength() > 1 && stream.CurrentByte == 195|] VHTTransmitPowerEnvelope NewVHTTransmitPowerEnvelopeSubelement;
    optional [|stream.RemainingByteLength() > 1 && stream.CurrentByte != 7 && stream.CurrentByte != 194 && stream.CurrentByte != 195|] binary Buffer with BinaryEncoding{Length = Length};
}

// 802.11ac - 2013 section 8.4.2.166 AID element
type AIDElement
{
    byte ElementID;
    byte Length;
    ushort AID;
}

// 802.11ac - 2013 section 8.4.2.167 Quiet Channel element
type QuietChannel
{
    byte ElementID;
    byte Length;
    byte APQuietMode;
    optional [|Length >= 2|] byte QuietCount;
    optional [|Length >= 3|] byte QuietPeriod;
    optional [|Length >= 5|] ushort QuietDuration;
    optional [|Length >= 7|] ushort QuietOffset;
}

// 802.11ac - 2013 section 8.4.2.168 Operating Mode Notification element
type OperatingModeNotification
{
    byte ElementID;
    byte Length;
    OperationModeField OperatingMode;
}

// =================== 8.4.4 Access Network Query Protocol (ANQP) elements ==================
// 802.11 - 2012 section 8.4.4.1 General
type GeneralAnqpElement
{
    ushort InfoId;
    ushort Length;
    binary Information with BinaryEncoding{Length = Length};
}

pattern AnqpInformationId = enum ushort
{
    $"Query List" = 256 ,
    $"Capability List" = 257 ,
    $"Venue Name" = 258 ,
    $"Emergency Call Number" = 259 ,
    $"Network Authentication Type" = 260 ,
    $"Roaming Consortium" = 261 ,
    $"IP Address Type Availability" = 262 ,
    $"NAI Realm" = 263 ,
    $"3GPP Cellular Network" = 264 ,
    $"AP Geospatial Location" = 265 ,
    $"AP Civic Location" = 266 ,
    $"AP Location Public Identifier URI" = 267 ,
    $"Domain Name" = 268 ,
    $"Emergency Alert Identifier URI" = 269 ,
    $"TDLS Capability" = 270 ,
    $"Emergency NAI" = 271 ,
    $"Neighbor Report" = 272 ,
    $"Vendor Specific" = 56797,
    ...
};

pattern AnqpInformationIdWithoutVendorSpecific = enum ushort
{
    $"Query List" = 256 ,
    $"Capability List" = 257 ,
    $"Venue Name" = 258 ,
    $"Emergency Call Number" = 259 ,
    $"Network Authentication Type" = 260 ,
    $"Roaming Consortium" = 261 ,
    $"IP Address Type Availability" = 262 ,
    $"NAI Realm" = 263 ,
    $"3GPP Cellular Network" = 264 ,
    $"AP Geospatial Location" = 265 ,
    $"AP Civic Location" = 266 ,
    $"AP Location Public Identifier URI" = 267 ,
    $"Domain Name" = 268 ,
    $"Emergency Alert Identifier URI" = 269 ,
    $"TDLS Capability" = 270 ,
    $"Emergency NAI" = 271 ,
    $"Neighbor Report" = 272,
    ...
};
 
pattern AnqpInformation = [|RemainingBitLength(stream) >= 16|]
    ([|!PeekByteCompare(stream, stream.BitPosition, [0xDD, 0xDD])|] AnqpInformationIdWithoutVendorSpecific |
    AnqpVendorSpecificList
    ) with DisplayInfo{ToText = AnqpInformationToText};

string AnqpInformationToText(any data)
{
    if (data is noSpec:AnqpInformationIdWithoutVendorSpecific)
    {
        return EnumToString(data, "WiFi.AnqpInformationIdWithoutVendorSpecific");
    }
    else if (data is spec:AnqpVendorSpecificList)
    {
        return "Vendor Specific";
    }
    return data.ToString();
}

const array<byte> AnqpQueryList_InfoId_BYTEARRAY = [0x00, 0x01];
const array<byte> AnqpCapabilityList_InfoId_BYTEARRAY = [0x01, 0x01];
const array<byte> VenueNameInformation_InfoId_BYTEARRAY = [0x02, 0x01];
const array<byte> EmergencyCallNumberInformation_InfoId_BYTEARRAY = [0x03, 0x01];
const array<byte> NetworkAuthenticationTypeInformation_InfoId_BYTEARRAY = [0x04, 0x01];
const array<byte> RoamingConsortiumList_InfoId_BYTEARRAY = [0x05, 0x01];
const array<byte> IpAddressTypeAvailabilityInformation_InfoId_BYTEARRAY = [0x06, 0x01];
const array<byte> NaiRealmList_InfoId_BYTEARRAY = [0x07, 0x01];
const array<byte> GPPCellularNetworkInformation_InfoId_BYTEARRAY = [0x08, 0x01];
const array<byte> ApGeospatialLocation_InfoId_BYTEARRAY = [0x09, 0x01];
const array<byte> ApCivicLocation_InfoId_BYTEARRAY = [0x0A, 0x01];
const array<byte> ApLocationPublicIdentifierUri_InfoId_BYTEARRAY = [0x0B, 0x01];
const array<byte> DomainNameList_InfoId_BYTEARRAY = [0x0C, 0x01];
const array<byte> EmergencyAlertUriInformation_InfoId_BYTEARRAY = [0x0D, 0x01];
const array<byte> EmergencyNaiInformation_InfoId_BYTEARRAY = [0x0F, 0x01];
const array<byte> AnqpVendorSpecificList_InfoId_BYTEARRAY = [0xDD, 0xDD];

pattern AnqpElementPattern = [|RemainingBitLength(stream) >= 16|]
    ([|PeekByteCompare(stream, stream.BitPosition, AnqpQueryList_InfoId_BYTEARRAY)|] AnqpQueryList |  // 256
    [|PeekByteCompare(stream, stream.BitPosition, AnqpCapabilityList_InfoId_BYTEARRAY)|] AnqpCapabilityList |  // 257
    [|PeekByteCompare(stream, stream.BitPosition, VenueNameInformation_InfoId_BYTEARRAY)|] VenueNameInformation |  // 258
    [|PeekByteCompare(stream, stream.BitPosition, EmergencyCallNumberInformation_InfoId_BYTEARRAY)|] EmergencyCallNumberInformation |  // 259
    [|PeekByteCompare(stream, stream.BitPosition, NetworkAuthenticationTypeInformation_InfoId_BYTEARRAY)|] NetworkAuthenticationTypeInformation |  // 260
    [|PeekByteCompare(stream, stream.BitPosition, RoamingConsortiumList_InfoId_BYTEARRAY)|] RoamingConsortiumList |  // 261
    [|PeekByteCompare(stream, stream.BitPosition, IpAddressTypeAvailabilityInformation_InfoId_BYTEARRAY)|] IpAddressTypeAvailabilityInformation |  // 262
    [|PeekByteCompare(stream, stream.BitPosition, NaiRealmList_InfoId_BYTEARRAY)|] NaiRealmList |  // 263
    [|PeekByteCompare(stream, stream.BitPosition, GPPCellularNetworkInformation_InfoId_BYTEARRAY)|] $"3GPPCellularNetworkInformation" |  // 264
    [|PeekByteCompare(stream, stream.BitPosition, ApGeospatialLocation_InfoId_BYTEARRAY)|] ApGeospatialLocation |  // 265
    [|PeekByteCompare(stream, stream.BitPosition, ApCivicLocation_InfoId_BYTEARRAY)|] ApCivicLocation |  // 266
    [|PeekByteCompare(stream, stream.BitPosition, ApLocationPublicIdentifierUri_InfoId_BYTEARRAY)|] ApLocationPublicIdentifierUri |  // 267
    [|PeekByteCompare(stream, stream.BitPosition, DomainNameList_InfoId_BYTEARRAY)|] DomainNameList |  // 268
    [|PeekByteCompare(stream, stream.BitPosition, EmergencyAlertUriInformation_InfoId_BYTEARRAY)|] EmergencyAlertUriInformation |  // 269
    [|PeekByteCompare(stream, stream.BitPosition, EmergencyNaiInformation_InfoId_BYTEARRAY)|] EmergencyNaiInformation |  // 271
    [|PeekByteCompare(stream, stream.BitPosition, AnqpVendorSpecificList_InfoId_BYTEARRAY)|] AnqpVendorSpecificList // 56797
    );
 
// 802.11 - 2012 section 8.4.4.2 Query List ANQP-element
type AnqpQueryList
{
    (AnqpInformationId where value == 256) InfoId;
    ushort Length;
    array<AnqpInformationId> AnqpQueryId with BinaryEncoding{Length = Length / 2};
}

// 802.11 - 2012 section 8.4.4.3 Capability List ANQP-element
type AnqpCapabilityList
{
    (AnqpInformationId where value == 257) InfoId;
    ushort Length;
    array<AnqpInformation> AnqpCapability with BinaryEncoding{WidthForComposedType = Length * 8};
}

// 802.11 - 2012 section 8.4.4.4 Venue Name ANQP-element
type VenueNameInformation
{
    (AnqpInformationId where value == 258) InfoId;
    ushort Length;
    VenueInfo VenueInfo;
    optional array<VenueNameDuple> VenueNameDuple with BinaryEncoding{WidthForComposedType = (Length - 2) * 8};
}

type VenueNameDuple
{
    byte Length;
    string LanguageCode with BinaryEncoding{Length = 3, TextEncoding = TextEncoding.ASCII};
    string VenueName with BinaryEncoding{Length = Length - 3, TextEncoding = TextEncoding.UTF8};
}

// 802.11 - 2012 section 8.4.4.5 Emergency Call Number ANQP-element
type EmergencyCallNumberInformation
{
    (AnqpInformationId where value == 259) InfoId;
    ushort Length;
    optional [|Length > 0|] array<EachEmergencyCallNumberUnit> VenueNameDuple with BinaryEncoding{WidthForComposedType = Length * 8};
}

type EachEmergencyCallNumberUnit
{
    byte LengthOfEmergencyCalNumber;
    string EmergencyCalNumber with BinaryEncoding{Length = LengthOfEmergencyCalNumber, TextEncoding = TextEncoding.UTF8};
}

// 802.11 - 2012 section 8.4.4.6 Network Authentication Type ANQP-element
type NetworkAuthenticationTypeInformation
{
    (AnqpInformationId where value == 260) InfoId;
    ushort Length;
    optional [|Length > 0|] array<NetworkAuthenticationTypeUnit> NetworkAuthenticationTypeUnit with BinaryEncoding{WidthForComposedType = Length * 8};
}

type NetworkAuthenticationTypeUnit
{
    NetworkAuthenticationTypeIndicator NetworkAuthenticationTypeIndicator;
    ushort RedirectUrlLength;
    optional [|RedirectUrlLength > 0|] string RedirectUrl  with BinaryEncoding{Length = RedirectUrlLength, TextEncoding = TextEncoding.ASCII};
}

pattern NetworkAuthenticationTypeIndicator = enum byte
{
    $"Acceptance of terms and conditions" = 0,
    $"On-line enrollment supported" = 1,
    $"http/https redirection" = 2,
    $"DNS redirection" = 3,
    ...
};

// 802.11 - 2012 section 8.4.4.7 Roaming Consortium ANQP-element
type RoamingConsortiumList
{
    (AnqpInformationId where value == 261) InfoId;
    ushort Length;
    optional [|Length > 0|] array<OiDuple> OiDuple with BinaryEncoding{WidthForComposedType = Length * 8};
}

type OiDuple
{
    byte OiLength;
    binary Oi with BinaryEncoding{Length = OiLength};
}

// 802.11 - 2012 section 8.4.4.8 Vendor Specific ANQP-element
type AnqpVendorSpecificList
{
    (AnqpInformationId where value == 56797) InfoId;
    ushort Length;
    binary OiAndVendorSpecificContent with BinaryEncoding{Length = Length};
}

// 802.11 - 2012 section 8.4.4.9 IP Address Type Availability ANQP-element
type IpAddressTypeAvailabilityInformation
{
    (AnqpInformationId where value == 262) InfoId;
    ushort Length;
    IpAddress IpAddress;
}

type IpAddress
{
    Ipv4Address Ipv4Address with BinaryEncoding{Width = 6};
    Ipv6Address Ipv6Address with BinaryEncoding{Width = 2};
}

pattern Ipv6Address = enum byte
{
    $"Address type not available" = 0,
    $"Address type available" = 1,
    $"Availability of the address type not known" = 2,
    ...
} with BinaryEncoding{Width = 2};

pattern Ipv4Address = enum byte
{
    $"Address type not available" = 0,
    $"Public IPv4 address available" = 1,
    $"Port-restricted IPv4 address available" = 2,
    $"Single NATed private IPv4 address available" = 3,
    $"Double NATed private IPv4 address available" = 4,
    $"Port-restricted IPv4 address and single NATed IPv4 address available" = 5,
    $"Port-restricted IPv4 address and double NATed IPv4 address available" = 6,
    $"Availability of the address type is not known" = 7,
    ...
} with BinaryEncoding{Width = 6};

// 802.11 - 2012 section 8.4.4.10 NAI Realm ANQP-element
type NaiRealmList
{
    (AnqpInformationId where value == 263) InfoId;
    ushort Length;
    ushort NaiRealmCount;
    optional [|NaiRealmCount > 0|] array<NaiRealmData> NaiRealmData with BinaryEncoding{Length = NaiRealmCount};
}

type NaiRealmData
{
    ushort NaiRealmDataFieldLength;
    byte Reserved with BinaryEncoding{Width = 7};
    bool NaiRealmEncodingType with BinaryEncoding{Width = 1};
    byte NaiRealmLength;
    binary NaiRealm with BinaryEncoding{Length = NaiRealmLength};
    byte EapMethodCount;
    optional [|EapMethodCount > 0|] array<EapMethod> EapMethod with BinaryEncoding{Length = EapMethodCount};
}

type EapMethod
{
    byte Length;
    byte EapMethod;
    byte AuthenticationParameterCount;
    optional [|AuthenticationParameterCount > 0|] array<AuthenticationParameter> AuthenticationParameter with BinaryEncoding{Length = AuthenticationParameterCount};
}

type AuthenticationParameter
{
    AuthenticationParameterTypes ID;
    byte Length;
    binary AuthenticationParameterValue with BinaryEncoding{Length = Length};
}

pattern AuthenticationParameterTypes = enum byte
{
    $"Expanded EAP Method" = 1,
    $"Non-EAP Inner Authentication Type" = 2,
    $"Inner Authentication EAP Method Type" = 3,
    $"Expanded Inner EAP Method" = 4,
    $"Credential Type" = 5,
    $"Tunneled EAP Method Credential Type" = 6,
    $"Vendor Specific" = 221,
    ...
};

// 802.11 - 2012 section 8.4.4.11 3GPP Cellular Network ANQP-element
type $"3GPPCellularNetworkInformation"
{
    (AnqpInformationId where value == 264) InfoId;
    byte Length;
    binary Payload with BinaryEncoding{Length = Length};
}

// 802.11 - 2012 section 8.4.4.12 AP Geospatial Location ANQP-element
type ApGeospatialLocation
{
    (AnqpInformationId where value == 265) InfoId;
    byte Length;
    binary LocationConfigurationReport with BinaryEncoding{Length = Length};
}

// 802.11 - 2012 section 8.4.4.13 AP Civic Location ANQP-element
type ApCivicLocation
{
    (AnqpInformationId where value == 266) InfoId;
    byte Length;
    binary LocationCivicReport with BinaryEncoding{Length = Length};
}

// 802.11 - 2012 section 8.4.4.14 AP Location Public Identifier URI ANQP-element
type ApLocationPublicIdentifierUri
{
    (AnqpInformationId where value == 267) InfoId;
    byte Length;
    binary PublicIdentifierUri with BinaryEncoding{Length = Length};
}

// 802.11 - 2012 section 8.4.4.15 Domain Name ANQP-element
type DomainNameList
{
    (AnqpInformationId where value == 268) InfoId;
    ushort Length;
    optional [|Length > 0|] array<DomainName> DomainName with BinaryEncoding{WidthForComposedType = Length * 8};
}

type DomainName
{
    byte Length;
    string DomainName with BinaryEncoding{Length = Length, TextEncoding = TextEncoding.ASCII};
}

// 802.11 - 2012 section 8.4.4.16 Emergency Alert URI ANQP-element
type EmergencyAlertUriInformation
{
    (AnqpInformationId where value == 269) InfoId;
    byte Length;
    string EmergencyAlertUri with BinaryEncoding{Length = Length, TextEncoding = TextEncoding.ASCII};
}

// 802.11 - 2012 section 8.4.4.17 Emergency NAI ANQP-element
type EmergencyNaiInformation
{
    (AnqpInformationId where value == 271) InfoId;
    byte Length;
    string EmergencyNaiString with BinaryEncoding{Length = Length, TextEncoding = TextEncoding.UTF8};
}

// =========== 8.5 Action frame format details ===============
// 802.11 - 2012 section 8.5.2.2 Measurement Request frame format
type MeasurementRequestForAction
{
    byte Category;
    byte Action;
    byte DialogToken;
    array<MeasurementRequest> MeasurementRequest;
}

// 802.11 - 2012 section 8.5.2.4 TPC Request frame format
type TPCRequestForAction
{
    byte Category;
    byte Action;
    byte DialogToken;
    TPCRequest TPCRequest;
}

// 802.11 - 2012 section 8.5.2.5 TPC Report frame format
type TPCReportForAction
{
    byte Category;
    byte Action;
    byte DialogToken;
    TPCReport TPCReport;
}

// 802.11 - 2012 section 8.5.2.6 Channel Switch Announcement frame format
type ChannelSwitchAnnouncementForAction
{
    byte Category;
    byte Action;
    ChannelSwitchAnnouncement ChannelSwitchAnnouncement;
    optional [|stream.RemainingByteLength > 1 && CurrentByte(stream) == 62|] SecondaryChannelOffset SecondaryChannelOffset;
    optional [|stream.RemainingByteLength > 1 && CurrentByte(stream) == 118|] MeshChannelSwitchParameters MeshChannelSwitchParametersElement;
    // defined by 802.11ac -2013
    optional [|stream.RemainingByteLength > 1 && CurrentByte(stream) == 163|] WideBandwidthChannelSwitchElement WideBandwidthChannelSwitchElement;
    optional [|stream.RemainingByteLength > 1 && stream.CurrentByte == 195|] VHTTransmitPowerEnvelope NewVHTTransmitPowerEnvelopeSubelement;
}

pattern QosAction = [|RemainingBitLength(stream) >= 16|]
    ([|PeekByte(stream, stream.BitPosition + 8) == 0x00|] AddtsRequest |                             // Category == 1, Action == 0
    [|PeekByte(stream, stream.BitPosition + 8) == 0x01|] AddtsResponse |                            // Category == 1, Action == 1
    [|PeekByte(stream, stream.BitPosition + 8) == 0x02|] Delts |                                    // Category == 1, Action == 2
    [|PeekByte(stream, stream.BitPosition + 8) == 0x03|] SchedulForAction |                         // Category == 1, Action == 3
    [|PeekByte(stream, stream.BitPosition + 8) == 0x04|] QosMapConfigure);                           // Category == 1, Action == 4

// 802.11 - 2012 section 8.5.3.2 ADDTS Request frame format
type AddtsRequest
{
    byte Category;
    byte Action;
    byte DialogToken;
    TSPEC Tspec;
    optional array<TCLAS> tclas;
    optional TCLASProcessing TclasProcessing;
    optional ExpeditedBandwidthRequestInformation ExpeditedBandwidthRequestInformation;
}

// 802.11 - 2012 section 8.5.3.3 ADDTS Response frame format
type AddtsResponse
{
    byte Category;
    byte Action;
    byte DialogToken;
    ushort Status;
    optional [|Status == 47|] TSDelay TSDelay;
    TSPEC Tspec;
    optional array<TCLAS> tclas;
    optional TCLASProcessing TclasProcessing;
    optional [|Status == 0|] Schedule Schedule;
    optional ExpeditedBandwidthRequestInformation ExpeditedBandwidthRequestInformation;
}

// 802.11 - 2012 section 8.5.3.4 DELTS frame format
type Delts
{
    byte Category;
    byte Action;
    byte DialogToken;
    TSInfo TSInfo;
    ushort Reason;
}

// 802.11 - 2012 section 8.5.3.5 Schedule frame format
type SchedulForAction
{
    byte Category;
    byte Action;
    Schedule Schedule;
}

// 802.11 - 2012 section 8.5.3.6 QoS Map Configure frame format
type QosMapConfigure
{
    byte Category;
    byte Action;
    QosMapSetinformation QosMapSetInformation;
}

// DLSAction, Category == 2
pattern DLSAction = [|RemainingBitLength(stream) >= 16|]
    ([|PeekByte(stream, stream.BitPosition + 8) == 0x00|] DLSRequest |                               // Category == 2, Action == 0
    [|PeekByte(stream, stream.BitPosition + 8) == 0x01|] DLSResponse |                              // Category == 2, Action == 1
    [|PeekByte(stream, stream.BitPosition + 8) == 0x02|] DLSTeardown);                               // Category == 2, Action == 2

// 802.11 - 2012 section 8.5.4.2 DLS Request frame format
type DLSRequest
{
    byte Category;
    byte Action;
    MacAddress Destination;
    MacAddress Source;
    Capability CapabilityInformation;
    ushort DLSTimeoutValue;
    SupportedRates SupportedRates;
    ExtendedSupportedRates ExtendedSupportedRates;
    optional [|stream.RemainingByteLength > 1 && CurrentByte(stream) == 45|] HTCapabilities HTCapabilities;
    // defined by 802.11ac -2013
    optional [|stream.RemainingByteLength > 1 && CurrentByte(stream) == 197|] AIDElement AIDElement;
    optional [|stream.RemainingByteLength > 1 && CurrentByte(stream) == 191|] VHTCapabilities VHTCapabilities;
}

// 802.11 - 2012 section 8.5.4.3 DLS Response frame format
type DLSResponse
{
    byte Category;
    byte Action;
    ushort Status;
    MacAddress Destination;
    MacAddress Source;
    optional [|Status == 0|] Capability CapabilityInformation;
    optional [|Status == 0|] SupportedRates SupportedRates;
    optional [|Status == 0|] ExtendedSupportedRates ExtendedSupportedRates;
    optional [|stream.RemainingByteLength > 1 && CurrentByte(stream) == 45|] HTCapabilities HTCapabilities;
    // defined by 802.11ac -2013
    optional [|stream.RemainingByteLength > 1 && CurrentByte(stream) == 197|] AIDElement AIDElement;
    optional [|stream.RemainingByteLength > 1 && CurrentByte(stream) == 191|] VHTCapabilities VHTCapabilities;

}

// 802.11 - 2012 section 8.5.4.4 DLS Teardown frame format
type DLSTeardown
{
    byte Category;
    byte Action;
    MacAddress Destination;
    MacAddress Source;
    ushort Reason;
}

// BlockAckAction, Category == 3
pattern BlockAckAction = [|RemainingBitLength(stream) >= 16|]
    ([|PeekByte(stream, stream.BitPosition + 8) == 0x00|] ADDBARequest |                             // Category == 3, Action == 0
    [|PeekByte(stream, stream.BitPosition + 8) == 0x01|] ADDBAResponse |                            // Category == 3, Action == 1
    [|PeekByte(stream, stream.BitPosition + 8) == 0x02|] DELBA);                                     // Category == 3, Action == 2

// 802.11 - 2012 section 8.5.5.2 ADDBA Request frame format
type ADDBARequest
{
    byte Category;
    byte Action;
    byte DialogToken;
    BlockAckParameterSet BlockAckParameterSet;
    ushort BlockAckTimeoutValue;
    BlockAckStartingSequenceControl BlockAckStartingSequenceControl;
}

// 802.11 - 2012 section 8.5.5.3 ADDBA Response frame format
type ADDBAResponse
{
    byte Category;
    byte Action;
    byte DialogToken;
    ushort Status;
    BlockAckParameterSet BlockAckParameterSet;
    ushort BlockAckTimeoutValue;
}

// 802.11 - 2012 section 8.5.5.4 DELBA frame format
type DELBA
{
    byte Category;
    byte Action;
    DELBAParameterSet DELBAParameterSet;
    ushort Reason;
}

// 802.11 - 2012 section 8.5.6 Vendor-specific action details
type VendorSpecificFrame
{
    (byte where value == 0xFF) Category;
    binary OUI with BinaryEncoding{Length = 3};
    binary Content;
}

// 802.11 - 2012 section 8.5.23 VHT Action frame details
pattern VHTAction = [|RemainingBitLength(stream) >= 16|]
    ([|PeekByte(stream, stream.BitPosition + 8) == 0x00|] VHTCompressedBeamforming |                    // Category == 21, Action == 0
    [|PeekByte(stream, stream.BitPosition + 8) == 0x01|] GroupIDManagement |                            // Category == 21, Action == 1
    [|PeekByte(stream, stream.BitPosition + 8) == 0x02|] OperatingModeNotificationFrame);               // Category == 21, Action == 2

// 802.11ac - 2013 section 8.5.23.2 VHT Compressed Beamforming frame format
type VHTCompressedBeamforming
{
    byte Category;
    byte Action;
    VHTMIMOControlField VHTMIMOControl;
    VHTCompressedBeamformingReportField VHTCompressedBeamformingReport;
}

// 802.11ac - 2013 section 8.5.23.3  Group ID Management frame format
type GroupIDManagement
{
    byte Category;
    byte Action;
    MembershipStatusArrayField MembershipStatusArray;
    UserPositionArrayField UserPositionArray;
}

// 802.11ac - 2013 section 8.5.23.4 Operating Mode Notification frame format
type OperatingModeNotificationFrame
{
    byte Category;
    byte Action;
    OperationModeField OperationMode;
}

// ================== 8.5.7 Radio Measurement action details ====================
// Radio Measurement, Category == 5
pattern RadioMeasurementAction = [|RemainingBitLength(stream) >= 16|]
    ([|PeekByte(stream, stream.BitPosition + 8) == 0x00|] RadioMeasurementRequest | // 0
    [|PeekByte(stream, stream.BitPosition + 8) == 0x01|] RadioMeasurementReport | // 1
    [|PeekByte(stream, stream.BitPosition + 8) == 0x02|] LinkMeasurementRequest | // 2
    [|PeekByte(stream, stream.BitPosition + 8) == 0x03|] LinkMeasurementReport | // 3
    [|PeekByte(stream, stream.BitPosition + 8) == 0x04|] NeighborReportRequest | // 4
    [|PeekByte(stream, stream.BitPosition + 8) == 0x05|] NeighborReportResponse); //5

// 802.11 - 2012 section 8.5.7.2 Radio Measurement Request frame format
type RadioMeasurementRequest
{
    byte Category;
    byte Action;
    byte DialogToken;
    ushort NumberOfRepetitions;
    array<MeasurementRequest> MeasurementRequests;
}

// 802.11 - 2012 section 8.5.7.3 Radio Measurement Report frame format
type RadioMeasurementReport
{
    byte Category;
    byte Action;
    byte DialogToken;
    array<MeasurementReport> MeasurementReports;
}

// 802.11 - 2012 section 8.5.7.4 Link Measurement Request frame format
type LinkMeasurementRequest
{
    byte Category;
    byte Action;
    byte DialogToken;
    byte TransmitPowerUsed;
    byte MaxTransmitPower;
    array<VendorSpecificInformation> SubElements;
}

// 802.11 - 2012 section 8.5.7.5 Link Measurement Report frame format
type LinkMeasurementReport
{
    byte Category;
    byte Action;
    byte DialogToken;
    TPCReport TPCReport;
    byte ReceiveAntennaID;
    byte TransmitAntennaID;
    byte RCPI;
    byte RSNI;
    array<VendorSpecificInformation> SubElements;
}

// 802.11 - 2012 section 8.5.7.6 Neighbor Report Request frame format
type NeighborReportRequest
{
    byte Category;
    byte Action;
    byte DialogToken;
    array<SubElementForNeighborReportRequest> SubElements;
}

pattern SubElementForNeighborReportRequest = [|stream.RemainingByteLength > 1|]
(
    [|stream.CurrentByte == 0|] SSID |
    [|stream.CurrentByte == 221|] VendorSpecificInformation
);

// 802.11 - 2012 section 8.5.7.7 Neighbor Report Response frame format
type NeighborReportResponse
{
    byte Category;
    byte Action;
    byte DialogToken;
    array<NeighborReport> NeighborReports;
}

// =================== 8.5.8 Public Action details ==================
// 802.11 - 2012 section 8.5.8.1 Public Action frames
type PublicActionFrame
{
    PublicActionFrameBody Action;
}

type VendorSpecificActionFrame
{
    VendorSpecificFrame Action;
}

pattern ActionFramePattern = ActionFrame | PublicActionFrame | VendorSpecificActionFrame;

const array<byte> WiFi20or40BSSCoexistenceManagement_BYTEARRAY = [0x04, 0x00];
const array<byte> DSEEnablement_4_BYTEARRAY = [0x04, 0x01];
const array<byte> DSEEnablement_9_BYTEARRAY = [0x09, 0x01];
const array<byte> DSEDeEnablement_4_BYTEARRAY = [0x04, 0x02];
const array<byte> DSEDeEnablement_9_BYTEARRAY = [0x09, 0x02];
const array<byte> DSERegisteredLocationAnnouncement_BYTEARRAY = [0x04, 0x03];
const array<byte> ExtendedChannelSwitchAnnouncementForAction_4_BYTEARRAY = [0x04, 0x04];
const array<byte> ExtendedChannelSwitchAnnouncementForAction_9_BYTEARRAY = [0x09, 0x04];
const array<byte> DSEMeasurementRequest_4_BYTEARRAY = [0x04, 0x05];
const array<byte> DSEMeasurementRequest_9_BYTEARRAY = [0x09, 0x05];
const array<byte> DSEMeasurementReport_4_BYTEARRAY = [0x04, 0x06];
const array<byte> DSEMeasurementReport_9_BYTEARRAY = [0x09, 0x06];
const array<byte> MeasurementPilot_BYTEARRAY = [0x04, 0x07];
const array<byte> DSEPowerConstraint_4_BYTEARRAY = [0x04, 0x08];
const array<byte> DSEPowerConstraint_9_BYTEARRAY = [0x09, 0x08];
const array<byte> PublicActionVendorSpecific_4_BYTEARRAY = [0x04, 0x09];
const array<byte> PublicActionVendorSpecific_9_BYTEARRAY = [0x09, 0x09];
const array<byte> GasInitialRequest_4_BYTEARRAY = [0x04, 0x0A];
const array<byte> GasInitialRequest_9_BYTEARRAY = [0x09, 0x0A];
const array<byte> GasInitialResponse_4_BYTEARRAY = [0x04, 0x0B];
const array<byte> GasInitialResponse_9_BYTEARRAY = [0x09, 0x0B];
const array<byte> GasComebackRequest_4_BYTEARRAY = [0x04, 0x0C];
const array<byte> GasComebackRequest_9_BYTEARRAY = [0x09, 0x0C];
const array<byte> GasComebackResponse_4_BYTEARRAY = [0x04, 0x0D];
const array<byte> GasComebackResponse_9_BYTEARRAY = [0x09, 0x0D];
const array<byte> TDLSDiscoveryResponse_4_BYTEARRAY = [0x04, 0x0E];
const array<byte> TDLSDiscoveryResponse_9_BYTEARRAY = [0x09, 0x0E];

// 802.11 - 2012 section 8.4.1.11 Action field
pattern ActionFrameBody = [|RemainingBitLength(stream) >= 16|]
    ( // SpectrumManagementAction, Category == 0
    [|CurrentByte(stream) == 0|] SpectrumManagementAction |
    // Qos, Category == 1
    [|CurrentByte(stream) == 1|] QosAction |
    // DLSAction, Category == 2
    [|CurrentByte(stream) == 2|] DLSAction |
    // BlockAckAction, Category == 3
    [|CurrentByte(stream) == 3|] BlockAckAction |
    // Radio Measurement, Category == 5
    [|CurrentByte(stream) == 5|] RadioMeasurementAction |
    // FT Action, Category == 6
    [|CurrentByte(stream) == 6|] FTAction |
    // HTAction, Category == 7
    [|CurrentByte(stream) == 7|] HTAction |
    // WSA Action, Category == 8
    [|CurrentByte(stream) == 8|] WSAAction |
    // VHT Action, Category == 21
    [|CurrentByte(stream) == 8|] VHTAction);

pattern PublicActionFrameBody = [|RemainingBitLength(stream) >= 16|]
    (// PublicAction, Category == 4 or Category == 9
    // PublicAction, Category == 4 or Category == 9
    [|PeekByteCompare(stream, stream.BitPosition, WiFi20or40BSSCoexistenceManagement_BYTEARRAY)|] WiFi20or40BSSCoexistenceManagement |
    [|PeekByteCompare(stream, stream.BitPosition, DSEEnablement_4_BYTEARRAY) || PeekByteCompare(stream, stream.BitPosition, DSEEnablement_9_BYTEARRAY)|] DSEEnablement |
    [|PeekByteCompare(stream, stream.BitPosition, DSEDeEnablement_4_BYTEARRAY) || PeekByteCompare(stream, stream.BitPosition, DSEDeEnablement_9_BYTEARRAY)|] DSEDeEnablement | // 2
    [|PeekByteCompare(stream, stream.BitPosition, DSERegisteredLocationAnnouncement_BYTEARRAY)|] DSERegisteredLocationAnnouncement | // 3
    [|PeekByteCompare(stream, stream.BitPosition, ExtendedChannelSwitchAnnouncementForAction_4_BYTEARRAY) || PeekByteCompare(stream, stream.BitPosition, ExtendedChannelSwitchAnnouncementForAction_9_BYTEARRAY)|] ExtendedChannelSwitchAnnouncementForAction | // 4
    [|PeekByteCompare(stream, stream.BitPosition, DSEMeasurementRequest_4_BYTEARRAY) || PeekByteCompare(stream, stream.BitPosition, DSEMeasurementRequest_9_BYTEARRAY)|] DSEMeasurementRequest | // 5
    [|PeekByteCompare(stream, stream.BitPosition, DSEMeasurementReport_4_BYTEARRAY) || PeekByteCompare(stream, stream.BitPosition, DSEMeasurementReport_9_BYTEARRAY)|] DSEMeasurementReport | // 6
    [|PeekByteCompare(stream, stream.BitPosition, MeasurementPilot_BYTEARRAY)|] MeasurementPilot | // 7
    [|PeekByteCompare(stream, stream.BitPosition, DSEPowerConstraint_4_BYTEARRAY) || PeekByteCompare(stream, stream.BitPosition, DSEPowerConstraint_9_BYTEARRAY)|] DSEPowerConstraint | // 8
    [|PeekByteCompare(stream, stream.BitPosition, PublicActionVendorSpecific_4_BYTEARRAY) || PeekByteCompare(stream, stream.BitPosition, PublicActionVendorSpecific_9_BYTEARRAY)|] VendorSpecificForPublic | // 9
    [|PeekByteCompare(stream, stream.BitPosition, GasInitialRequest_4_BYTEARRAY) || PeekByteCompare(stream, stream.BitPosition, GasInitialRequest_9_BYTEARRAY)|] GasInitialRequest | // 10
    [|PeekByteCompare(stream, stream.BitPosition, GasInitialResponse_4_BYTEARRAY) || PeekByteCompare(stream, stream.BitPosition, GasInitialResponse_9_BYTEARRAY)|] GasInitialResponse | // 11
    [|PeekByteCompare(stream, stream.BitPosition, GasComebackRequest_4_BYTEARRAY) || PeekByteCompare(stream, stream.BitPosition, GasComebackRequest_9_BYTEARRAY)|] GasComebackRequest | // 12
    [|PeekByteCompare(stream, stream.BitPosition, GasComebackResponse_4_BYTEARRAY) || PeekByteCompare(stream, stream.BitPosition, GasComebackResponse_9_BYTEARRAY)|] GasComebackResponse | // 13
    [|PeekByteCompare(stream, stream.BitPosition, TDLSDiscoveryResponse_4_BYTEARRAY) || PeekByteCompare(stream, stream.BitPosition, TDLSDiscoveryResponse_9_BYTEARRAY)|] TDLSDiscoveryResponse); // 14

pattern SpectrumManagementAction = [|RemainingBitLength(stream) >= 16|]
    ([|PeekByte(stream, stream.BitPosition + 8) == 0x00|] MeasurementRequestForAction |              // Category == 0, Action == 0
    [|PeekByte(stream, stream.BitPosition + 8) == 0x01|] MeasurementReportForAction |               // Category == 0, Action == 1
    [|PeekByte(stream, stream.BitPosition + 8) == 0x02|] TPCRequestForAction |                      // Category == 0, Action == 2
    [|PeekByte(stream, stream.BitPosition + 8) == 0x03|] TPCReportForAction |                       // Category == 0, Action == 3
    [|PeekByte(stream, stream.BitPosition + 8) == 0x04|] ChannelSwitchAnnouncementForAction);       // Category == 0, Action == 4

// 802.11 - 2012 section 8.5.8.2 20/40 BSS Coexistence Management frame format
type WiFi20or40BSSCoexistenceManagement
{
    byte Category;
    byte Action;
    WiFi20or40BSSCoexistence WiFi20or40BSSCoexistence;
    optional array<WiFi20and40BSSIntolerantChannelReport> WiFi20and40BSSIntolerantChannelReports;
}

// 802.11 - 2012 section 8.5.8.4 DSE Enablement frame format
type DSEEnablement
{
    byte Category;
    byte Action;
    MacAddress RequesterSTAAddress;
    MacAddress ResponderSTAAddress;
    byte Reason;
    ushort EnablementIdentifier;
}

// 802.11 - 2012 section 8.5.8.5 DSE Deenablement frame format
type DSEDeEnablement
{
    byte Category;
    byte Action;
    MacAddress RequesterSTAAddress;
    MacAddress ResponderSTAAddress;
    byte Reason;
}

// 802.11 - 2012 section 8.5.8.6 DSE Registered Location Announcement frame format
type DSERegisteredLocationAnnouncement
{
    byte Category;
    byte Action;
    DSERLBody Body;
}

// 802.11 - 2012 section 8.5.8.7 Extended Channel Switch Announcement frame format
type ExtendedChannelSwitchAnnouncementForAction
{
    byte Category;
    byte Action;
    byte ChannelSwitchMode;
    byte NewRegulatoryClass;
    byte NewChannelNumber;
    byte ChannelSwitchCount;
    optional [|stream.RemainingByteLength > 1 && stream.CurrentByte == 118|] MeshChannelSwitchParameters MeshChannelSwitchParametersElement;
    // defined in 802.11ac - 2013
    optional [|stream.RemainingByteLength() > 1 && stream.CurrentByte == 7|] Country NewCountrySubelement;
    optional [|stream.RemainingByteLength() > 1 && stream.CurrentByte == 194|] WideBandwidthChannelSwitchElement WideBandwidthChannelSwitchSubelement;
    optional [|stream.RemainingByteLength() > 1 && stream.CurrentByte == 195|] VHTTransmitPowerEnvelope NewVHTTransmitPowerEnvelopeSubelement;
}

// 802.11 - 2012 section 8.5.8.8 DSE Measurement Request frame format
type DSEMeasurementRequest
{
    byte Category;
    byte Action;
    MacAddress RequesterSTAAddress;
    MacAddress ResponderSTAAddress;
    byte RegulatoryClass;
    byte ChannelNumber;
    ulong MeasurementStartTime;
    ushort MeasurementDuration;
}

// 802.11 - 2012 section 8.5.8.9 DSE Measurement Report frame format
type DSEMeasurementReport
{
    byte Category;
    byte Action;
    MacAddress RequesterSTAAddress;
    MacAddress ResponderSTAAddress;
    ushort Length;
    byte RegulatoryClass;
    byte ChannelNumber;
    MeasurementReportMode MeasurementReportMode;
    ulong ActualMeasurementStartTime;
    ushort MeasurementDuration;
    MacAddress SaAddress;
    DSERLBody DSELCI;
}

// 802.11 - 2012 section 8.5.8.3 Measurement Pilot frame format
type MeasurementPilot
{
    byte Category;
    byte Action;
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "WiFi", "Reserved", "MeasurementPilot", value) with BinaryEncoding{Width = 6};
    bool ShortSlotTime      with BinaryEncoding{Width = 1};
    bool SpectrumManagement with BinaryEncoding{Width = 1};
    ushort CondensedCountryString;
    byte RegulatoryClass;
    byte Channel;
    byte MeasurementPilotInterval;
    array<SubElementForMeasurementPilot> SubElements;
}

pattern SubElementForMeasurementPilot = [|stream.RemainingByteLength > 1|]
(
    [|stream.CurrentByte == 71|] MultipleBSSID |
    [|stream.CurrentByte == 221|] VendorSpecificInformation
);

// 802.11 - 2012 section 8.5.8.10 DSE Power Constraint frame format
type DSEPowerConstraint
{
    byte Category;
    byte Action;
    MacAddress RequesterSTAAddress;
    MacAddress ResponderSTAAddress;
    byte Reason;
    uint LocalPowerConstraint;
}

// 802.11 - 2012 section 8.5.8.11 Vendor Specific Public Action frame format
type VendorSpecificForPublic
{
    (byte where value == 4) Category;
    (byte where value == 9) Action;
    binary OUI with BinaryEncoding{Length = 3};
    binary Content;
}

bool IsAnqpProtocol(AdvertisementProtocol e)
{
    return (e.AdvertisementProtocolTuple.Count > 0 && e.AdvertisementProtocolTuple[0].AdvertisementProtocolId is id:AdvertisementProtocolId && id == 0);
}
    
// 802.11 - 2012 section 8.5.8.12 GAS Initial Request frame format
type GasInitialRequest
{
    (byte where value == 4) Category;
    (byte where value == 10) Action;
    byte DialogToken;
    AdvertisementProtocol AdvertisementProtocolElement;
    ushort QueryRequestLength;
    ([|IsAnqpProtocol(AdvertisementProtocolElement)|] array<AnqpElementPattern> |
    binary) QueryRequest; // with BinaryEncoding{WidthForComposedType = QueryRequestLength * 8};
}

// 802.11 - 2012 section 8.5.8.13 GAS Initial Response frame format
type GasInitialResponse
{
    (byte where value == 4) Category;
    (byte where value == 11) Action;
    byte DialogToken;
    ushort StatusCode;
    ushort GasComebackDelay;
    AdvertisementProtocol AdvertisementProtocolElement;
    ushort QueryResponseLength;
    optional [|QueryResponseLength > 0|] ([|IsAnqpProtocol(AdvertisementProtocolElement)|] array<AnqpElementPattern> |
    binary) QueryResponse; // with BinaryEncoding{WidthForComposedType = QueryResponseLength * 8};
}

// 802.11 - 2012 section 8.5.8.14 GAS Comeback Request frame format
type GasComebackRequest
{
    (byte where value == 4) Category;
    (byte where value == 12) Action;
    byte DialogToken;
}

// 802.11 - 2012 section 8.5.8.15 GAS Comeback Response frame format
type GasComebackResponse
{
    (byte where value == 4) Category;
    (byte where value == 13) Action;
    byte DialogToken;
    ushort StatusCode;
    GasQueryResponseFragmentId GasQueryResponseFragmentId;
    ushort GasComebackDelay;
    AdvertisementProtocol AdvertisementProtocolElement;
    ushort QueryResponseLength;
    optional [|QueryResponseLength > 0|] (
        [|GasQueryResponseFragmentId.GasQueryResponseFragmentId == 0 && (!GasQueryResponseFragmentId.MoreGasFragments) && IsAnqpProtocol(AdvertisementProtocolElement)|] array<AnqpElementPattern> |
        binary |
        any
        ) QueryResponse; // with BinaryEncoding{MaxLength = QueryResponseLength};
}

// 802.11 - 2012 section 8.5.8.16 TDLS Discovery Response frame format
type TDLSDiscoveryResponse
{
    byte Category;
    byte Action;
    byte DialogToken;
    array<InformationField> InformationElements;
}

// ============== 8.5.9 FT Action frame details =================
// FT Action, Category == 6
pattern FTAction = [|RemainingBitLength(stream) >= 16|]
    ([|PeekByte(stream, stream.BitPosition + 8) == 0x01|] FTRequest | // 1
    [|PeekByte(stream, stream.BitPosition + 8) == 0x02|] FTResponse | // 2
    [|PeekByte(stream, stream.BitPosition + 8) == 0x03|] FTConfirm | //  3
    [|PeekByte(stream, stream.BitPosition + 8) == 0x04|] FTAck); // 4

// 802.11 - 2012 section 8.5.9.2 FT Request frame
type FTRequest
{
    byte Category;
    byte Action;
    MacAddress StaAddress;
    MacAddress TargetAPAddress;
    optional RSN RSN;
    MobilityDomain MobilityDomain;
    optional FastBSSTransition FastBSSTransition;
}

// 802.11 - 2012 section 8.5.9.3 FT Response frame
type FTResponse
{
    byte Category;
    byte Action;
    MacAddress StaAddress;
    MacAddress TargetAPAddress;
    ushort Status;
    optional RSN RSN;
    MobilityDomain MobilityDomain;
    optional FastBSSTransition FastBSSTransition;
}

// 802.11 - 2012 section 8.5.9.4 FT Confirm frame
type FTConfirm
{
    byte Category;
    byte Action;
    MacAddress StaAddress;
    MacAddress TargetAPAddress;
    optional RSN RSN;
    MobilityDomain MobilityDomain;
    optional FastBSSTransition FastBSSTransition;
    optional RICData RICData;
    optional RICDescriptor RICDescriptor;
}

// 802.11 - 2012 section 8.5.9.5 FT Ack frame
type FTAck
{
    byte Category;
    byte Action;
    MacAddress StaAddress;
    MacAddress TargetAPAddress;
    ushort Status;
    optional RSN RSN;
    MobilityDomain MobilityDomain;
    optional FastBSSTransition FastBSSTransition;
    optional TimeoutInterval TimeoutInterval;
    optional RICData RICData;
    optional RICDescriptor RICDescriptor;
}

// 802.11 - 2012 section 8.5.10 SA Query Action frame details
// Not covered

// 802.11 - 2012 section 8.5.11 Protected Dual of Public Action frames
// Not covered

// ============== 8.5.12 HT Action frame details =================
// HTAction, Category == 7
pattern HTAction = [|RemainingBitLength(stream) >= 16|]
    ([|PeekByte(stream, stream.BitPosition + 8) == 0x00|] NotifyChannelWidth | // 0
    [|PeekByte(stream, stream.BitPosition + 8) == 0x01|] SMPowerSave | // 1
    [|PeekByte(stream, stream.BitPosition + 8) == 0x02|] PSMP | // 2
    [|PeekByte(stream, stream.BitPosition + 8) == 0x03|] SetPCOPhase | // 3
    [|PeekByte(stream, stream.BitPosition + 8) == 0x04|] CSI | // 4
    [|PeekByte(stream, stream.BitPosition + 8) == 0x05|] NoncompressedBeamforming | // 5
    [|PeekByte(stream, stream.BitPosition + 8) == 0x06|] CompressedBeamforming | // 6
    [|PeekByte(stream, stream.BitPosition + 8) == 0x07|] ASELIndicesFeedback); //7

// 802.11 - 2012 section 8.5.12.2 Notify Channel Width frame format
type NotifyChannelWidth
{
    byte Category;
    byte Action;
    byte ChannelWidth;
}

// 802.11 - 2012 section 8.5.12.3 SM Power Save frame format
type SMPowerSave
{
    byte Category;
    byte Action;
    SMPowerControl SMPowerControl;
}

// 802.11 - 2012 section 8.5.12.4 PSMP frame format
type PSMP
{
    byte Category;
    byte Action;
    PSMPParameterSet PSMPParameterSet;
    array<PSMPSTAInfo> PSMPSTAInfo with BinaryEncoding{Length = PSMPParameterSet.NSTA};
}

// 802.11 - 2012 section 8.5.12.5 Set PCO Phase frame format
type SetPCOPhase
{
    byte Category;
    byte Action;
    byte PCOPhaseControl;
}

// 802.11 - 2012 section 8.5.12.6 CSI frame format
type CSI
{
    byte Category;
    byte Action;
    MIMOControl MIMOControl;
    ([|MIMOControl.MIMOControlChannelWidth == 0|] CSIReport[CountIncrease(MIMOControl.NcIndex as uint), CSIReportNbCountTransform(MIMOControl.CoefficientSize as uint), CountIncrease(MIMOControl.NrIndex as uint), CarrierCountTransform20MHz(MIMOControl.Grouping as uint)] | 
    [|MIMOControl.MIMOControlChannelWidth == 1|] CSIReport[CountIncrease(MIMOControl.NcIndex as uint), CSIReportNbCountTransform(MIMOControl.CoefficientSize as uint), CountIncrease(MIMOControl.NrIndex as uint), CarrierCountTransform40MHz(MIMOControl.Grouping as uint)]) CSIReport;
}

// 802.11 - 2012 section 8.5.12.7 Noncompressed Beamforming frame format
type NoncompressedBeamforming
{
    byte Category;
    byte Action;
    MIMOControl MIMOControl;
    ((NoncompressedBeamformingReport[CountIncrease(MIMOControl.NcIndex as uint), NoncompressedBeamformingReportNbCountTransform(MIMOControl.CoefficientSize as uint), CountIncrease(MIMOControl.NrIndex as uint), CarrierCountTransform20MHz(MIMOControl.Grouping as uint)] where MIMOControl.MIMOControlChannelWidth == 0) | 
    (NoncompressedBeamformingReport[CountIncrease(MIMOControl.NcIndex as uint), NoncompressedBeamformingReportNbCountTransform(MIMOControl.CoefficientSize as uint), CountIncrease(MIMOControl.NrIndex as uint), CarrierCountTransform40MHz(MIMOControl.Grouping as uint)] where MIMOControl.MIMOControlChannelWidth == 1)) CSIReport;
}

type NoncompressedBeamformingReport[uint NcCount, uint NbCount, uint NrCount, uint CarrierCount]
{
    array<byte> SNR with BinaryEncoding{Length = NcCount};
    array<NoncompressedBeamformingFeedbackMatrix[NcCount, NbCount, NrCount]> Matrixes with BinaryEncoding{Length = CarrierCount};
}

type NoncompressedBeamformingFeedbackMatrix[uint NcCount, uint NbCount, uint NrCount]
{
    array<Bit> Bits with BinaryEncoding{Length = 2 * NbCount * NcCount * NrCount};
}

uint NoncompressedBeamformingReportNbCountTransform(uint input)
{
    switch (input)
    {
        case 0 =>
            return 4;
        case 1 =>
            return 2;
        case 2 =>
            return 6;
        case 3 =>
            return 8;
        default =>
            return 0;
    }
}

// 802.11 - 2012 section 8.5.12.8 Compressed Beamforming frame format
type CompressedBeamforming
{
    byte Category;
    byte Action;
    MIMOControl MIMOControl;
    ([|MIMOControl.MIMOControlChannelWidth == 0|] CompressedBeamformingReport[CountIncrease(MIMOControl.NcIndex as uint), NaCountTransform(CountIncrease(MIMOControl.NcIndex as uint), CountIncrease(MIMOControl.NrIndex as uint)), CarrierCountTransform20MHz(MIMOControl.Grouping as uint), Bit1Count(MIMOControl.CodebookInformation as uint), Bit2Count(MIMOControl.CodebookInformation as uint)] | 
    [|MIMOControl.MIMOControlChannelWidth == 1|] CompressedBeamformingReport[CountIncrease(MIMOControl.NcIndex as uint), NaCountTransform(CountIncrease(MIMOControl.NcIndex as uint), CountIncrease(MIMOControl.NrIndex as uint)), CarrierCountTransform40MHz(MIMOControl.Grouping as uint), Bit1Count(MIMOControl.CodebookInformation as uint), Bit2Count(MIMOControl.CodebookInformation as uint)]) CSIReport;
}

type CompressedBeamformingReport[uint NcCount, uint NaCount, uint Bit1Count, uint Bit2Count, uint CarrierCount]
{
    array<byte> SNR with BinaryEncoding{Length = NcCount};
    array<CompressedBeamformingFeedbackMatrix[NaCount, Bit1Count, Bit2Count]> Matrixes with BinaryEncoding{Length = CarrierCount};
}

type CompressedBeamformingFeedbackMatrix[uint NaCount, uint Bit1Count, uint Bit2Count]
{
    array<Bit> Bits with BinaryEncoding{Length = NaCount * ((Bit1Count + Bit2Count) / 2)};
}

uint NaCountTransform(uint ncCount, uint nrCount)
{
    if (nrCount == 2 && ncCount == 1)
    {
        return 2;
    }
    else if (nrCount == 2 && ncCount == 2)
    {
        return 2;
    }
    else if (nrCount == 3 && ncCount == 1)
    {
        return 4;
    }
    else if (nrCount == 3 && ncCount == 2)
    {
        return 6;
    }
    else if (nrCount == 3 && ncCount == 3)
    {
        return 6;
    }
    else if (nrCount == 4 && ncCount == 1)
    {
        return 6;
    }
    else if (nrCount == 4 && ncCount == 2)
    {
        return 10;
    }
    else if (nrCount == 4 && ncCount == 3)
    {
        return 10;
    }
    else if (nrCount == 4 && ncCount == 4)
    {
        return 2;
    }
    else
    {
        return 0;
    }
}

uint Bit1Count(uint input)
{
    return input + 1;
}

uint Bit2Count(uint input)
{
    return input + 3;
}

// 802.11 - 2012 section 7.4.10.9 Antenna Selection Indices Feedback frame format
type ASELIndicesFeedback
{
    byte Category;
    byte Action;
    byte AntennaSelectionIndices;
}

// WSA Action, Category == 8
pattern WSAAction = [|RemainingBitLength(stream) >= 16|]
    ([|PeekByte(stream, stream.BitPosition + 8) == 0x00|] SAQueryRequest | // 0
    [|PeekByte(stream, stream.BitPosition + 8) == 0x01|] SAQueryResponse); //1

// 802.11 - 2012 section 8.5.10.2 SA Query Request frame
type SAQueryRequest
{
    byte Category;
    byte Action;
    ushort TransactionIdentifier;
}

// 802.11 - 2012 section 8.5.10.3 SA Query Response frame
type SAQueryResponse
{
    byte Category;
    byte Action;
    ushort TransactionIdentifier;
}

pattern InformationField = [|RemainingByteLength(stream) >= 2|]
    ([|CurrentByte(stream) == 0 && PeekByte(stream, stream.BitPosition + 8) <= 32|] SSID |
    [|CurrentByte(stream) == 1 && PeekByte(stream, stream.BitPosition + 8) >= 1 && PeekByte(stream, stream.BitPosition + 8) <= 8|] SupportedRates |
    [|CurrentByte(stream) == 2 && PeekByte(stream, stream.BitPosition + 8) == 5|] FHParameterSet |
    [|CurrentByte(stream) == 3 && PeekByte(stream, stream.BitPosition + 8) == 1|] DSParameterSet |
    [|CurrentByte(stream) == 4 && PeekByte(stream, stream.BitPosition + 8) == 6|] CFParameterSet |
    [|CurrentByte(stream) == 5 && PeekByte(stream, stream.BitPosition + 8) >= 3|] TIM |
    [|CurrentByte(stream) == 6 && PeekByte(stream, stream.BitPosition + 8) == 2|] IBSSParameterSet |
    [|CurrentByte(stream) == 7 && PeekByte(stream, stream.BitPosition + 8) >= 6|] Country |
    [|CurrentByte(stream) == 8 && PeekByte(stream, stream.BitPosition + 8) == 6|] HoppingPatternParameters |
    [|CurrentByte(stream) == 9 && PeekByte(stream, stream.BitPosition + 8) >= 4|] HoppingPatternTable |
    [|CurrentByte(stream) == 10|] Request |
    [|CurrentByte(stream) == 11 && PeekByte(stream, stream.BitPosition + 8) == 5|] BSSLoad |
    [|CurrentByte(stream) == 12 && PeekByte(stream, stream.BitPosition + 8) == 18|] EDCAParameterSet |
    [|CurrentByte(stream) == 13 && PeekByte(stream, stream.BitPosition + 8) == 55|] TSPEC |
    [|CurrentByte(stream) == 14|] TCLAS |
    [|CurrentByte(stream) == 15 && PeekByte(stream, stream.BitPosition + 8) == 12|] Schedule |
    [|CurrentByte(stream) == 16|] ChallengeText |
    [|CurrentByte(stream) == 32 && PeekByte(stream, stream.BitPosition + 8) == 1|] PowerConstraint |
    [|CurrentByte(stream) == 33 && PeekByte(stream, stream.BitPosition + 8) == 2|] PowerCapability |
    [|CurrentByte(stream) == 34 && PeekByte(stream, stream.BitPosition + 8) == 0|] TPCRequest |
    [|CurrentByte(stream) == 35 && PeekByte(stream, stream.BitPosition + 8) == 2|] TPCReport |
    [|CurrentByte(stream) == 36 && PeekByte(stream, stream.BitPosition + 8) % 2 == 0|] SupportedChannels |
    [|CurrentByte(stream) == 37 && PeekByte(stream, stream.BitPosition + 8) == 3|] ChannelSwitchAnnouncement |
    [|CurrentByte(stream) == 38|] MeasurementRequest |
    [|CurrentByte(stream) == 39|] MeasurementReport |
    [|CurrentByte(stream) == 40 && PeekByte(stream, stream.BitPosition + 8) == 6|] Quiet |
    [|CurrentByte(stream) == 41 && PeekByte(stream, stream.BitPosition + 8) >= 7 && (PeekByte(stream, stream.BitPosition + 8) - 7) % 2 == 0|] IBSSDFS |
    [|CurrentByte(stream) == 42 && PeekByte(stream, stream.BitPosition + 8) == 1|] ERPInformation |
    [|CurrentByte(stream) == 43 && PeekByte(stream, stream.BitPosition + 8) == 4|] TSDelay |
    [|CurrentByte(stream) == 44 && PeekByte(stream, stream.BitPosition + 8) == 1|] TCLASProcessing |
    [|CurrentByte(stream) == 45 && PeekByte(stream, stream.BitPosition + 8) == 26|] HTCapabilities |
    [|CurrentByte(stream) == 46 && PeekByte(stream, stream.BitPosition + 8) == 1|] QoSCapability |
    [|CurrentByte(stream) == 47|] Reserved |
    [|CurrentByte(stream) == 48|] RSN |
    [|CurrentByte(stream) == 50|] ExtendedSupportedRates |
    [|CurrentByte(stream) == 51 && PeekByte(stream, stream.BitPosition + 8) >= 1|] APChannelReport |
    [|CurrentByte(stream) == 52|] NeighborReport |
    [|CurrentByte(stream) == 53 && PeekByte(stream, stream.BitPosition + 8) == 1|] RCPI |
    [|CurrentByte(stream) == 54 && PeekByte(stream, stream.BitPosition + 8) == 3|] MobilityDomain |
    [|CurrentByte(stream) == 56 && PeekByte(stream, stream.BitPosition + 8) == 5|] TimeoutInterval |
    [|CurrentByte(stream) == 57 && PeekByte(stream, stream.BitPosition + 8) == 4|] RICData |
    [|CurrentByte(stream) == 58 && PeekByte(stream, stream.BitPosition + 8) == 20|] DSERegisteredLocation |
    [|CurrentByte(stream) == 59 && PeekByte(stream, stream.BitPosition + 8) == 4|] SupportedOperatingClasses |
    [|CurrentByte(stream) == 60 && PeekByte(stream, stream.BitPosition + 8) == 4|] ExtendedChannelSwitchAnnouncement |
    [|CurrentByte(stream) == 61 && PeekByte(stream, stream.BitPosition + 8) == 22|] HTOperation |
    [|CurrentByte(stream) == 62 && PeekByte(stream, stream.BitPosition + 8) == 1|] SecondaryChannelOffset |
    [|CurrentByte(stream) == 63 && PeekByte(stream, stream.BitPosition + 8) == 1|] BSSAverageAccessDelay |
    [|CurrentByte(stream) == 64 && PeekByte(stream, stream.BitPosition + 8) == 1|] AntennaInformation |
    [|CurrentByte(stream) == 65 && PeekByte(stream, stream.BitPosition + 8) == 1|] RSNI |
    [|CurrentByte(stream) == 66|] MeasurementPilotTransmissionInformation |
    [|CurrentByte(stream) == 67|] BSSAvailableAdmissionCapacity |
    [|CurrentByte(stream) == 68 && PeekByte(stream, stream.BitPosition + 8) == 4|] BSSACAccessDelay |
    [|CurrentByte(stream) == 70 && PeekByte(stream, stream.BitPosition + 8) == 5|] RRMEnabledCapabilities |
    [|CurrentByte(stream) == 71|] MultipleBSSID |
    [|CurrentByte(stream) == 72 && PeekByte(stream, stream.BitPosition + 8) == 1|] WiFi20or40BSSCoexistence |
    [|CurrentByte(stream) == 73|] WiFi20and40BSSIntolerantChannelReport |
    [|CurrentByte(stream) == 74 && PeekByte(stream, stream.BitPosition + 8) == 14|] OverlappingBSSScanParameters |
    [|CurrentByte(stream) == 75|] RICDescriptor |
    [|CurrentByte(stream) == 76 && (PeekByte(stream, stream.BitPosition + 8) == 16 || PeekByte(stream, stream.BitPosition + 8) == 24)|] ManagementMicInformation |
    [|CurrentByte(stream) == 107|] InterworkingInformation |
    [|CurrentByte(stream) == 108|] AdvertisementProtocol |
    [|CurrentByte(stream) == 109 && PeekByte(stream, stream.BitPosition + 8) == 1|] ExpeditedBandwidthRequestInformation |
    [|CurrentByte(stream) == 110|] QosMapSetinformation |
    [|CurrentByte(stream) == 111|] RoamingConsortiumInformation |
    [|CurrentByte(stream) == 112|] EmergencyAlertIdentifierInformation |
    [|CurrentByte(stream) == 118 && PeekByte(stream, stream.BitPosition + 8) == 6|] MeshChannelSwitchParameters |
    [|CurrentByte(stream) == 127|] ExtendedCapabilities |
    [|CurrentByte(stream) == 221|] VendorSpecificInformation |
    // defined in 802.11ac
    [|CurrentByte(stream) == 191 && PeekByte(stream, stream.BitPosition + 8) == 12|] VHTCapabilities |
    [|CurrentByte(stream) == 192 && PeekByte(stream, stream.BitPosition + 8) == 5|] VHTOperation |
    [|CurrentByte(stream) == 193 && PeekByte(stream, stream.BitPosition + 8) == 6|] ExtendedBSSLoad |
    [|CurrentByte(stream) == 194 && PeekByte(stream, stream.BitPosition + 8) == 3|] WideBandwidthChannelSwitchElement |
    [|CurrentByte(stream) == 195 && (PeekByte(stream, stream.BitPosition + 8) >= 2)|] VHTTransmitPowerEnvelope |
    [|CurrentByte(stream) == 196 && PeekByte(stream, stream.BitPosition + 8) >= 5|] ChannelSwitchWrapper |
    [|CurrentByte(stream) == 197 && PeekByte(stream, stream.BitPosition + 8) == 2|] AIDElement |
    [|CurrentByte(stream) == 198 && (PeekByte(stream, stream.BitPosition + 8) == 1 || PeekByte(stream, stream.BitPosition + 8) == 7)|] QuietChannel |
    [|CurrentByte(stream) == 199 && PeekByte(stream, stream.BitPosition + 8) == 1|] OperatingModeNotification |
    GeneralElement);

// 802.11 - 2012 section 11. Security
pattern EncryptedFramePattern = WEP | TKIP | CCMP;
// 802.11 - 2012 section 11.2.2.2 WEP MPDU format
type WEP
{
    IV IV;
    binary EncryptedData; // Encrypted
    // uint ICV; // Encrypted
}

// The ordering conventions defined in 8.2.2 apply to the IV field and its subfields and to the ICV field
type IV
{
    binary InitVector with BinaryEncoding{Length = 3};
    byte KeyID with BinaryEncoding{Width = 2};
    byte Pad with BinaryEncoding{Width = 6};
}

// 802.11 - 2012 section 11.4.2.2 TKIP MPDU formats
type TKIP
{
    IVKeyID IVKeyID;
    ExtendedIV ExtendedIV;
    binary EncryptedData; // Encrypted
    // ulong MIC; // Encrypted
    // uint ICV; // Encrypted
}

type IVKeyID
{
    byte TSC1;
    byte WEPSeed;
    byte TSC0;
    byte KeyID with BinaryEncoding{Width = 2};
    byte ExtIV with BinaryEncoding{Width = 1};
    byte Pad with BinaryEncoding{Width = 5};
}

type ExtendedIV
{
    byte TSC2;
    byte TSC3;
    byte TSC4;
    byte TSC5;
}

// 802.11 - 2012 section 11.4.3.2 CCMP MPDU format
type CCMP
{
    CCMPHeader Header;
    binary EncryptedData; // Encrypted
    // ulong MIC; // Encrypted
}

type CCMPHeader
{
    byte PN0;
    byte PN1;
    byte Rsvd;
    byte KeyID with BinaryEncoding{Width = 2};
    byte ExtIV with BinaryEncoding{Width = 1};
    byte Pad with BinaryEncoding{Width = 5};
    byte PN2;
    byte PN3;
    byte PN4;
    byte PN5;
}

// ========================= Others =============================
string MessageNaming(byte msgType, byte subtype)
{
    switch (msgType)
    {
        case MessageType.Management =>
            switch (subtype)
            {
                case ManagementSubType.AssociationRequest => return "Management Association Request";
                case ManagementSubType.AssociationResponse => return "Management Association Response";
                case ManagementSubType.ReassociationRequest => return "Management Reassociation Request";
                case ManagementSubType.ReassociationResponse => return "Management Reassociation Response";
                case ManagementSubType.ProbeRequest => return "Management Probe Request";
                case ManagementSubType.ProbeResponse => return "Management Probe Response";
                case ManagementSubType.Beacon => return "Management Beacon";
                case ManagementSubType.ATIM => return "Management ATIM";
                case ManagementSubType.Disassociation => return "Management Disassociation";
                case ManagementSubType.Authentication => return "Management Authentication";
                case ManagementSubType.Deauthentication => return "Management Deauthentication";
                case ManagementSubType.Action => return "Management Action";
                case ManagementSubType.ActionNoAck => return "Management Action No Ack";
                default =>;
            }
        case MessageType.Control =>
            switch (subtype)
            {
                case ControlSubType.BlockAckReq =>  return "Control Block Ack Request";
                case ControlSubType.BlockAck =>  return "Control Block Ack";
                case ControlSubType.PSPoll =>  return "Control PS-Poll";
                case ControlSubType.RTS =>  return "Control RTS";
                case ControlSubType.CTS =>  return "Control CTS";
                case ControlSubType.ACK =>  return "Control ACK";
                case ControlSubType.CFEnd =>  return "Control CF-End";
                case ControlSubType.CFEndCFAck =>  return "Control CF-End + CF-Ack";
                default =>;
            }
        case MessageType.Data =>
            switch (subtype)
            {
                case DataSubType.Data => return "Data";
                case DataSubType.DataCFAck => return "Data + CF-Ack";
                case DataSubType.DataCFPoll => return "Data + CF-Poll";
                case DataSubType.DataCFAckCFPoll => return "Data + CF-Ack + CF-Poll";
                case DataSubType.Null => return "Null(no data)";
                case DataSubType.CFAck => return "CF-Ack(no data)";
                case DataSubType.CFPoll => return "CF-Poll(no data)";
                case DataSubType.CFAckCFPoll => return "CF-Ack + CF-Poll(no data)";
                case DataSubType.QoSData => return "QoS Data";
                case DataSubType.QoSDataCFAck => return "QoS Data + CF-Ack";
                case DataSubType.QoSDataCFPoll => return "QoS Data + CF-Poll";
                case DataSubType.QoSDataCFAckCFPoll => return "QoS Data + CF-Ack + CFPoll";
                case DataSubType.QoSNull => return "QoS Null(no data)";
                case DataSubType.Reserved => return "Reserved";
                case DataSubType.QoSCFPoll => return "QoS CF-Poll(no data)";
                case DataSubType.QoSCFAckCFPoll => return "QoS CF-Ack + CF-Poll(no data)";
                default =>;
            }
        default =>;
    }
    return "Unknown message type, Type: " + (msgType as string) + ", SubType: " + (subtype as string);
}

string GetSSIDString(WiFiMessage msg, byte subType)
{
    var frame = msg.Body;
    switch (subType)
    {
        case 0 =>
            if (frame is associationRequestFrame:AssociationRequestFrame)
            {
                foreach (var e in associationRequestFrame.InformationElements)
                {
                    if (e is id:SSID && id.Length > 0)
                        return ", SSID: " + id.SSID.ToString();
                }
            }
        case 1 =>
            if (frame is associationResponseFrame:AssociationResponseFrame)
            {
                foreach (var e in associationResponseFrame.InformationElements)
                {
                    if (e is id:SSID && id.Length > 0)
                        return ", SSID: " + id.SSID.ToString();
                }
            }
        case 2 =>
            if (frame is reassociationRequestFrame:ReassociationRequestFrame)
            {
                foreach (var e in reassociationRequestFrame.InformationElements)
                {
                    if (e is id:SSID && id.Length > 0)
                        return ", SSID: " + id.SSID.ToString();
                }
            }
        case 3 =>
            if (frame is reassociationResponseFrame:ReassociationResponseFrame)
            {
                foreach (var e in reassociationResponseFrame.InformationElements)
                {
                    if (e is id:SSID && id.Length > 0)
                        return ", SSID: " + id.SSID.ToString();
                }
            }
        case 4 =>
            if (frame is probeRequestFrame:ProbeRequestFrame)
            {
                foreach (var e in probeRequestFrame.InformationElements)
                {
                    if (e is id:SSID && id.Length > 0)
                        return ", SSID: " + id.SSID.ToString();
                }
            }
        case 5 =>
            if (frame is probeResponseFrame:ProbeResponseFrame)
            {
                foreach (var e in probeResponseFrame.InformationElements)
                {
                    if (e is id:SSID && id.Length > 0)
                        return ", SSID: " + id.SSID.ToString();
                }
            }
        case 8 =>
            if (frame is beaconFrame:BeaconFrame)
            {
                foreach (var e in beaconFrame.InformationElements)
                {
                    if (e is id:SSID && id.Length > 0)
                        return ", SSID: " + id.SSID.ToString();
                }
            }
        case 10 =>
            if (frame is disassociationFrame:DisassociationFrame)
            {
                foreach (var e in disassociationFrame.InformationElements)
                {
                    if (e is id:SSID && id.Length > 0)
                        return ", SSID: " + id.SSID.ToString();
                }
            }
        case 11 =>
            if (frame is authenticationFrame:AuthenticationFrame)
            {
                foreach (var e in authenticationFrame.InformationElements)
                {
                    if (e is id:SSID && id.Length > 0)
                        return ", SSID: " + id.SSID.ToString();
                }
            }
        case 12 =>
            if (frame is deauthentication:Deauthentication)
            {
                foreach (var e in deauthentication.InformationElements)
                {
                    if (e is id:SSID && id.Length > 0)
                        return ", SSID: " + id.SSID.ToString();
                }
            }
        case 13 =>
            if (frame is actionNoAckFrame:ActionNoAckFrame)
            {
                foreach (var e in actionNoAckFrame.InformationElements)
                {
                    if (e is id:SSID && id.Length > 0)
                        return ", SSID: " + id.SSID.ToString();
                }
            }
        default =>;
    }
    return "";
}

string GetControlInfor(WiFiMessage frame)
{
    string summary = "";
    FrameControl ctrl = (frame.MacHeader as MacHeaderBase).FrameControl as FrameControl;
    summary = summary + (ctrl.ToDS ? "T" : ".");
    summary = summary + (ctrl.FromDS ? "F" : ".");
    summary = summary + (ctrl.MoreFrag ? "M" : ".");
    summary = summary + (ctrl.Retry ? "R" : ".");
    summary = summary + (ctrl.PwrMgt ? "P" : ".");
    summary = summary + (ctrl.MoreData ? "D" : ".");
    summary = summary + (ctrl.ProtectedFrame ? "P" : ".");
    summary = summary + (ctrl.Order ? "O" : ".");
    return summary;
}

type WiFiGasReassemblyHelper
{
   // cache all received WiFiMessage fragements for GAS reassembly.
    // outter key is GasComebackResponse.DialogToken, inner key is GasComebackResponse..GasQueryResponseFragmentId
    map<byte, map<byte, WiFiMessage>> Fragments = {};
    // expected fragment count of each Dialog, the key is GasComebackResponse.DialogToken
    map<byte, byte> ExpectedFragmentCount = {};

    // cache all received GasComebackRequest
    map<byte, array<WiFiMessage>> CachedRequest = {};
}

// To workaround BinaryDecoder<Array<A|B>> failure
type AnqpElementArrayWrapper
{
    array<AnqpElementPattern> Elements;
}

pattern HasFCS = enum byte
{
    Yes,
    No,
    Unknown
};

bool IsKnownWiFiMessage(byte msgType, byte subtype)
{
    switch (msgType)
    {
        case MessageType.Management =>
            return subtype != ManagementSubType.Reserved1 && subtype != ManagementSubType.Reserved2 &&
                InRange<ManagementSubType>(subtype);
        case MessageType.Control =>
            return InRange<ControlSubType>(subtype);
        case MessageType.Data =>
            return subtype <= 15;
        default =>
            return false;
    }
}
